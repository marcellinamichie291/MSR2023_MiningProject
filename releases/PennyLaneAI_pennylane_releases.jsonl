{"url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/78185945", "assets_url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/78185945/assets", "upload_url": "https://uploads.github.com/repos/PennyLaneAI/pennylane/releases/78185945/assets{?name,label}", "html_url": "https://github.com/PennyLaneAI/pennylane/releases/tag/v0.26.0-postfix-1", "id": 78185945, "author": {"login": "josh146", "id": 2959003, "node_id": "MDQ6VXNlcjI5NTkwMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/2959003?v=4", "gravatar_id": "", "url": "https://api.github.com/users/josh146", "html_url": "https://github.com/josh146", "followers_url": "https://api.github.com/users/josh146/followers", "following_url": "https://api.github.com/users/josh146/following{/other_user}", "gists_url": "https://api.github.com/users/josh146/gists{/gist_id}", "starred_url": "https://api.github.com/users/josh146/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/josh146/subscriptions", "organizations_url": "https://api.github.com/users/josh146/orgs", "repos_url": "https://api.github.com/users/josh146/repos", "events_url": "https://api.github.com/users/josh146/events{/privacy}", "received_events_url": "https://api.github.com/users/josh146/received_events", "type": "User", "site_admin": false}, "node_id": "RE_kwDOB76r6M4EqQXZ", "tag_name": "v0.26.0-postfix-1", "target_commitish": "v0.26.0-postfix1", "name": "Release 0.26.0-postfix1", "draft": false, "prerelease": false, "created_at": "2022-09-26T20:04:35Z", "published_at": "2022-09-26T20:10:11Z", "assets": [], "tarball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/tarball/v0.26.0-postfix-1", "zipball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/zipball/v0.26.0-postfix-1", "body": "A minor postfix release to update the documentation styling."}
{"url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/77559696", "assets_url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/77559696/assets", "upload_url": "https://uploads.github.com/repos/PennyLaneAI/pennylane/releases/77559696/assets{?name,label}", "html_url": "https://github.com/PennyLaneAI/pennylane/releases/tag/v0.26.0", "id": 77559696, "author": {"login": "rmoyard", "id": 36766072, "node_id": "MDQ6VXNlcjM2NzY2MDcy", "avatar_url": "https://avatars.githubusercontent.com/u/36766072?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rmoyard", "html_url": "https://github.com/rmoyard", "followers_url": "https://api.github.com/users/rmoyard/followers", "following_url": "https://api.github.com/users/rmoyard/following{/other_user}", "gists_url": "https://api.github.com/users/rmoyard/gists{/gist_id}", "starred_url": "https://api.github.com/users/rmoyard/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rmoyard/subscriptions", "organizations_url": "https://api.github.com/users/rmoyard/orgs", "repos_url": "https://api.github.com/users/rmoyard/repos", "events_url": "https://api.github.com/users/rmoyard/events{/privacy}", "received_events_url": "https://api.github.com/users/rmoyard/received_events", "type": "User", "site_admin": false}, "node_id": "RE_kwDOB76r6M4En3eQ", "tag_name": "v0.26.0", "target_commitish": "v0.26.0-rc0", "name": "Release 0.26.0", "draft": false, "prerelease": false, "created_at": "2022-09-19T17:44:56Z", "published_at": "2022-09-19T17:48:53Z", "assets": [], "tarball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/tarball/v0.26.0", "zipball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/zipball/v0.26.0", "body": "<h3>New features since last release</h3>\r\n\r\n<h4>Classical shadows \ud83d\udc64</h4>\r\n\r\n* PennyLane now provides built-in support for implementing the classical-shadows measurement protocol. [(#2820)](https://github.com/PennyLaneAI/pennylane/pull/2820) [(#2821)](https://github.com/PennyLaneAI/pennylane/pull/2821) [(#2871)](https://github.com/PennyLaneAI/pennylane/pull/2871) [(#2968)](https://github.com/PennyLaneAI/pennylane/pull/2968) [(#2959)](https://github.com/PennyLaneAI/pennylane/pull/2959) [(#2968)](https://github.com/PennyLaneAI/pennylane/pull/2968)\r\n\r\n  The classical-shadow measurement protocol is described in detail in the paper [Predicting Many Properties of a Quantum System from Very Few Measurements](https://arxiv.org/abs/2002.08953). As part of the support for classical shadows in this release, two new finite-shot and fully-differentiable measurements are available: \r\n\r\n  - QNodes returning the new measurement `qml.classical_shadow()` will return two entities; `bits` (0 or 1 if the 1 or -1 eigenvalue is sampled, respectively) and `recipes` (the randomized Pauli measurements that are performed for each qubit, labelled by integer):\r\n    \r\n    ```python\r\n    dev = qml.device(\"default.qubit\", wires=2, shots=3)\r\n\r\n    @qml.qnode(dev)\r\n    def circuit():\r\n        qml.Hadamard(wires=0)\r\n        qml.CNOT(wires=[0, 1])\r\n        return qml.classical_shadow(wires=[0, 1])\r\n    ```\r\n\r\n    ```pycon\r\n    >>> bits, recipes = circuit()\r\n    >>> bits\r\n    tensor([[0, 0],\r\n            [1, 0],\r\n            [0, 1]], dtype=uint8, requires_grad=True)\r\n    >>> recipes\r\n    tensor([[2, 2],\r\n            [0, 2],\r\n            [0, 2]], dtype=uint8, requires_grad=True)\r\n    ```\r\n\r\n  - QNodes returning `qml.shadow_expval()` yield the expectation value estimation using classical shadows:\r\n\r\n    ```python\r\n    dev = qml.device(\"default.qubit\", wires=range(2), shots=10000)\r\n\r\n    @qml.qnode(dev)\r\n    def circuit(x, H):\r\n        qml.Hadamard(0)\r\n        qml.CNOT((0,1))\r\n        qml.RX(x, wires=0)\r\n        return qml.shadow_expval(H)\r\n\r\n    x = np.array(0.5, requires_grad=True) \r\n    H = qml.Hamiltonian(\r\n            [1., 1.], \r\n            [qml.PauliZ(0) @ qml.PauliZ(1), qml.PauliX(0) @ qml.PauliX(1)]\r\n        )  \r\n    ```\r\n\r\n    ```pycon\r\n    >>> circuit(x, H)\r\n    tensor(1.8486, requires_grad=True) \r\n    >>> qml.grad(circuit)(x, H)\r\n    -0.4797000000000001\r\n    ```\r\n\r\n  Fully-differentiable QNode transforms for both new classical-shadows measurements are also available via `qml.shadows.shadow_state` and `qml.shadows.shadow_expval`, respectively.\r\n  \r\n  For convenient post-processing, we've also added the ability to calculate general Renyi entropies by way of the `ClassicalShadow` class' `entropy` method, which requires the wires of the subsystem of interest and the Renyi entropy order:\r\n\r\n  ```pycon\r\n  >>> shadow = qml.ClassicalShadow(bits, recipes)\r\n  >>> vN_entropy = shadow.entropy(wires=[0, 1], alpha=1)\r\n  ``` \r\n\r\n<h4>Qutrits: quantum circuits for tertiary degrees of freedom \u2618\ufe0f</h4>\r\n\r\n* An entirely new framework for quantum computing is now simulatable with the addition of qutrit functionalities. [(#2699)](https://github.com/PennyLaneAI/pennylane/pull/2699) [(#2781)](https://github.com/PennyLaneAI/pennylane/pull/2781) [(#2782)](https://github.com/PennyLaneAI/pennylane/pull/2782) [(#2783)](https://github.com/PennyLaneAI/pennylane/pull/2783) [(#2784)](https://github.com/PennyLaneAI/pennylane/pull/2784) [(#2841)](https://github.com/PennyLaneAI/pennylane/pull/2841) [(#2843)](https://github.com/PennyLaneAI/pennylane/pull/2843)\r\n\r\n  [Qutrits](https://en.wikipedia.org/wiki/Qutrit) are like qubits, but instead live in a *three*-dimensional Hilbert space; they are not binary degrees of freedom, they are *tertiary*. The advent of qutrits allows for all sorts of interesting theoretical, practical, and algorithmic capabilities that have yet to be discovered.\r\n  \r\n  To facilitate qutrit circuits requires a new device: `default.qutrit`. The `default.qutrit` device is a Python-based simulator, akin to `default.qubit`, and is defined as per usual:\r\n\r\n  ```pycon\r\n  >>> dev = qml.device(\"default.qutrit\", wires=1)\r\n  ```\r\n\r\n  The following operations are supported on `default.qutrit` devices:\r\n\r\n  - The qutrit shift operator, `qml.TShift`, and the ternary clock operator, `qml.TClock`, as defined in this paper by [Yeh et al. (2022)](https://arxiv.org/abs/2204.00552),\r\n  which are the qutrit analogs of the Pauli X and Pauli Z operations, respectively.\r\n  - The `qml.TAdd` and `qml.TSWAP` operations which are the qutrit analogs of the CNOT and SWAP operations, respectively.\r\n  - Custom unitary operations via `qml.QutritUnitary`.\r\n  - `qml.state` and `qml.probs` measurements.\r\n  - Measuring user-specified Hermitian matrix observables via `qml.THermitian`.\r\n\r\n  A comprehensive example of these features is given below:\r\n\r\n  ```python\r\n  dev = qml.device(\"default.qutrit\", wires=1)\r\n\r\n  U = np.array([\r\n          [1, 1, 1], \r\n          [1, 1, 1], \r\n          [1, 1, 1]\r\n      ]\r\n  ) / np.sqrt(3) \r\n\r\n  obs = np.array([\r\n          [1, 1, 0], \r\n          [1, -1, 0], \r\n          [0, 0, np.sqrt(2)]\r\n      ]\r\n  ) / np.sqrt(2)\r\n\r\n  @qml.qnode(dev)\r\n  def qutrit_state(U, obs):\r\n      qml.TShift(0)\r\n      qml.TClock(0)\r\n      qml.QutritUnitary(U, wires=0)\r\n      return qml.state()\r\n\r\n  @qml.qnode(dev)\r\n  def qutrit_expval(U, obs):\r\n      qml.TShift(0)\r\n      qml.TClock(0)\r\n      qml.QutritUnitary(U, wires=0)\r\n      return qml.expval(qml.THermitian(obs, wires=0))\r\n  ```\r\n\r\n  ```pycon\r\n  >>> qutrit_state(U, obs)\r\n  tensor([-0.28867513+0.5j, -0.28867513+0.5j, -0.28867513+0.5j], requires_grad=True) \r\n  >>> qutrit_expval(U, obs)\r\n  tensor(0.80473785, requires_grad=True)\r\n  ```\r\n\r\n  We will continue to add more and more support for qutrits in future releases.\r\n\r\n<h4>Simplifying just got... simpler \ud83d\ude0c</h4>\r\n\r\n* The `qml.simplify()` function has several intuitive improvements with this release. [(#2978)](https://github.com/PennyLaneAI/pennylane/pull/2978) [(#2982)](https://github.com/PennyLaneAI/pennylane/pull/2982) [(#2922)](https://github.com/PennyLaneAI/pennylane/pull/2922) [(#3012)](https://github.com/PennyLaneAI/pennylane/pull/3012)\r\n\r\n  `qml.simplify` can now perform the following:\r\n\r\n  - simplify parametrized operations\r\n  - simplify the adjoint and power of specific operators\r\n  - group like terms in a sum\r\n  - resolve products of Pauli operators\r\n  - combine rotation angles of identical rotation gates\r\n\r\n  Here is an example of `qml.simplify` in action with parameterized rotation gates. In this case, the angles of rotation are simplified to be modulo $4\\pi$.\r\n\r\n  ```pycon\r\n  >>> op1 = qml.RX(30.0, wires=0)\r\n  >>> qml.simplify(op1)\r\n  RX(4.867258771281655, wires=[0])\r\n  >>> op2 = qml.RX(4 * np.pi, wires=0)\r\n  >>> qml.simplify(op2)\r\n  Identity(wires=[0])\r\n  ```\r\n  \r\n  All of these simplification features can be applied directly to quantum functions, QNodes, and tapes via decorating with `@qml.simplify`, as well:\r\n\r\n  ```python\r\n  dev = qml.device(\"default.qubit\", wires=2)\r\n  @qml.simplify\r\n  @qml.qnode(dev)\r\n  def circuit():\r\n      qml.adjoint(qml.prod(qml.RX(1, 0) ** 1, qml.RY(1, 0), qml.RZ(1, 0)))\r\n      return qml.probs(wires=0)\r\n  ```\r\n\r\n  ```pycon\r\n  >>> circuit()\r\n  >>> list(circuit.tape)\r\n  [RZ(11.566370614359172, wires=[0]) @ RY(11.566370614359172, wires=[0]) @ RX(11.566370614359172, wires=[0]),\r\n   probs(wires=[0])]\r\n  ```\r\n\r\n<h4>QNSPSA optimizer \ud83d\udcaa</h4>\r\n\r\n* A new optimizer called `qml.QNSPSAOptimizer` is available that implements the quantum natural simultaneous perturbation stochastic approximation (QNSPSA) method based on [Simultaneous Perturbation Stochastic Approximation of the Quantum Fisher Information](https://quantum-journal.org/papers/q-2021-10-20-567/). [(#2818)](https://github.com/PennyLaneAI/pennylane/pull/2818) \r\n\r\n  `qml.QNSPSAOptimizer` is a second-order [SPSA algorithm](https://en.wikipedia.org/wiki/Simultaneous_perturbation_stochastic_approximation), which combines the convergence power of the quantum-aware Quantum Natural Gradient (QNG) optimization method with the reduced quantum evaluations of SPSA methods.\r\n\r\n  While the QNSPSA optimizer requires additional circuit executions (10 executions per step) compared to standard SPSA optimization (3 executions per step), these additional evaluations are used to provide a stochastic estimation of a second-order metric tensor, which often helps the optimizer to achieve faster convergence.\r\n\r\n  Use `qml.QNSPSAOptimizer` like you would any other optimizer:\r\n  \r\n  ```python\r\n  max_iterations = 50\r\n  opt = qml.QNSPSAOptimizer() \r\n\r\n  for _ in range(max_iterations):\r\n      params, cost = opt.step_and_cost(cost, params)\r\n  ```  \r\n\r\n  Check out [our demo](https://pennylane.ai/qml/demos/qnspsa.html) on the QNSPSA optimizer for more information.\r\n\r\n<h4>Operator and parameter broadcasting supplements \ud83d\udcc8</h4>\r\n\r\n* Operator methods for exponentiation and raising to a power have been added. [(#2799)](https://github.com/PennyLaneAI/pennylane/pull/2799) [(#3029)](https://github.com/PennyLaneAI/pennylane/pull/3029)\r\n\r\n  - The `qml.exp` function can be used to create observables or generic rotation gates:\r\n\r\n    ```pycon\r\n    >>> x = 1.234\r\n    >>> t = qml.PauliX(0) @ qml.PauliX(1) + qml.PauliY(0) @ qml.PauliY(1)\r\n    >>> isingxy = qml.exp(t, 0.25j * x)\r\n    >>> isingxy.matrix()\r\n    array([[1.       +0.j        , 0.       +0.j        ,\r\n        1.       +0.j        , 0.       +0.j        ],\r\n       [0.       +0.j        , 0.8156179+0.j        ,\r\n        1.       +0.57859091j, 0.       +0.j        ],\r\n       [0.       +0.j        , 0.       +0.57859091j,\r\n        0.8156179+0.j        , 0.       +0.j        ],\r\n       [0.       +0.j        , 0.       +0.j        ,\r\n        1.       +0.j        , 1.       +0.j        ]]) \r\n    ```\r\n\r\n  - The `qml.pow` function raises a given operator to a power:\r\n\r\n    ```pycon\r\n    >>> op = qml.pow(qml.PauliX(0), 2)\r\n    >>> op.matrix()\r\n    array([[1, 0], [0, 1]])\r\n    ```\r\n\r\n* An operator called `qml.PSWAP` is now available. [(#2667)](https://github.com/PennyLaneAI/pennylane/pull/2667)\r\n\r\n  The `qml.PSWAP` gate -- or phase-SWAP gate -- was previously available within the PennyLane-Braket plugin only. Enjoy it natively in PennyLane with v0.26.\r\n\r\n* Check whether or not an operator is hermitian or unitary with `qml.is_hermitian` and `qml.is_unitary`. [(#2960)](https://github.com/PennyLaneAI/pennylane/pull/2960)\r\n\r\n  ```pycon\r\n  >>> op1 = qml.PauliX(wires=0)\r\n  >>> qml.is_hermitian(op1)\r\n  True\r\n  >>> op2 = qml.PauliX(0) + qml.RX(np.pi/3, 0) \r\n  >>> qml.is_unitary(op2)\r\n  False\r\n  ```\r\n\r\n* Embedding templates now support parameter broadcasting. [(#2810)](https://github.com/PennyLaneAI/pennylane/pull/2810)\r\n\r\n  Embedding templates like `AmplitudeEmbedding` or `IQPEmbedding` now support parameter broadcasting with a leading broadcasting dimension in their variational parameters. `AmplitudeEmbedding`, for example, would usually use a one-dimensional input vector of features. With broadcasting, we can now compute\r\n\r\n  ```pycon\r\n  >>> features = np.array([\r\n  ...     [0.5, 0.5, 0., 0., 0.5, 0., 0.5, 0.],\r\n  ...     [1., 0., 0., 0., 0., 0., 0., 0.],\r\n  ...     [0.5, 0.5, 0., 0., 0., 0., 0.5, 0.5],\r\n  ... ])\r\n  >>> op = qml.AmplitudeEmbedding(features, wires=[1, 5, 2])\r\n  >>> op.batch_size\r\n  3\r\n  ```\r\n\r\n  An exception is `BasisEmbedding`, which is not broadcastable.\r\n\r\n<h3>Improvements</h3>\r\n\r\n* The `qml.math.expand_matrix()` method now allows the sparse matrix representation of an operator to be extended to a larger hilbert space. [(#2998)](https://github.com/PennyLaneAI/pennylane/pull/2998)\r\n\r\n  ```pycon\r\n  >>> from scipy import sparse\r\n  >>> mat = sparse.csr_matrix([[0, 1], [1, 0]])\r\n  >>> qml.math.expand_matrix(mat, wires=[1], wire_order=[0,1]).toarray()\r\n  array([[0., 1., 0., 0.],\r\n         [1., 0., 0., 0.],\r\n         [0., 0., 0., 1.],\r\n         [0., 0., 1., 0.]])\r\n  ```\r\n\r\n* `qml.ctrl` now uses `Controlled` instead of `ControlledOperation`.  The new `Controlled` class wraps individual `Operator`'s instead of a tape.  It provides improved representations and integration. [(#2990)](https://github.com/PennyLaneAI/pennylane/pull/2990)\r\n\r\n* `qml.matrix` can now compute the matrix of tapes and QNodes that contain multiple broadcasted operations or non-broadcasted operations after broadcasted ones. [(#3025)](https://github.com/PennyLaneAI/pennylane/pull/3025)\r\n\r\n  A common scenario in which this becomes relevant is the decomposition of broadcasted operations: the decomposition in general will contain one or multiple broadcasted operations as well as operations with no or fixed parameters that are not broadcasted.\r\n\r\n* Lists of operators are now internally sorted by their respective wires while also taking into account their commutativity property.[(#2995)](https://github.com/PennyLaneAI/pennylane/pull/2995)\r\n\r\n* Some methods of the `QuantumTape` class have been simplified and reordered to improve both readability and performance. [(#2963)](https://github.com/PennyLaneAI/pennylane/pull/2963)\r\n\r\n* The `qml.qchem.molecular_hamiltonian` function is modified to support observable grouping. [(#2997)](https://github.com/PennyLaneAI/pennylane/pull/2997)\r\n\r\n* `qml.ops.op_math.Controlled` now has basic decomposition functionality. [(#2938)](https://github.com/PennyLaneAI/pennylane/pull/2938)\r\n\r\n* Automatic circuit cutting has been improved by making better partition imbalance derivations. Now it is more likely to generate optimal cuts for larger circuits. [(#2517)](https://github.com/PennyLaneAI/pennylane/pull/2517)\r\n\r\n* By default, `qml.counts` only returns the outcomes observed in sampling. Optionally, specifying `qml.counts(all_outcomes=True)` will return a dictionary containing all possible outcomes. [(#2889)](https://github.com/PennyLaneAI/pennylane/pull/2889)\r\n  \r\n  ```pycon\r\n  >>> dev = qml.device(\"default.qubit\", wires=2, shots=1000)\r\n  >>>\r\n  >>> @qml.qnode(dev)\r\n  >>> def circuit():\r\n  ...     qml.Hadamard(wires=0)\r\n  ...     qml.CNOT(wires=[0, 1])\r\n  ...     return qml.counts(all_outcomes=True)\r\n  >>> result = circuit()\r\n  >>> result\r\n  {'00': 495, '01': 0, '10': 0,  '11': 505}\r\n  ```\r\n  \r\n* Internal use of in-place inversion is eliminated in preparation for its deprecation. [(#2965)](https://github.com/PennyLaneAI/pennylane/pull/2965)\r\n\r\n* `Controlled` operators now work with `qml.is_commuting`. [(#2994)](https://github.com/PennyLaneAI/pennylane/pull/2994)\r\n\r\n* `qml.prod` and `qml.op_sum` now support the `sparse_matrix()` method. [(#3006)](https://github.com/PennyLaneAI/pennylane/pull/3006)\r\n\r\n  ```pycon\r\n  >>> xy = qml.prod(qml.PauliX(1), qml.PauliY(1))\r\n  >>> op = qml.op_sum(xy, qml.Identity(0))\r\n  >>>\r\n  >>> sparse_mat = op.sparse_matrix(wire_order=[0,1])\r\n  >>> type(sparse_mat)\r\n  <class 'scipy.sparse.csr.csr_matrix'>\r\n  >>> sparse_mat.toarray()\r\n  [[1.+1.j 0.+0.j 0.+0.j 0.+0.j]\r\n  [0.+0.j 1.-1.j 0.+0.j 0.+0.j]\r\n  [0.+0.j 0.+0.j 1.+1.j 0.+0.j]\r\n  [0.+0.j 0.+0.j 0.+0.j 1.-1.j]]\r\n  ```\r\n\r\n* Provided `sparse_matrix()` support for single qubit observables. [(#2964)](https://github.com/PennyLaneAI/pennylane/pull/2964)\r\n\r\n* `qml.Barrier` with `only_visual=True` now simplifies via `op.simplify()` to the identity operator or a product of identity operators.[(#3016)](https://github.com/PennyLaneAI/pennylane/pull/3016)\r\n\r\n* More accurate and intuitive outputs for printing some operators have been added. [(#3013)](https://github.com/PennyLaneAI/pennylane/pull/3013)\r\n\r\n* Results for the matrix of the sum or product of operators are stored in a more efficient manner. [(#3022)](https://github.com/PennyLaneAI/pennylane/pull/3022)\r\n\r\n* The computation of the (sparse) matrix for the sum or product of operators is now more efficient. [(#3030)](https://github.com/PennyLaneAI/pennylane/pull/3030)\r\n\r\n* When the factors of `qml.prod` don't share any wires, the matrix and sparse matrix are computed using a kronecker product for improved efficiency. [(#3040)](https://github.com/PennyLaneAI/pennylane/pull/3040)\r\n  \r\n* `qml.grouping.is_pauli_word` now returns `False` for operators that don't inherit from `qml.Observable` instead of raising an error. [(#3039)](https://github.com/PennyLaneAI/pennylane/pull/3039)\r\n\r\n* Added functionality to iterate over operators created from `qml.op_sum` and `qml.prod`. [(#3028)](https://github.com/PennyLaneAI/pennylane/pull/3028)\r\n\r\n  ```pycon\r\n  >>> op = qml.op_sum(qml.PauliX(0), qml.PauliY(1), qml.PauliZ(2))\r\n  >>> len(op)\r\n  3\r\n  >>> op[1]\r\n  PauliY(wires=[1])\r\n  >>> [o.name for o in op]\r\n  ['PauliX', 'PauliY', 'PauliZ']\r\n  ```\r\n\r\n<h3>Deprecations</h3>\r\n\r\n* In-place inversion is now deprecated. This includes `op.inv()` and `op.inverse=value`. Please use `qml.adjoint` or `qml.pow` instead. Support for these methods will remain till v0.28. [(#2988)](https://github.com/PennyLaneAI/pennylane/pull/2988)\r\n\r\n  Don't use:\r\n\r\n  ```pycon\r\n  >>> v1 = qml.PauliX(0).inv()\r\n  >>> v2 = qml.PauliX(0)\r\n  >>> v2.inverse = True\r\n  ```\r\n\r\n  Instead use:\r\n\r\n  ```pycon\r\n  >>> qml.adjoint(qml.PauliX(0))\r\n  Adjoint(PauliX(wires=[0]))\r\n  >>> qml.pow(qml.PauliX(0), -1)\r\n  PauliX(wires=[0])**-1\r\n  >>> qml.pow(qml.PauliX(0), -1, lazy=False)\r\n  PauliX(wires=[0])\r\n  >>> qml.PauliX(0) ** -1\r\n  PauliX(wires=[0])**-1\r\n  ```\r\n\r\n  `qml.adjoint` takes the conjugate transpose of an operator, while `qml.pow(op, -1)` indicates matrix inversion. For unitary operators, `adjoint` will be more efficient than `qml.pow(op, -1)`, even though they represent the same thing.\r\n\r\n* The `supports_reversible_diff` device capability is unused and has been removed. [(#2993)](https://github.com/PennyLaneAI/pennylane/pull/2993)\r\n\r\n<h3>Breaking changes</h3>\r\n\r\n* Measuring an operator that might not be hermitian now raises a warning instead of an error. To definitively determine whether or not an operator is hermitian, use `qml.is_hermitian`. [(#2960)](https://github.com/PennyLaneAI/pennylane/pull/2960)\r\n\r\n* The `ControlledOperation` class has been removed. This was a developer-only class, so the change should not be evident to any users. It is replaced by `Controlled`. [(#2990)](https://github.com/PennyLaneAI/pennylane/pull/2990)\r\n\r\n* The default `execute` method for the `QubitDevice` base class now calls `self.statistics` with an additional keyword argument `circuit`, which represents the quantum tape being executed. Any device that overrides `statistics` should edit the signature of the method to include the new `circuit` keyword argument. [(#2820)](https://github.com/PennyLaneAI/pennylane/pull/2820)\r\n\r\n* The `expand_matrix()` has been moved from `pennylane.operation` to `pennylane.math.matrix_manipulation`. [(#3008)](https://github.com/PennyLaneAI/pennylane/pull/3008)\r\n\r\n* `qml.grouping.utils.is_commuting` has been removed, and its Pauli word logic is now part of `qml.is_commuting`. [(#3033)](https://github.com/PennyLaneAI/pennylane/pull/3033)\r\n\r\n* `qml.is_commuting` has been moved from `pennylane.transforms.commutation_dag` to `pennylane.ops.functions`. [(#2991)](https://github.com/PennyLaneAI/pennylane/pull/2991)\r\n\r\n<h3>Documentation</h3>\r\n\r\n* Updated the Fourier transform docs to use `circuit_spectrum` instead of `spectrum`, which has been deprecated. [(#3018)](https://github.com/PennyLaneAI/pennylane/pull/3018)\r\n  \r\n* Corrected the docstrings for diagonalizing gates for all relevant operations. The docstrings used to say that the diagonalizing gates implemented $U$, the unitary such that $O = U \\Sigma U^{\\dagger}$, where $O$ is the original observable and $\\Sigma$ a diagonal matrix. However, the diagonalizing gates actually implement $U^{\\dagger}$, since $\\langle \\psi | O | \\psi \\rangle = \\langle \\psi | U \\Sigma U^{\\dagger} | \\psi \\rangle$, making $U^{\\dagger} | \\psi \\rangle$ the actual state being measured in the Z-basis. [(#2981)](https://github.com/PennyLaneAI/pennylane/pull/2981)\r\n\r\n<h3>Bug fixes</h3>\r\n\r\n* Fixed a bug with `qml.ops.Exp` operators when the coefficient is autograd but the diagonalizing gates don't act on all wires. [(#3057)](https://github.com/PennyLaneAI/pennylane/pull/3057)\r\n\r\n* Fixed a bug where the tape transform `single_qubit_fusion` computed wrong rotation angles for specific combinations of rotations. [(#3024)](https://github.com/PennyLaneAI/pennylane/pull/3024)\r\n\r\n* Jax gradients now work with a QNode when the quantum function was transformed by `qml.simplify`. [(#3017)](https://github.com/PennyLaneAI/pennylane/pull/3017)\r\n\r\n* Operators that have `num_wires = AnyWires` or `num_wires = AnyWires` now raise an error, with certain exceptions, when instantiated with `wires=[]`. [(#2979)](https://github.com/PennyLaneAI/pennylane/pull/2979)\r\n\r\n* Fixed a bug where printing `qml.Hamiltonian` with complex coefficients raises `TypeError` in some cases. [(#3005)](https://github.com/PennyLaneAI/pennylane/pull/3004)\r\n\r\n* Added a more descriptive error message when measuring non-commuting observables at the end of a circuit with `probs`, `samples`, `counts` and `allcounts`. [(#3065)](https://github.com/PennyLaneAI/pennylane/pull/3065)\r\n\r\n<h3>Contributors</h3>\r\n\r\nThis release contains contributions from (in alphabetical order):\r\n\r\nJuan Miguel Arrazola, Utkarsh Azad, Tom Bromley, Olivia Di Matteo, Isaac De Vlugt, Yiheng Duan, Lillian Marie Austin Frederiksen, Josh Izaac, Soran Jahangiri, Edward Jiang, Ankit Khandelwal, Korbinian Kottmann, Meenu Kumari, Christina Lee, Albert Mitjans Coma, Romain Moyard, Rashid N H M, Zeyue Niu, Mudit Pandey, Matthew Silverman, Jay Soni, Antal Sz\u00e1va, Cody Wang, David Wierichs.", "reactions": {"url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/77559696/reactions", "total_count": 2, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 2, "rocket": 0, "eyes": 0}}
{"url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/74703568", "assets_url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/74703568/assets", "upload_url": "https://uploads.github.com/repos/PennyLaneAI/pennylane/releases/74703568/assets{?name,label}", "html_url": "https://github.com/PennyLaneAI/pennylane/releases/tag/v0.25.1", "id": 74703568, "author": {"login": "rmoyard", "id": 36766072, "node_id": "MDQ6VXNlcjM2NzY2MDcy", "avatar_url": "https://avatars.githubusercontent.com/u/36766072?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rmoyard", "html_url": "https://github.com/rmoyard", "followers_url": "https://api.github.com/users/rmoyard/followers", "following_url": "https://api.github.com/users/rmoyard/following{/other_user}", "gists_url": "https://api.github.com/users/rmoyard/gists{/gist_id}", "starred_url": "https://api.github.com/users/rmoyard/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rmoyard/subscriptions", "organizations_url": "https://api.github.com/users/rmoyard/orgs", "repos_url": "https://api.github.com/users/rmoyard/repos", "events_url": "https://api.github.com/users/rmoyard/events{/privacy}", "received_events_url": "https://api.github.com/users/rmoyard/received_events", "type": "User", "site_admin": false}, "node_id": "RE_kwDOB76r6M4Ec-LQ", "tag_name": "v0.25.1", "target_commitish": "v0.25.1-bugfix", "name": "Release 0.25.1", "draft": false, "prerelease": false, "created_at": "2022-08-18T09:26:57Z", "published_at": "2022-08-18T10:01:08Z", "assets": [], "tarball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/tarball/v0.25.1", "zipball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/zipball/v0.25.1", "body": "<h3>Bug fixes</h3>\r\n\r\n* Fixed Torch device discrepencies for certain parametrized operations by updating `qml.math.array` and `qml.math.eye` to preserve the Torch device used. [(#2967)](https://github.com/PennyLaneAI/pennylane/pull/2967)\r\n\r\n<h3>Contributors</h3>\r\n\r\nThis release contains contributions from (in alphabetical order):\r\n\r\nRomain Moyard, Rashid N H M, Lee James O'Riordan, Antal Sz\u00e1va."}
{"url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/74428028", "assets_url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/74428028/assets", "upload_url": "https://uploads.github.com/repos/PennyLaneAI/pennylane/releases/74428028/assets{?name,label}", "html_url": "https://github.com/PennyLaneAI/pennylane/releases/tag/v0.25.0", "id": 74428028, "author": {"login": "rmoyard", "id": 36766072, "node_id": "MDQ6VXNlcjM2NzY2MDcy", "avatar_url": "https://avatars.githubusercontent.com/u/36766072?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rmoyard", "html_url": "https://github.com/rmoyard", "followers_url": "https://api.github.com/users/rmoyard/followers", "following_url": "https://api.github.com/users/rmoyard/following{/other_user}", "gists_url": "https://api.github.com/users/rmoyard/gists{/gist_id}", "starred_url": "https://api.github.com/users/rmoyard/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rmoyard/subscriptions", "organizations_url": "https://api.github.com/users/rmoyard/orgs", "repos_url": "https://api.github.com/users/rmoyard/repos", "events_url": "https://api.github.com/users/rmoyard/events{/privacy}", "received_events_url": "https://api.github.com/users/rmoyard/received_events", "type": "User", "site_admin": false}, "node_id": "RE_kwDOB76r6M4Eb658", "tag_name": "v0.25.0", "target_commitish": "v0.25.0-rc0", "name": "Release 0.25.0", "draft": false, "prerelease": false, "created_at": "2022-08-15T18:26:13Z", "published_at": "2022-08-15T18:34:51Z", "assets": [], "tarball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/tarball/v0.25.0", "zipball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/zipball/v0.25.0", "body": "<h3>New features since last release</h3>\r\n\r\n<h4>Estimate computational resource requirements \ud83e\udde0</h4>\r\n\r\n* Functionality for estimating molecular simulation computations has been added with `qml.resource`. [(#2646)](https://github.com/PennyLaneAI/pennylane/pull/2646) [(#2653)](https://github.com/PennyLaneAI/pennylane/pull/2653) [(#2665)](https://github.com/PennyLaneAI/pennylane/pull/2665) [(#2694)](https://github.com/PennyLaneAI/pennylane/pull/2694) [(#2720)](https://github.com/PennyLaneAI/pennylane/pull/2720) [(#2723)](https://github.com/PennyLaneAI/pennylane/pull/2723) [(#2746)](https://github.com/PennyLaneAI/pennylane/pull/2746) [(#2796)](https://github.com/PennyLaneAI/pennylane/pull/2796) [(#2797)](https://github.com/PennyLaneAI/pennylane/pull/2797) [(#2874)](https://github.com/PennyLaneAI/pennylane/pull/2874) [(#2944)](https://github.com/PennyLaneAI/pennylane/pull/2944) [(#2644)](https://github.com/PennyLaneAI/pennylane/pull/2644)\r\n\r\n  The new [resource](https://pennylane.readthedocs.io/en/stable/code/qml_resource.html) module allows you to estimate the number of non-[Clifford gates](https://en.wikipedia.org/wiki/Clifford_gates) and logical qubits needed to implement [quantum phase estimation](https://codebook.xanadu.ai/P.1) algorithms for simulating materials and molecules. This includes support for quantum algorithms using [first](https://en.wikipedia.org/wiki/First_quantization) and [second](https://en.wikipedia.org/wiki/Second_quantization) quantization with specific bases:\r\n\r\n  - [First quantization](https://en.wikipedia.org/wiki/First_quantization) using a plane-wave basis via the `FirstQuantization` class:\r\n\r\n    ```pycon\r\n    >>> n = 100000        # number of plane waves\r\n    >>> eta = 156         # number of electrons\r\n    >>> omega = 1145.166  # unit cell volume in atomic units\r\n    >>> algo = FirstQuantization(n, eta, omega)\r\n    >>> print(algo.gates, algo.qubits)\r\n    1.10e+13, 4416\r\n    ```\r\n\r\n  - [Second quantization](https://en.wikipedia.org/wiki/Second_quantization) with a double-factorized Hamiltonian via the `DoubleFactorization` class: \r\n \r\n    ```python\r\n    symbols = [\"O\", \"H\", \"H\"]\r\n    geometry = np.array(\r\n        [\r\n            [0.00000000, 0.00000000, 0.28377432],\r\n            [0.00000000, 1.45278171, -1.00662237],\r\n            [0.00000000, -1.45278171, -1.00662237],\r\n        ],\r\n        requires_grad=False,\r\n    )\r\n\r\n    mol = qml.qchem.Molecule(symbols, geometry, basis_name=\"sto-3g\")\r\n    core, one, two = qml.qchem.electron_integrals(mol)()\r\n\r\n    algo = DoubleFactorization(one, two)\r\n    ```\r\n\r\n    ```pycon\r\n    >>> print(algo.gates, algo.qubits)\r\n    103969925, 290\r\n    ```\r\n    \r\n  The methods of the `FirstQuantization` and the `DoubleFactorization` classes, such as `qubit_cost` (number of logical qubits) and `gate_cost` (number of non-Clifford gates), can be also accessed as static methods: \r\n  \r\n  ```pycon \r\n  >>> qml.resource.FirstQuantization.qubit_cost(100000, 156, 169.69608, 0.01) \r\n  4377 \r\n  >>> qml.resource.FirstQuantization.gate_cost(100000, 156, 169.69608, 0.01) \r\n  3676557345574\r\n  ```\r\n\r\n<h4>Differentiable error mitigation \u2699\ufe0f</h4>\r\n\r\n* Differentiable zero-noise-extrapolation (ZNE) error mitigation is now available. [(#2757)](https://github.com/PennyLaneAI/pennylane/pull/2757)\r\n\r\n  Elevate any variational quantum algorithm to a *mitigated* algorithm with improved results on noisy hardware while maintaining differentiability throughout.\r\n\r\n  In order to do so, use the `qml.transforms.mitigate_with_zne` transform on your QNode and provide the PennyLane proprietary `qml.transforms.fold_global` folding function and `qml.transforms.poly_extrapolate` extrapolation function. Here is an example for a noisy simulation device where we mitigate a QNode and are still able to compute the gradient:\r\n\r\n  ```python\r\n  # Describe noise\r\n  noise_gate = qml.DepolarizingChannel\r\n  noise_strength = 0.1\r\n\r\n  # Load devices\r\n  dev_ideal = qml.device(\"default.mixed\", wires=1)\r\n  dev_noisy = qml.transforms.insert(noise_gate, noise_strength)(dev_ideal)\r\n\r\n  scale_factors = [1, 2, 3]\r\n  @mitigate_with_zne(\r\n    scale_factors,\r\n    qml.transforms.fold_global,\r\n    qml.transforms.poly_extrapolate,\r\n    extrapolate_kwargs={'order': 2}\r\n  )\r\n  @qml.qnode(dev_noisy)\r\n  def qnode_mitigated(theta):\r\n      qml.RY(theta, wires=0)\r\n      return qml.expval(qml.PauliX(0))\r\n  ```\r\n\r\n  ```pycon\r\n  >>> theta = np.array(0.5, requires_grad=True)\r\n  >>> qml.grad(qnode_mitigated)(theta)\r\n  0.5712737447327619\r\n  ```\r\n\r\n<h4>More native support for parameter broadcasting \ud83d\udce1</h4>\r\n\r\n* `default.qubit` now natively supports parameter broadcasting, providing increased performance when executing the same circuit at various parameter positions compared to manually looping over parameters, or directly using the `qml.transforms.broadcast_expand` transform. [(#2627)](https://github.com/PennyLaneAI/pennylane/pull/2627)\r\n\r\n  ```python\r\n  dev = qml.device(\"default.qubit\", wires=1)\r\n\r\n  @qml.qnode(dev)\r\n  def circuit(x):\r\n      qml.RX(x, wires=0)\r\n      return qml.expval(qml.PauliZ(0))\r\n  ```\r\n\r\n  ```pycon\r\n  >>> circuit(np.array([0.1, 0.3, 0.2]))\r\n  tensor([0.99500417, 0.95533649, 0.98006658], requires_grad=True) \r\n  ```\r\n  Currently, not all templates have been updated to support broadcasting.\r\n\r\n* Parameter-shift gradients now allow for parameter broadcasting internally, which can result in a significant speedup when computing gradients of circuits with many parameters. [(#2749)](https://github.com/PennyLaneAI/pennylane/pull/2749)\r\n\r\n  The gradient transform `qml.gradients.param_shift` now accepts the keyword argument `broadcast`. If set to `True`, broadcasting is used to compute the derivative:\r\n\r\n  ```python\r\n  dev = qml.device(\"default.qubit\", wires=2)\r\n\r\n  @qml.qnode(dev)\r\n  def circuit(x, y):\r\n      qml.RX(x, wires=0)\r\n      qml.RY(y, wires=1)\r\n      return qml.expval(qml.PauliZ(0) @ qml.PauliZ(1))\r\n  ```\r\n\r\n  ```pycon\r\n  >>> x = np.array([np.pi/3, np.pi/2], requires_grad=True)\r\n  >>> y = np.array([np.pi/6, np.pi/5], requires_grad=True)\r\n  >>> qml.gradients.param_shift(circuit, broadcast=True)(x, y)\r\n  (tensor([[-0.7795085,  0.       ],\r\n           [ 0.       , -0.7795085]], requires_grad=True),\r\n  tensor([[-0.125, 0.  ],\r\n          [0.  , -0.125]], requires_grad=True))\r\n  ```\r\n\r\n  The following example highlights how to make use of broadcasting gradients at the QNode level. Internally, broadcasting is used to compute the parameter-shift rule when required, which may result in performance improvements.\r\n\r\n  ```python\r\n  @qml.qnode(dev, diff_method=\"parameter-shift\", broadcast=True)\r\n  def circuit(x, y):\r\n      qml.RX(x, wires=0)\r\n      qml.RY(y, wires=1)\r\n      return qml.expval(qml.PauliZ(0) @ qml.PauliZ(1))\r\n  ```\r\n\r\n  ```pycon\r\n  >>> x = np.array(0.1, requires_grad=True)\r\n  >>> y = np.array(0.4, requires_grad=True)\r\n  >>> qml.grad(circuit)(x, y)\r\n  (array(-0.09195267), array(-0.38747287))\r\n  ```\r\n\r\n  Here, only 2 circuits are created internally, rather than 4 with `broadcast=False`.\r\n\r\n  To illustrate the speedup, for a constant-depth circuit with Pauli rotations and controlled Pauli rotations, the time required to compute `qml.gradients.param_shift(circuit, broadcast=False)(params)` (\"No broadcasting\") and `qml.gradients.param_shift(circuit, broadcast=True)(params)` (\"Broadcasting\") as a function of the number of qubits is given [here](https://pennylane.readthedocs.io/en/stable/_images/param_shift_broadcast_speedup.png).\r\n\r\n* Operations for quantum chemistry now support parameter broadcasting. [(#2726)](https://github.com/PennyLaneAI/pennylane/pull/2726)\r\n\r\n  ```pycon\r\n  >>> op = qml.SingleExcitation(np.array([0.3, 1.2, -0.7]), wires=[0, 1])\r\n  >>> op.matrix().shape\r\n  (3, 4, 4)\r\n  ```\r\n\r\n<h4>Intuitive operator arithmetic \ud83e\uddee</h4>\r\n\r\n* New functionality for representing the sum, product, and scalar-product of operators is available. [(#2475)](https://github.com/PennyLaneAI/pennylane/pull/2475) [(#2625)](https://github.com/PennyLaneAI/pennylane/pull/2625) [(#2622)](https://github.com/PennyLaneAI/pennylane/pull/2622) [(#2721)](https://github.com/PennyLaneAI/pennylane/pull/2721)\r\n\r\n  The following functionalities have been added to facilitate creating new operators whose matrix, terms, and eigenvalues can be accessed as per usual, while maintaining differentiability. Operators created from these new features can be used within QNodes as operations or as observables (where physically applicable). \r\n\r\n  - Summing any number of operators via `qml.op_sum` results in a \"summed\" operator:\r\n\r\n    ```pycon\r\n    >>> ops_to_sum = [qml.PauliX(0), qml.PauliY(1), qml.PauliZ(0)] \r\n    >>> summed_ops = qml.op_sum(*ops_to_sum)\r\n    >>> summed_ops\r\n    PauliX(wires=[0]) + PauliY(wires=[1]) + PauliZ(wires=[0])\r\n    >>> qml.matrix(summed_ops)\r\n    array([[ 1.+0.j,  0.-1.j,  1.+0.j,  0.+0.j],\r\n           [ 0.+1.j,  1.+0.j,  0.+0.j,  1.+0.j],\r\n           [ 1.+0.j,  0.+0.j, -1.+0.j,  0.-1.j],\r\n           [ 0.+0.j,  1.+0.j,  0.+1.j, -1.+0.j]])\r\n    >>> summed_ops.terms()\r\n    ([1.0, 1.0, 1.0], (PauliX(wires=[0]), PauliY(wires=[1]), PauliZ(wires=[0])))\r\n    ```\r\n\r\n  - Multiplying any number of operators via `qml.prod` results in a \"product\" operator, where the matrix product or tensor product is used correspondingly:\r\n\r\n    ```pycon\r\n    >>> theta = 1.23\r\n    >>> prod_op = qml.prod(qml.PauliZ(0), qml.RX(theta, 1))\r\n    >>> prod_op\r\n    PauliZ(wires=[0]) @ RX(1.23, wires=[1]) \r\n    >>> qml.eigvals(prod_op)\r\n    [-1.39373197 -0.23981492  0.23981492  1.39373197]\r\n    ```\r\n  \r\n  - Taking the product of a coefficient and an operator via `qml.s_prod` produces a \"scalar-product\" operator:\r\n\r\n    ```pycon\r\n    >>> sprod_op = qml.s_prod(2.0, qml.PauliX(0))\r\n    >>> sprod_op\r\n    2.0*(PauliX(wires=[0]))\r\n    >>> sprod_op.matrix()\r\n    array([[ 0., 2.],\r\n           [ 2., 0.]])\r\n    >>> sprod_op.terms()\r\n    ([2.0], [PauliX(wires=[0])])\r\n    ```\r\n\r\n  Each of these new functionalities can be used within QNodes as operators or observables, where applicable, while also maintaining differentiability. For example:\r\n\r\n  ```python\r\n  dev = qml.device(\"default.qubit\", wires=2)\r\n\r\n  @qml.qnode(dev)\r\n  def circuit(angles):\r\n      qml.prod(qml.PauliZ(0), qml.RY(angles[0], 1))\r\n      qml.op_sum(qml.PauliX(1), qml.RY(angles[1], 0))\r\n\r\n      return qml.expval(qml.op_sum(qml.PauliX(0), qml.PauliZ(1)))\r\n  ```\r\n\r\n  ```pycon\r\n  >>> angles = np.array([1.23, 4.56], requires_grad=True)\r\n  >>> circuit(angles)\r\n  tensor(0.33423773, requires_grad=True)\r\n  >>> qml.grad(circuit)(angles)\r\n  array([-0.9424888,  0.       ])\r\n  ```\r\n  \r\n* All PennyLane operators can now be added, subtracted, multiplied, scaled, and raised to powers using `+`, `-`, `@`, `*`, `**`, respectively. [(#2849)](https://github.com/PennyLaneAI/pennylane/pull/2849) [(#2825)](https://github.com/PennyLaneAI/pennylane/pull/2825) [(#2891)](https://github.com/PennyLaneAI/pennylane/pull/2891)\r\n  \r\n  - You can now add scalars to operators, where the interpretation is that the scalar is a properly-sized identity matrix;\r\n\r\n    ```pycon\r\n    >>> sum_op = 5 + qml.PauliX(0)\r\n    >>> sum_op.matrix()\r\n    array([[5., 1.],\r\n           [1., 5.]])\r\n    ```\r\n    \r\n  - The `+` and `-` operators can be used to combine all Pennylane operators:\r\n\r\n    ```pycon\r\n    >>> sum_op = qml.RX(phi=1.23, wires=0) + qml.RZ(phi=3.14, wires=0) - qml.RY(phi=0.12, wires=0)\r\n    >>> sum_op\r\n    RX(1.23, wires=[0]) + RZ(3.14, wires=[0]) + -1*(RY(0.12, wires=[0]))\r\n    >>> qml.matrix(sum_op)\r\n    array([[-0.18063077-0.99999968j,  0.05996401-0.57695852j],\r\n           [-0.05996401-0.57695852j, -0.18063077+0.99999968j]])\r\n    ```\r\n    Note that the behavior of `+` and `-` with *observables* is different; it still creates a Hamiltonian.\r\n  \r\n  - The `*` and `@` operators can be used to scale and compose all PennyLane operators.\r\n  \r\n    ```pycon\r\n    >>> prod_op = 2*qml.RX(1, wires=0) @ qml.RY(2, wires=0)\r\n    >>> prod_op\r\n    2*(RX(1, wires=[0])) @ RY(2, wires=[0])\r\n    >>> qml.matrix(prod_op)\r\n    array([[ 0.94831976-0.80684536j, -1.47692053-0.51806945j],\r\n           [ 1.47692053-0.51806945j,  0.94831976+0.80684536j]])\r\n     ```\r\n  \r\n  - The `**` operator can be used to raise PennyLane operators to a power.\r\n  \r\n    ```pycon       \r\n    >>> exp_op = qml.RZ(1.0, wires=0) ** 2\r\n    >>> exp_op\r\n    RZ**2(1.0, wires=[0])\r\n    >>> qml.matrix(exp_op)\r\n    array([[0.54030231-0.84147098j, 0.        +0.j        ],\r\n           [0.        +0.j        , 0.54030231+0.84147098j]])\r\n    ```\r\n\r\n* A new class called `Controlled` is available in `qml.ops.op_math` to represent a controlled version of any operator. This will eventually be integrated into `qml.ctrl` to provide a performance increase and more feature coverage. [(#2634)](https://github.com/PennyLaneAI/pennylane/pull/2634)\r\n\r\n* Arithmetic operations can now be simplified using `qml.simplify`. [(#2835)](https://github.com/PennyLaneAI/pennylane/pull/2835) [(#2854)](https://github.com/PennyLaneAI/pennylane/pull/2854)\r\n  \r\n  ```pycon \r\n  >>> op = qml.adjoint(qml.adjoint(qml.RX(x, wires=0))) \r\n  >>> op \r\n  Adjoint(Adjoint(RX))(tensor([1.04719755, 1.57079633], requires_grad=True), wires=[0]) \r\n  >>> qml.simplify(op) \r\n  RX(tensor([1.04719755, 1.57079633], requires_grad=True), wires=[0]) \r\n  ```\r\n\r\n* A new function called `qml.equal` can be used to compare the equality of parametric operators. [(#2651)](https://github.com/PennyLaneAI/pennylane/pull/2651)\r\n\r\n  ```pycon\r\n  >>> qml.equal(qml.RX(1.23, 0), qml.RX(1.23, 0))\r\n  True\r\n  >>> qml.equal(qml.RY(4.56, 0), qml.RY(7.89, 0))\r\n  False\r\n  ```\r\n\r\n<h4>Marvelous mixed state features \ud83d\ude4c</h4>\r\n\r\n* The `default.mixed` device now supports [backpropagation](https://pennylane.readthedocs.io/en/stable/introduction/unsupported_gradients.html#backpropagation) with the `\"jax\"` interface, which can result in significant speedups. [(#2754)](https://github.com/PennyLaneAI/pennylane/pull/2754) [(#2776)](https://github.com/PennyLaneAI/pennylane/pull/2776)\r\n\r\n  ```python\r\n  dev = qml.device(\"default.mixed\", wires=2)\r\n\r\n  @qml.qnode(dev, diff_method=\"backprop\", interface=\"jax\")\r\n  def circuit(angles):\r\n      qml.RX(angles[0], wires=0)\r\n      qml.RY(angles[1], wires=1)\r\n      return qml.expval(qml.PauliZ(0) + qml.PauliZ(1))\r\n  ```\r\n\r\n  ```pycon\r\n  >>> angles = np.array([np.pi/6, np.pi/5], requires_grad=True)\r\n  >>> qml.grad(circuit)(angles)\r\n  array([-0.8660254 , -0.25881905])\r\n  ```\r\n  \r\n  Additionally, quantum channels now support Jax and TensorFlow tensors. This allows quantum channels to be used inside QNodes decorated by `tf.function`, `jax.jit`, or `jax.vmap`.\r\n\r\n* The `default.mixed` device now supports readout error. [(#2786)](https://github.com/PennyLaneAI/pennylane/pull/2786)\r\n\r\n  A new keyword argument called `readout_prob` can be specified when creating a `default.mixed` device. Any circuits running on a `default.mixed` device with a finite `readout_prob` (upper-bounded by 1) will alter the measurements performed at the end of the circuit similarly to how a `qml.BitFlip` channel would affect circuit measurements:\r\n\r\n  ```pycon\r\n  >>> dev = qml.device(\"default.mixed\", wires=2, readout_prob=0.1)\r\n  >>> @qml.qnode(dev)\r\n  ... def circuit():\r\n  ...     return qml.expval(qml.PauliZ(0))\r\n  >>> circuit()\r\n  array(0.8)\r\n  ```\r\n  \r\n<h4>Relative entropy is now available in qml.qinfo \ud83d\udca5</h4>\r\n\r\n* The quantum information module now supports computation of [relative entropy](https://en.wikipedia.org/wiki/Quantum_relative_entropy).\r\n  [(#2772)](https://github.com/PennyLaneAI/pennylane/pull/2772)\r\n\r\n  We've enabled two cases for calculating the relative entropy:\r\n  \r\n  - A QNode transform via `qml.qinfo.relative_entropy`:\r\n\r\n    ```python\r\n    dev = qml.device('default.qubit', wires=2)\r\n\r\n    @qml.qnode(dev)\r\n    def circuit(param):\r\n        qml.RY(param, wires=0)\r\n        qml.CNOT(wires=[0, 1])\r\n        return qml.state()\r\n    ```\r\n\r\n    ```pycon\r\n    >>> relative_entropy_circuit = qml.qinfo.relative_entropy(circuit, circuit, wires0=[0], wires1=[0])\r\n    >>> x, y = np.array(0.4), np.array(0.6)\r\n    >>> relative_entropy_circuit((x,), (y,))\r\n    0.017750012490703237\r\n    ```\r\n\r\n  - Support in `qml.math` for flexible post-processing:\r\n\r\n    ```pycon\r\n    >>> rho = np.array([[0.3, 0], [0, 0.7]])\r\n    >>> sigma = np.array([[0.5, 0], [0, 0.5]])\r\n    >>> qml.math.relative_entropy(rho, sigma)\r\n    tensor(0.08228288, requires_grad=True)\r\n    ```\r\n\r\n<h4>New measurements, operators, and more! \u2728</h4>\r\n\r\n* A new measurement called `qml.counts` is available. [(#2686)](https://github.com/PennyLaneAI/pennylane/pull/2686) [(#2839)](https://github.com/PennyLaneAI/pennylane/pull/2839) [(#2876)](https://github.com/PennyLaneAI/pennylane/pull/2876)\r\n\r\n  QNodes with `shots != None` that return `qml.counts` will yield a dictionary whose keys are bitstrings representing computational basis states that were measured, and whose values are the corresponding counts (i.e., how many times that computational basis state was measured):\r\n\r\n  ```python\r\n  dev = qml.device(\"default.qubit\", wires=2, shots=1000)\r\n\r\n  @qml.qnode(dev)\r\n  def circuit():\r\n      qml.Hadamard(wires=0)\r\n      qml.CNOT(wires=[0, 1])\r\n      return qml.counts()\r\n  ```\r\n\r\n  ```pycon\r\n  >>> circuit()\r\n  {'00': 495, '11': 505}\r\n  ```\r\n\r\n  `qml.counts` can also accept observables, where the resulting dictionary is ordered by the eigenvalues of the observable.\r\n\r\n  ```python\r\n  dev = qml.device(\"default.qubit\", wires=2, shots=1000)\r\n\r\n  @qml.qnode(dev)\r\n  def circuit():\r\n      qml.Hadamard(wires=0)\r\n      qml.CNOT(wires=[0, 1])\r\n      return qml.counts(qml.PauliZ(0)), qml.counts(qml.PauliZ(1))\r\n  ```\r\n\r\n  ```pycon\r\n  >>> circuit()\r\n  ({-1: 470, 1: 530}, {-1: 470, 1: 530})\r\n  ```\r\n  \r\n* A new experimental return type for QNodes with multiple measurements has been added. [(#2814)](https://github.com/PennyLaneAI/pennylane/pull/2814) [(#2815)](https://github.com/PennyLaneAI/pennylane/pull/2815) [(#2860)](https://github.com/PennyLaneAI/pennylane/pull/2860)\r\n\r\n  QNodes returning a list or tuple of different measurements return an intuitive data structure via `qml.enable_return()`, where the individual measurements are separated into their own tensors:\r\n\r\n  ```python\r\n  qml.enable_return()\r\n  dev = qml.device(\"default.qubit\", wires=2)\r\n  \r\n  @qml.qnode(dev)\r\n  def circuit(x):\r\n      qml.Hadamard(wires=[0])\r\n      qml.CRX(x, wires=[0, 1])\r\n      return (qml.probs(wires=[0]), qml.vn_entropy(wires=[0]), qml.probs(wires=0), qml.expval(wires=1))\r\n  ```\r\n  ```pycon\r\n  >>> circuit(0.5)\r\n  (tensor([0.5, 0.5], requires_grad=True), tensor(0.08014815, requires_grad=True), tensor([0.5, 0.5], requires_grad=True), tensor(0.93879128, requires_grad=True))\r\n  ```\r\n\r\n  In addition, QNodes that utilize this new return type support backpropagation. This new return type can be disabled thereafter via `qml.disable_return()`.\r\n\r\n* An operator called `qml.FlipSign` is now available. [(#2780)](https://github.com/PennyLaneAI/pennylane/pull/2780)\r\n\r\n  Mathematically, `qml.FlipSign` functions as follows: $\\text{FlipSign}(n) \\vert m \\rangle = (-1)^\\delta_{n,m} \\vert m \\rangle$, where $\\vert m \\rangle$ is an arbitrary qubit state and $n$ is a qubit configuration:\r\n\r\n  ```python\r\n  basis_state = [0, 1]\r\n\r\n  dev = qml.device(\"default.qubit\", wires=2)\r\n\r\n  @qml.qnode(dev)\r\n  def circuit():\r\n    for wire in list(range(2)):\r\n          qml.Hadamard(wires = wire)\r\n    qml.FlipSign(basis_state, wires = list(range(2)))\r\n    return qml.state()\r\n  ```\r\n\r\n  ```pycon\r\n  >>> circuit()\r\n  tensor([ 0.5+0.j  -0.5+0.j 0.5+0.j  0.5+0.j], requires_grad=True)\r\n  ```\r\n\r\n* The [simultaneous perturbation stochastic approximation (SPSA) optimizer](https://www.jhuapl.edu/SPSA/PDF-SPSA/Spall_An_Overview.PDF) is available via `qml.SPSAOptimizer`. [(#2661)](https://github.com/PennyLaneAI/pennylane/pull/2661)\r\n\r\n  The SPSA optimizer is suitable for cost functions whose evaluation may involve noise. Use the SPSA optimizer like you would any other optimizer:\r\n\r\n  ```python\r\n  max_iterations = 50\r\n  opt = qml.SPSAOptimizer(maxiter=max_iterations) \r\n\r\n  for _ in range(max_iterations):\r\n      params, cost = opt.step_and_cost(cost, params)\r\n  ```  \r\n  \r\n<h4>More drawing styles \ud83c\udfa8</h4>\r\n\r\n* New PennyLane-inspired `sketch` and `sketch_dark` styles are now available for drawing circuit diagram graphics. [(#2709)](https://github.com/PennyLaneAI/pennylane/pull/2709)\r\n\r\n<h3>Improvements \ud83d\udcc8</h3>\r\n\r\n* `default.qubit` now natively executes any operation that defines a matrix except for trainable `Pow` operations. [(#2836)](https://github.com/PennyLaneAI/pennylane/pull/2836)\r\n\r\n* Added `expm` to the `qml.math` module for matrix exponentiation. [(#2890)](https://github.com/PennyLaneAI/pennylane/pull/2890)\r\n  \r\n* When adjoint differentiation is requested, circuits are now decomposed so that all trainable operations have a generator. [(#2836)](https://github.com/PennyLaneAI/pennylane/pull/2836)\r\n  \r\n* A warning is now emitted for `qml.state`, `qml.density_matrix`, `qml.vn_entropy`, and `qml.mutual_info` when using a device with finite shots or a shot list since these measurements are always analytic. [(#2918)](https://github.com/PennyLaneAI/pennylane/pull/2918)\r\n\r\n* The efficiency of the Hartree-Fock workflow has been improved by removing repetitive steps. [(#2850)](https://github.com/PennyLaneAI/pennylane/pull/2850)\r\n\r\n* The coefficients of the non-differentiable molecular Hamiltonians generated with openfermion now have `requires_grad = False` by default. [(#2865)](https://github.com/PennyLaneAI/pennylane/pull/2865)\r\n\r\n* Upgraded performance of the `compute_matrix` method of broadcastable parametric operations. [(#2759)](https://github.com/PennyLaneAI/pennylane/pull/2759)\r\n\r\n* Jacobians are now cached with the Autograd interface when using the parameter-shift rule. [(#2645)](https://github.com/PennyLaneAI/pennylane/pull/2645)\r\n\r\n* The `qml.state` and `qml.density_matrix` measurements now support custom wire labels. [(#2779)](https://github.com/PennyLaneAI/pennylane/pull/2779)\r\n\r\n* Add trivial behaviour logic to `qml.operation.expand_matrix`. [(#2785)](https://github.com/PennyLaneAI/pennylane/issues/2785)\r\n\r\n* Added an `are_pauli_words_qwc` function which checks if certain Pauli words are pairwise qubit-wise commuting. This new function improves performance when measuring hamiltonians with many commuting terms. [(#2789)](https://github.com/PennyLaneAI/pennylane/pull/2798)\r\n\r\n* Adjoint differentiation now uses the adjoint symbolic wrapper instead of in-place inversion. [(#2855)](https://github.com/PennyLaneAI/pennylane/pull/2855)\r\n\r\n<h3>Breaking changes \ud83d\udc94</h3>\r\n\r\n* The deprecated `qml.hf` module is removed. Users with code that calls `qml.hf` can simply replace `qml.hf` with `qml.qchem` in most cases, or refer to the [qchem documentation](https://pennylane.readthedocs.io/en/stable/code/qml_qchem.html) and [demos](https://pennylane.ai/qml/demos_quantum-chemistry.html) for more information. [(#2795)](https://github.com/PennyLaneAI/pennylane/pull/2795)\r\n\r\n* `default.qubit` now uses `stopping_condition` to specify support for anything with a matrix. To override this behavior in inheriting devices and to support only a specific subset of operations, developers need to override `stopping_condition`. [(#2836)](https://github.com/PennyLaneAI/pennylane/pull/2836)\r\n\r\n* Custom devices inheriting from `DefaultQubit` or `QubitDevice` can break due to the introduction of parameter broadcasting. [(#2627)](https://github.com/PennyLaneAI/pennylane/pull/2627)\r\n\r\n  A custom device should only break if all three following statements hold simultaneously:\r\n\r\n  1. The custom device inherits from `DefaultQubit`, not `QubitDevice`.\r\n  2. The device implements custom methods in the simulation pipeline that are incompatible with broadcasting (for example `expval`, `apply_operation` or `analytic_probability`).\r\n  3. The custom device maintains the flag `\"supports_broadcasting\": True` in its `capabilities` dictionary *or* it overwrites `Device.batch_transform` without applying `broadcast_expand` (or both).\r\n\r\n  The `capabilities[\"supports_broadcasting\"]` is set to `True` for `DefaultQubit`. Typically, the easiest fix will be to change `capabilities[\"supports_broadcasting\"]` flag to `False` for the child device and/or to include a call to `broadcast_expand` in `CustomDevice.batch_transform`, similar to how `Device.batch_transform` calls it.\r\n\r\n  Separately from the above, custom devices that inherit from `QubitDevice` and implement a custom `_gather` method need to allow for the kwarg `axis` to be passed to this `_gather` method.\r\n\r\n* The argument `argnum` of the function `qml.batch_input` has been redefined: now it indicates the indices of the batched parameters, which need to be non-trainable, in the quantum tape. Consequently, its default value (set to 0) has been removed. [(#2873)](https://github.com/PennyLaneAI/pennylane/pull/2873)\r\n\r\n  Before this breaking change, one could call `qml.batch_input` without any arguments when using batched inputs as the first argument of the quantum circuit.\r\n\r\n  ```python\r\n  dev = qml.device(\"default.qubit\", wires=2, shots=None)\r\n\r\n  @qml.batch_input()  # argnum = 0\r\n  @qml.qnode(dev, diff_method=\"parameter-shift\", interface=\"tf\")\r\n  def circuit(inputs, weights):  # argument `inputs` is batched\r\n      qml.RY(weights[0], wires=0)\r\n      qml.AngleEmbedding(inputs, wires=range(2), rotation=\"Y\")\r\n      qml.RY(weights[1], wires=1)\r\n      return qml.expval(qml.PauliZ(1))\r\n  ```\r\n\r\n  With this breaking change, users must set a value to `argnum` specifying the index of the batched inputs with respect to all quantum tape parameters. In this example the quantum tape parameters are `[ weights[0], inputs, weights[1] ]`, thus `argnum` should be set to 1, specifying that `inputs` is batched:\r\n\r\n  ```python\r\n  dev = qml.device(\"default.qubit\", wires=2, shots=None)\r\n\r\n  @qml.batch_input(argnum=1)\r\n  @qml.qnode(dev, diff_method=\"parameter-shift\", interface=\"tf\")\r\n  def circuit(inputs, weights):\r\n      qml.RY(weights[0], wires=0)\r\n      qml.AngleEmbedding(inputs, wires=range(2), rotation=\"Y\")\r\n      qml.RY(weights[1], wires=1)\r\n      return qml.expval(qml.PauliZ(1))\r\n  ```\r\n\r\n* PennyLane now depends on newer versions (>=2.7) of the `semantic_version` package, which provides an updated API that is incompatible which versions of the package prior to 2.7. If you run into issues relating to this package, please reinstall PennyLane. [(#2744)](https://github.com/PennyLaneAI/pennylane/pull/2744) [(#2767)](https://github.com/PennyLaneAI/pennylane/pull/2767)\r\n\r\n<h3>Documentation \ud83d\udcd5</h3>\r\n\r\n* Added a dedicated docstring for the `QubitDevice.sample` method. [(#2812)](https://github.com/PennyLaneAI/pennylane/pull/2812)\r\n\r\n* Optimization examples of using JAXopt and Optax with the JAX interface have been added. [(#2769)](https://github.com/PennyLaneAI/pennylane/pull/2769)\r\n\r\n* Updated IsingXY gate docstring. [(#2858)](https://github.com/PennyLaneAI/pennylane/pull/2858)\r\n\r\n<h3>Bug fixes \ud83d\udc1e</h3>\r\n\r\n* Fixes `qml.equal` so that operators with different inverse properties are not equal. [(#2947)](https://github.com/PennyLaneAI/pennylane/pull/2947)\r\n\r\n* Cleans up interactions between operator arithmetic and batching by testing supported cases and adding errors when batching is not supported. [(#2900)](https://github.com/PennyLaneAI/pennylane/pull/2900)\r\n\r\n* Fixed a bug where the parameter-shift rule wasn't defined for `qml.kUpCCGSD`. [(#2913)](https://github.com/PennyLaneAI/pennylane/pull/2913)  \r\n\r\n* Reworked the Hermiticity check in `qml.Hermitian` by using `qml.math` calls because calling `.conj()` on an `EagerTensor` from TensorFlow raised an error. [(#2895)](https://github.com/PennyLaneAI/pennylane/pull/2895)\r\n\r\n* Fixed a bug where the parameter-shift gradient breaks when using both custom `grad_recipe`s that contain unshifted terms and recipes that do not contain any unshifted terms. [(#2834)](https://github.com/PennyLaneAI/pennylane/pull/2834)\r\n\r\n* Fixed mixed CPU-GPU data-locality issues for the Torch interface. [(#2830)](https://github.com/PennyLaneAI/pennylane/pull/2830)\r\n\r\n* Fixed a bug where the parameter-shift Hessian of circuits with untrainable parameters might be computed with respect to the wrong parameters or might raise an error. [(#2822)](https://github.com/PennyLaneAI/pennylane/pull/2822)\r\n\r\n* Fixed a bug where the custom implementation of the `states_to_binary` device method was not used. [(#2809)](https://github.com/PennyLaneAI/pennylane/pull/2809)\r\n\r\n* `qml.grouping.group_observables` now works when individual wire labels are iterable. [(#2752)](https://github.com/PennyLaneAI/pennylane/pull/2752)\r\n\r\n* The adjoint of an adjoint now has a correct `expand` result. [(#2766)](https://github.com/PennyLaneAI/pennylane/pull/2766)\r\n\r\n* Fixed the ability to return custom objects as the expectation value of a QNode with the Autograd interface. [(#2808)](https://github.com/PennyLaneAI/pennylane/pull/2808)\r\n\r\n* The WireCut operator now raises an error when instantiating it with an empty list. [(#2826)](https://github.com/PennyLaneAI/pennylane/pull/2826)\r\n\r\n* Hamiltonians with grouped observables are now allowed to be measured on devices which were transformed using `qml.transform.insert()`. [(#2857)](https://github.com/PennyLaneAI/pennylane/pull/2857)\r\n\r\n* Fixed a bug where `qml.batch_input` raised an error when using a batched operator that was not located at the beginning of the circuit. In addition, now `qml.batch_input` raises an error when using trainable batched inputs, which avoids an unwanted behaviour with duplicated parameters. [(#2873)](https://github.com/PennyLaneAI/pennylane/pull/2873)\r\n\r\n* Calling `qml.equal` with nested operators now raises a `NotImplementedError`. [(#2877)](https://github.com/PennyLaneAI/pennylane/pull/2877)\r\n\r\n* Fixed a bug where a non-sensible error message was raised when using `qml.counts` with `shots=False`. [(#2928)](https://github.com/PennyLaneAI/pennylane/pull/2928)\r\n\r\n* Fixed a bug where no error was raised and a wrong value was returned when using `qml.counts` with another non-commuting observable. [(#2928)](https://github.com/PennyLaneAI/pennylane/pull/2928)\r\n\r\n* Operator Arithmetic now allows `Hamiltonian` objects to be used and produces correct matrices. [(#2957)](https://github.com/PennyLaneAI/pennylane/pull/2957)\r\n\r\n<h3>Contributors</h3>\r\n\r\nThis release contains contributions from (in alphabetical order):\r\n\r\nJuan Miguel Arrazola, Utkarsh Azad, Samuel Banning, Prajwal Borkar, Isaac De Vlugt, Olivia Di Matteo, Kristiyan Dilov, David Ittah, Josh Izaac, Soran Jahangiri, Edward Jiang, Ankit Khandelwal, Korbinian Kottmann, Meenu Kumari, Christina Lee, Sergio Mart\u00ednez-Losa, Albert Mitjans Coma, Ixchel Meza Chavez, Romain Moyard, Lee James O'Riordan, Mudit Pandey, Bogdan Reznychenko, Shuli Shu, Jay Soni, Modjtaba Shokrian-Zini, Antal Sz\u00e1va, David Wierichs, Moritz Willmann."}
{"url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/69872871", "assets_url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/69872871/assets", "upload_url": "https://uploads.github.com/repos/PennyLaneAI/pennylane/releases/69872871/assets{?name,label}", "html_url": "https://github.com/PennyLaneAI/pennylane/releases/tag/v0.24.0", "id": 69872871, "author": {"login": "rmoyard", "id": 36766072, "node_id": "MDQ6VXNlcjM2NzY2MDcy", "avatar_url": "https://avatars.githubusercontent.com/u/36766072?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rmoyard", "html_url": "https://github.com/rmoyard", "followers_url": "https://api.github.com/users/rmoyard/followers", "following_url": "https://api.github.com/users/rmoyard/following{/other_user}", "gists_url": "https://api.github.com/users/rmoyard/gists{/gist_id}", "starred_url": "https://api.github.com/users/rmoyard/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rmoyard/subscriptions", "organizations_url": "https://api.github.com/users/rmoyard/orgs", "repos_url": "https://api.github.com/users/rmoyard/repos", "events_url": "https://api.github.com/users/rmoyard/events{/privacy}", "received_events_url": "https://api.github.com/users/rmoyard/received_events", "type": "User", "site_admin": false}, "node_id": "RE_kwDOB76r6M4EKizn", "tag_name": "v0.24.0", "target_commitish": "v0.24.0-rc0", "name": "Release 0.24.0", "draft": false, "prerelease": false, "created_at": "2022-06-20T19:21:42Z", "published_at": "2022-06-20T19:40:26Z", "assets": [], "tarball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/tarball/v0.24.0", "zipball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/zipball/v0.24.0", "body": "<h3>New features since last release</h3>\r\n\r\n<h4>All new quantum information quantities \ud83d\udccf</h4>\r\n\r\n* Functionality for computing quantum information quantities for QNodes has been added. [(#2554)](https://github.com/PennyLaneAI/pennylane/pull/2554) [(#2569)](https://github.com/PennyLaneAI/pennylane/pull/2569) [(#2598)](https://github.com/PennyLaneAI/pennylane/pull/2598) [(#2617)](https://github.com/PennyLaneAI/pennylane/pull/2617) [(#2631)](https://github.com/PennyLaneAI/pennylane/pull/2631) [(#2640)](https://github.com/PennyLaneAI/pennylane/pull/2640) [(#2663)](https://github.com/PennyLaneAI/pennylane/pull/2663) [(#2684)](https://github.com/PennyLaneAI/pennylane/pull/2684) [(#2688)](https://github.com/PennyLaneAI/pennylane/pull/2688) [(#2695)](https://github.com/PennyLaneAI/pennylane/pull/2695) [(#2710)](https://github.com/PennyLaneAI/pennylane/pull/2710) [(#2712)](https://github.com/PennyLaneAI/pennylane/pull/2712)\r\n\r\n  This includes two new QNode measurements:\r\n\r\n  - The [Von Neumann entropy](https://en.wikipedia.org/wiki/Von_Neumann_entropy) via `qml.vn_entropy`:\r\n  \r\n    ```pycon\r\n    >>> dev = qml.device(\"default.qubit\", wires=2)\r\n    >>> @qml.qnode(dev)\r\n    ... def circuit_entropy(x):\r\n    ...     qml.IsingXX(x, wires=[0,1])\r\n    ...     return qml.vn_entropy(wires=[0], log_base=2)\r\n    >>> circuit_entropy(np.pi/2)\r\n    1.0\r\n    ```\r\n\r\n  - The [mutual information](https://en.wikipedia.org/wiki/Quantum_mutual_information) via `qml.mutual_info`:\r\n  \r\n    ```pycon\r\n    >>> dev = qml.device(\"default.qubit\", wires=2)\r\n    >>> @qml.qnode(dev)\r\n    ... def circuit(x):\r\n    ...     qml.IsingXX(x, wires=[0,1])\r\n    ...     return qml.mutual_info(wires0=[0], wires1=[1], log_base=2)\r\n    >>> circuit(np.pi/2)\r\n    2.0\r\n    ```\r\n\r\n  New differentiable transforms are also available in the `qml.qinfo` module:\r\n\r\n  - The classical and quantum [Fisher information](https://en.wikipedia.org/wiki/Fisher_information) via `qml.qinfo.classical_fisher`, `qml.qinfo.quantum_fisher`, respectively:\r\n  \r\n    ```python3\r\n    dev = qml.device(\"default.qubit\", wires=3)\r\n\r\n    @qml.qnode(dev)\r\n    def circ(params):\r\n        qml.RY(params[0], wires=1)\r\n        qml.CNOT(wires=(1,0))\r\n        qml.RY(params[1], wires=1)\r\n        qml.RZ(params[2], wires=1)\r\n        return qml.expval(qml.PauliX(0) @ qml.PauliX(1) - 0.5 * qml.PauliZ(1))\r\n\r\n    params = np.array([0.5, 1., 0.2], requires_grad=True)\r\n    cfim = qml.qinfo.classical_fisher(circ)(params)\r\n    qfim = qml.qinfo.quantum_fisher(circ)(params)\r\n    ```\r\n\r\n    These quantities are typically employed in variational optimization schemes to tilt the gradient in a more favourable direction  --- producing what is known as the [natural gradient](https://pennylane.ai/qml/demos/tutorial_quantum_natural_gradient.html). For example:\r\n\r\n    ```pycon\r\n    >>> grad = qml.grad(circ)(params)\r\n    >>> cfim @ grad  # natural gradient\r\n    [ 5.94225615e-01 -2.61509542e-02 -1.18674655e-18]\r\n    >>> qfim @ grad  # quantum natural gradient\r\n    [ 0.59422561 -0.02615095 -0.03989212]\r\n    ```\r\n\r\n  - The fidelity between two arbitrary states via `qml.qinfo.fidelity`:\r\n\r\n    ```python\r\n    dev = qml.device('default.qubit', wires=1)\r\n  \r\n    @qml.qnode(dev)\r\n    def circuit_rx(x):\r\n        qml.RX(x[0], wires=0)\r\n        qml.RZ(x[1], wires=0)\r\n        return qml.state()\r\n  \r\n    @qml.qnode(dev)\r\n    def circuit_ry(y):\r\n        qml.RY(y, wires=0)\r\n        return qml.state()\r\n    ```\r\n\r\n    ```pycon\r\n    >>> x = np.array([0.1, 0.3], requires_grad=True)\r\n    >>> y = np.array(0.2, requires_grad=True) \r\n    >>> fid_func = qml.qinfo.fidelity(circuit_rx, circuit_ry, wires0=[0], wires1=[0])\r\n    >>> fid_func(x, y)\r\n    0.9905158135644924\r\n    >>> df = qml.grad(fid_func)\r\n    >>> df(x, y)\r\n    (array([-0.04768725, -0.29183666]), array(-0.09489803))\r\n    ```\r\n\r\n  - [Reduced density matrices](https://en.wikipedia.org/wiki/Quantum_entanglement#Reduced_density_matrices) of arbitrary states via `qml.qinfo.reduced_dm`:\r\n\r\n    ```python\r\n    dev = qml.device(\"default.qubit\", wires=2)\r\n    @qml.qnode(dev)\r\n    def circuit(x):\r\n        qml.IsingXX(x, wires=[0,1])\r\n        return qml.state()\r\n    ```\r\n\r\n    ```pycon\r\n    >>> qml.qinfo.reduced_dm(circuit, wires=[0])(np.pi/2)\r\n    [[0.5+0.j 0.+0.j]\r\n      [0.+0.j 0.5+0.j]]\r\n    ```\r\n\r\n  - Similar transforms, `qml.qinfo.vn_entropy` and `qml.qinfo.mutual_info` exist\r\n    for transforming QNodes.\r\n\r\n  Currently, all quantum information measurements and transforms are differentiable, but only support statevector devices, with hardware support to come in a future release (with the exception of `qml.qinfo.classical_fisher` and `qml.qinfo.quantum_fisher`, which are both hardware compatible).\r\n\r\n  For more information, check out the new [qinfo module](https://pennylane.readthedocs.io/en/stable/code/qml_qinfo.html) and [measurements page](https://pennylane.readthedocs.io/en/stable/introduction/measurements.html).\r\n\r\n* In addition to the QNode transforms and measurements above, functions for computing and differentiating quantum information metrics with numerical statevectors and density matrices have been added to the `qml.math` module. This enables flexible custom post-processing.\r\n\r\n  Added functions include:\r\n\r\n  - `qml.math.reduced_dm`\r\n  - `qml.math.vn_entropy`\r\n  - `qml.math.mutual_info`\r\n  - `qml.math.fidelity`\r\n  \r\n  For example:\r\n\r\n  ```pycon\r\n  >>> x = torch.tensor([1.0, 0.0, 0.0, 1.0], requires_grad=True)\r\n  >>> en = qml.math.vn_entropy(x / np.sqrt(2.), indices=[0])\r\n  >>> en\r\n  tensor(0.6931, dtype=torch.float64, grad_fn=<DivBackward0>)\r\n  >>> en.backward()\r\n  >>> x.grad\r\n  tensor([-0.3069,  0.0000,  0.0000, -0.3069])\r\n  ```\r\n\r\n<h4>Faster mixed-state training with backpropagation \ud83d\udcc9</h4>\r\n\r\n* The `default.mixed` device now supports differentiation via backpropagation with the Autograd, TensorFlow, and PyTorch (CPU) interfaces, leading to significantly more performant optimization and training. [(#2615)](https://github.com/PennyLaneAI/pennylane/pull/2615) [(#2670)](https://github.com/PennyLaneAI/pennylane/pull/2670) [(#2680)](https://github.com/PennyLaneAI/pennylane/pull/2680)\r\n\r\n  As a result, the default differentiation method for the device is now `\"backprop\"`. To continue using the old default `\"parameter-shift\"`, explicitly specify this differentiation method in the QNode:\r\n\r\n  ```python\r\n  dev = qml.device(\"default.mixed\", wires=2)\r\n\r\n  @qml.qnode(dev, interface=\"autograd\", diff_method=\"backprop\")\r\n  def circuit(x):\r\n      qml.RY(x, wires=0)\r\n      qml.CNOT(wires=[0, 1])\r\n      return qml.expval(qml.PauliZ(wires=1))\r\n  ```\r\n  ```pycon\r\n  >>> x = np.array(0.5, requires_grad=True)\r\n  >>> circuit(x)\r\n  array(0.87758256)\r\n  >>> qml.grad(circuit)(x)\r\n  -0.479425538604203\r\n  ```\r\n\r\n<h4>Support for quantum parameter broadcasting \ud83d\udce1</h4>\r\n\r\n* Quantum operators, functions, and tapes now support broadcasting across parameter dimensions, making it more convenient for developers to execute their PennyLane programs with multiple sets of parameters. [(#2575)](https://github.com/PennyLaneAI/pennylane/pull/2575) [(#2609)](https://github.com/PennyLaneAI/pennylane/pull/2609)\r\n\r\n  Parameter broadcasting refers to passing tensor parameters with additional leading dimensions to quantum operators; additional dimensions will flow through the computation, and produce additional dimensions at the output.\r\n\r\n  For example, instantiating a rotation gate with a one-dimensional array leads to a broadcasted `Operation`:\r\n\r\n  ```pycon\r\n  >>> x = np.array([0.1, 0.2, 0.3], requires_grad=True)\r\n  >>> op = qml.RX(x, 0)\r\n  >>> op.batch_size\r\n  3\r\n  ```\r\n\r\n  Its matrix correspondingly is augmented by a leading dimension of size `batch_size`:\r\n\r\n  ```pycon\r\n  >>> np.round(qml.matrix(op), 4)\r\n  tensor([[[0.9988+0.j    , 0.    -0.05j  ],\r\n         [0.    -0.05j  , 0.9988+0.j    ]],\r\n        [[0.995 +0.j    , 0.    -0.0998j],\r\n         [0.    -0.0998j, 0.995 +0.j    ]],\r\n        [[0.9888+0.j    , 0.    -0.1494j],\r\n         [0.    -0.1494j, 0.9888+0.j    ]]], requires_grad=True)\r\n  >>> qml.matrix(op).shape\r\n  (3, 2, 2)\r\n  ```\r\n  \r\n  This can be extended to quantum functions, where we may mix-and-match operations with batched parameters and those without. However, the `batch_size` of each batched `Operator` within the quantum function must be the same:\r\n\r\n  ```pycon\r\n  >>> dev = qml.device('default.qubit', wires=1)\r\n  >>> @qml.qnode(dev)\r\n  ... def circuit_rx(x, z):\r\n  ...     qml.RX(x, wires=0)\r\n  ...     qml.RZ(z, wires=0)\r\n  ...     qml.RY(0.3, wires=0)\r\n  ...     return qml.probs(wires=0)\r\n  >>> circuit_rx([0.1, 0.2], [0.3, 0.4])\r\n  tensor([[0.97092256, 0.02907744],\r\n          [0.95671515, 0.04328485]], requires_grad=True)\r\n  ```\r\n\r\n  Parameter broadcasting is supported on all devices, hardware and simulator. Note that if not natively supported by the underlying device, parameter broadcasting may result in additional quantum device evaluations.\r\n\r\n* A new transform, `qml.transforms.broadcast_expand`, has been added, which automates the process of transforming quantum functions (and tapes) to multiple quantum evaluations with no parameter broadcasting. [(#2590)](https://github.com/PennyLaneAI/pennylane/pull/2590)\r\n\r\n  ```pycon\r\n  >>> dev = qml.device('default.qubit', wires=1)\r\n  >>> @qml.transforms.broadcast_expand()\r\n  >>> @qml.qnode(dev)\r\n  ... def circuit_rx(x, z):\r\n  ...     qml.RX(x, wires=0)\r\n  ...     qml.RZ(z, wires=0)\r\n  ...     qml.RY(0.3, wires=0)\r\n  ...     return qml.probs(wires=0)\r\n  >>> print(qml.draw(circuit_rx)([0.1, 0.2], [0.3, 0.4]))\r\n  0: \u2500\u2500RX(0.10)\u2500\u2500RZ(0.30)\u2500\u2500RY(0.30)\u2500\u2524  Probs\r\n  \\\r\n  0: \u2500\u2500RX(0.20)\u2500\u2500RZ(0.40)\u2500\u2500RY(0.30)\u2500\u2524  Probs\r\n  ```\r\n\r\n  Under-the-hood, this transform is used for devices that don't natively support parameter broadcasting.\r\n\r\n* To specify that a device natively supports broadcasted tapes, the new flag `Device.capabilities()[\"supports_broadcasting\"]` should be set to `True`.\r\n\r\n* To support parameter broadcasting for new or custom operations, the following new `Operator` class attributes must be specified:\r\n\r\n  - `Operator.ndim_params` specifies expected number of dimensions for each parameter\r\n\r\n  Once set, `Operator.batch_size` and `QuantumTape.batch_size` will dynamically compute the parameter broadcasting axis dimension, if present.\r\n\r\n<h4>Improved JAX JIT support \ud83c\udfce</h4>\r\n\r\n* JAX just-in-time (JIT) compilation now supports vector-valued QNodes, enabling new types of workflows and significant performance boosts. [(#2034)](https://github.com/PennyLaneAI/pennylane/pull/2034)\r\n  \r\n  Vector-valued QNodes include those with:\r\n  * `qml.probs`;\r\n  * `qml.state`;\r\n  * `qml.sample` or\r\n  * multiple `qml.expval` / `qml.var` measurements.\r\n\r\n  Consider a QNode that returns basis-state probabilities:\r\n\r\n  ```python\r\n  dev = qml.device('default.qubit', wires=2)\r\n  x = jnp.array(0.543)\r\n  y = jnp.array(-0.654)\r\n\r\n  @jax.jit\r\n  @qml.qnode(dev, diff_method=\"parameter-shift\", interface=\"jax\")\r\n  def circuit(x, y):\r\n      qml.RX(x, wires=[0])\r\n      qml.RY(y, wires=[1])\r\n      qml.CNOT(wires=[0, 1])\r\n      return qml.probs(wires=[1])\r\n  ```\r\n  ```pycon\r\n  >>> circuit(x, y)\r\n  DeviceArray([0.8397495 , 0.16025047], dtype=float32)\r\n  ```\r\n\r\n  Note that computing the jacobian of vector-valued QNode is not supported with JAX JIT. The output of vector-valued QNodes can, however, be used in the definition of scalar-valued cost functions whose gradients can be computed.\r\n\r\n  For example, one can define a cost function that outputs the first element of the probability vector:\r\n\r\n  ```python\r\n  def cost(x, y):\r\n      return circuit(x, y)[0]\r\n  ```\r\n  \r\n  ```pycon\r\n  >>> jax.grad(cost, argnums=[0])(x, y)\r\n  (DeviceArray(-0.2050439, dtype=float32),)\r\n  ```\r\n\r\n<h4>More drawing styles \ud83c\udfa8</h4>\r\n\r\n* New `solarized_light` and `solarized_dark` styles are available for drawing circuit diagram graphics.  [(#2662)](https://github.com/PennyLaneAI/pennylane/pull/2662)\r\n\r\n<h4>New operations & transforms \ud83e\udd16</h4>  \r\n  \r\n* The `qml.IsingXY` gate is now available (see [1912.04424](https://arxiv.org/abs/1912.04424)).  [(#2649)](https://github.com/PennyLaneAI/pennylane/pull/2649)\r\n\r\n* The `qml.ECR` (echoed cross-resonance) operation is now available (see [2105.01063](https://arxiv.org/pdf/2105.01063.pdf)). This gate is a maximally-entangling gate and is equivalent to a CNOT gate up to single-qubit pre-rotations. [(#2613)](https://github.com/PennyLaneAI/pennylane/pull/2613)\r\n\r\n* The adjoint transform `adjoint` can now accept either a single instantiated operator or a quantum function. It returns an entity of the same type / call signature as what it was given: [(#2222)](https://github.com/PennyLaneAI/pennylane/pull/2222) [(#2672)](https://github.com/PennyLaneAI/pennylane/pull/2672)\r\n\r\n  ```pycon\r\n  >>> qml.adjoint(qml.PauliX(0))\r\n  Adjoint(PauliX)(wires=[0])\r\n  >>> qml.adjoint(qml.RX)(1.23, wires=0)\r\n  Adjoint(RX)(1.23, wires=[0])\r\n  ```\r\n\r\n  Now, `adjoint` wraps operators in a symbolic operator class `qml.ops.op_math.Adjoint`. This class should not be constructed directly; the `adjoint` constructor should always be used instead. The class behaves just like any other `Operator`:\r\n\r\n  ```pycon\r\n  >>> op = qml.adjoint(qml.S(0))\r\n  >>> qml.matrix(op)\r\n  array([[1.-0.j, 0.-0.j],\r\n        [0.-0.j, 0.-1.j]])\r\n  >>> qml.eigvals(op)\r\n  array([1.-0.j, 0.-1.j])\r\n  ```\r\n\r\n* A new symbolic operator class `qml.ops.op_math.Pow` represents an operator raised to a power. When `decomposition()` is called, a list of new operators equal to this one raised to the given power is given: [(#2621)](https://github.com/PennyLaneAI/pennylane/pull/2621)\r\n\r\n  ```pycon\r\n  >>> op = qml.ops.op_math.Pow(qml.PauliX(0), 0.5)\r\n  >>> op.decomposition()\r\n  [SX(wires=[0])]\r\n  >>> qml.matrix(op)\r\n  array([[0.5+0.5j, 0.5-0.5j],\r\n       [0.5-0.5j, 0.5+0.5j]])\r\n  ```\r\n\r\n* A new transform `qml.batch_partial` is available which behaves similarly to `functools.partial`, but supports batching in the unevaluated parameters. [(#2585)](https://github.com/PennyLaneAI/pennylane/pull/2585)\r\n\r\n  This is useful for executing a circuit with a batch dimension in some of its parameters:\r\n\r\n  ```python\r\n  dev = qml.device(\"default.qubit\", wires=1)\r\n\r\n  @qml.qnode(dev)\r\n  def circuit(x, y):\r\n     qml.RX(x, wires=0)\r\n     qml.RY(y, wires=0)\r\n     return qml.expval(qml.PauliZ(wires=0))\r\n  ```\r\n\r\n  ```pycon\r\n  >>> batched_partial_circuit = qml.batch_partial(circuit, x=np.array(np.pi / 4))\r\n  >>> y = np.array([0.2, 0.3, 0.4])\r\n  >>> batched_partial_circuit(y=y)\r\n  tensor([0.69301172, 0.67552491, 0.65128847], requires_grad=True)\r\n  ```\r\n\r\n* A new transform `qml.split_non_commuting` is available, which splits a quantum function or tape into multiple functions/tapes determined by groups of commuting observables: [(#2587)](https://github.com/PennyLaneAI/pennylane/pull/2587)\r\n\r\n  ```python\r\n  dev = qml.device(\"default.qubit\", wires=1)\r\n\r\n  @qml.transforms.split_non_commuting\r\n  @qml.qnode(dev)\r\n  def circuit(x):\r\n      qml.RX(x,wires=0)\r\n      return [qml.expval(qml.PauliX(0)), qml.expval(qml.PauliZ(0))]\r\n  ```\r\n\r\n  ```pycon\r\n  >>> print(qml.draw(circuit)(0.5))\r\n  0: \u2500\u2500RX(0.50)\u2500\u2524  <X>\r\n  \\\r\n  0: \u2500\u2500RX(0.50)\u2500\u2524  <Z>\r\n  ```\r\n\r\n<h3>Improvements</h3>\r\n\r\n* Expectation values of multiple non-commuting observables from within a single QNode are now supported: [(#2587)](https://github.com/PennyLaneAI/pennylane/pull/2587)\r\n\r\n  ```\r\n  >>> dev = qml.device('default.qubit', wires=1)\r\n  >>> @qml.qnode(dev)\r\n  ... def circuit_rx(x, z):\r\n  ...     qml.RX(x, wires=0)\r\n  ...     qml.RZ(z, wires=0)\r\n  ...     return qml.expval(qml.PauliX(0)), qml.expval(qml.PauliY(0))\r\n  >>> circuit_rx(0.1, 0.3)\r\n  tensor([ 0.02950279, -0.09537451], requires_grad=True)\r\n  ```\r\n\r\n* Selecting which parts of parameter-shift Hessians are computed is now possible. [(#2538)](https://github.com/PennyLaneAI/pennylane/pull/2538)\r\n\r\n  The `argnum` keyword argument for `qml.gradients.param_shift_hessian` is now allowed to be a two-dimensional Boolean `array_like`. Only the indicated entries of the Hessian will then be computed.\r\n\r\n  A particularly useful example is the computation of the diagonal of the Hessian:\r\n\r\n  ```python\r\n  dev = qml.device(\"default.qubit\", wires=1)\r\n\r\n  @qml.qnode(dev)\r\n  def circuit(x):\r\n      qml.RX(x[0], wires=0)\r\n      qml.RY(x[1], wires=0)\r\n      qml.RX(x[2], wires=0)\r\n      return qml.expval(qml.PauliZ(0))\r\n\r\n  argnum = qml.math.eye(3, dtype=bool)\r\n  x = np.array([0.2, -0.9, 1.1], requires_grad=True)\r\n  ```\r\n\r\n  ```pycon\r\n  >>> qml.gradients.param_shift_hessian(circuit, argnum=argnum)(x)\r\n  tensor([[-0.09928388,  0.        ,  0.        ],\r\n          [ 0.        , -0.27633945,  0.        ],\r\n          [ 0.        ,  0.        , -0.09928388]], requires_grad=True)\r\n  ```\r\n\r\n* Commuting Pauli operators are now measured faster. [(#2425)](https://github.com/PennyLaneAI/pennylane/pull/2425)\r\n\r\n  The logic that checks for qubit-wise commuting (QWC) observables has been improved, resulting in a performance boost that is noticable when many commuting Pauli operators of the same type are measured.\r\n\r\n* It is now possible to add `Observable` objects to the integer `0`, for example `qml.PauliX(wires=[0]) + 0`. [(#2603)](https://github.com/PennyLaneAI/pennylane/pull/2603)\r\n\r\n* Wires can now be passed as the final argument to an `Operator`, instead of requiring the wires to be explicitly specified with keyword `wires`. This functionality already existed for `Observable`s, but now extends to all `Operator`s: [(#2432)](https://github.com/PennyLaneAI/pennylane/pull/2432)\r\n\r\n  ```pycon\r\n  >>> qml.S(0)\r\n  S(wires=[0])\r\n  >>> qml.CNOT((0,1))\r\n  CNOT(wires=[0, 1])\r\n  ```\r\n\r\n* The `qml.taper` function can now be used to consistently taper any additional observables such as dipole moment, particle number, and spin operators using the symmetries obtained from the Hamiltonian. [(#2510)](https://github.com/PennyLaneAI/pennylane/pull/2510)\r\n\r\n* Sparse Hamiltonians' representation has changed from Coordinate (COO) to Compressed Sparse Row (CSR) format. [(#2561)](https://github.com/PennyLaneAI/pennylane/pull/2561)\r\n\r\n  The CSR representation is more performant for arithmetic operations and matrix-vector products. This change decreases the `expval()` calculation time for `qml.SparseHamiltonian`, specially for large workflows. In addition, the CSR format consumes less memory for `qml.SparseHamiltonian` storage.\r\n\r\n* IPython now displays the `str` representation of a `Hamiltonian`, rather than the `repr`. This displays more information about the object.[(#2648)](https://github.com/PennyLaneAI/pennylane/pull/2648)\r\n\r\n* The `qml.qchem` tests have been restructured. [(#2593)](https://github.com/PennyLaneAI/pennylane/pull/2593) [(#2545)](https://github.com/PennyLaneAI/pennylane/pull/2545)\r\n\r\n  - OpenFermion-dependent tests are now localized and collected in `tests.qchem.of_tests`. The new module `test_structure` is created to collect the tests of the `qchem.structure` module in one place and remove their dependency to OpenFermion.\r\n\r\n  - Test classes have been created to group the integrals and matrices unit tests.\r\n\r\n* An `operations_only` argument is introduced to the `tape.get_parameters` method. [(#2543)](https://github.com/PennyLaneAI/pennylane/pull/2543)\r\n\r\n* The `gradients` module now uses faster subroutines and uniform formats of gradient rules. [(#2452)](https://github.com/XanaduAI/pennylane/pull/2452)\r\n\r\n* Instead of checking types, objects are now processed in the `QuantumTape` based on a new `_queue_category` property. This is a temporary fix that will disappear in the future. [(#2408)](https://github.com/PennyLaneAI/pennylane/pull/2408)\r\n\r\n* The `QNode` class now contains a new method `best_method_str` that returns the best differentiation method for a provided device and interface, in human-readable format. [(#2533)](https://github.com/PennyLaneAI/pennylane/pull/2533)\r\n  \r\n* Using `Operation.inv()` in a queuing environment no longer updates the queue's metadata, but merely updates the operation in place. [(#2596)](https://github.com/PennyLaneAI/pennylane/pull/2596)\r\n\r\n* A new method `safe_update_info` is added to `qml.QueuingContext`. This method is substituted for `qml.QueuingContext.update_info` in a variety of places. [(#2612)](https://github.com/PennyLaneAI/pennylane/pull/2612) [(#2675)](https://github.com/PennyLaneAI/pennylane/pull/2675)\r\n\r\n* `BasisEmbedding` can accept an int as argument instead of a list of bits. [(#2601)](https://github.com/PennyLaneAI/pennylane/pull/2601)\r\n\r\n  For example, `qml.BasisEmbedding(4, wires = range(4))` is now equivalent to `qml.BasisEmbedding([0,1,0,0], wires = range(4))` (as `4==0b100`).\r\n\r\n* Introduced a new `is_hermitian` property to `Operator`s to determine if an operator can be used in a measurement process. [(#2629)](https://github.com/PennyLaneAI/pennylane/pull/2629)\r\n\r\n* Added separate `requirements_dev.txt` for separation of concerns for code development and just using PennyLane. [(#2635)](https://github.com/PennyLaneAI/pennylane/pull/2635)\r\n\r\n* The performance of building sparse Hamiltonians has been improved by accumulating the sparse representation of coefficient-operator pairs in a temporary storage and by eliminating unnecessary `kron` operations on identity matrices. [(#2630)](https://github.com/PennyLaneAI/pennylane/pull/2630)\r\n\r\n* Control values are now displayed distinctly in text and matplotlib drawings of circuits. [(#2668)](https://github.com/PennyLaneAI/pennylane/pull/2668)\r\n\r\n* The `TorchLayer` `init_method` argument now accepts either a `torch.nn.init` function or a dictionary which should specify a `torch.nn.init`/`torch.Tensor` for each different weight. [(#2678)](https://github.com/PennyLaneAI/pennylane/pull/2678)\r\n\r\n* The unused keyword argument `do_queue` for `Operation.adjoint` is now fully removed. [(#2583)](https://github.com/PennyLaneAI/pennylane/pull/2583)\r\n\r\n* Several non-decomposable `Adjoint` operators are added to the device test suite. [(#2658)](https://github.com/PennyLaneAI/pennylane/pull/2658)\r\n\r\n* The developer-facing `pow` method has been added to `Operator` with concrete implementations for many classes. [(#2225)](https://github.com/PennyLaneAI/pennylane/pull/2225)\r\n\r\n* The `ctrl` transform and `ControlledOperation` have been moved to the new `qml.ops.op_math` submodule. The developer-facing `ControlledOperation` class is no longer imported top-level. [(#2656)](https://github.com/PennyLaneAI/pennylane/pull/2656)\r\n\r\n<h3>Deprecations</h3>\r\n\r\n* `qml.ExpvalCost` has been deprecated, and usage will now raise a warning. [(#2571)](https://github.com/PennyLaneAI/pennylane/pull/2571)\r\n\r\n  Instead, it is recommended to simply pass Hamiltonians to the `qml.expval` function inside QNodes:\r\n\r\n  ```python\r\n  @qml.qnode(dev)\r\n  def ansatz(params):\r\n      some_qfunc(params)\r\n      return qml.expval(Hamiltonian)\r\n  ```\r\n\r\n<h3>Breaking changes</h3>\r\n\r\n* When using `qml.TorchLayer`, weights with negative shapes will now raise an error, while weights with `size = 0` will result in creating empty Tensor objects. [(#2678)](https://github.com/PennyLaneAI/pennylane/pull/2678)\r\n  \r\n* PennyLane no longer supports TensorFlow `<=2.3`. [(#2683)](https://github.com/PennyLaneAI/pennylane/pull/2683)\r\n\r\n* The `qml.queuing.Queue` class has been removed.  [(#2599)](https://github.com/PennyLaneAI/pennylane/pull/2599)\r\n\r\n* The `qml.utils.expand` function is now removed; `qml.operation.expand_matrix` should be used instead. [(#2654)](https://github.com/PennyLaneAI/pennylane/pull/2654)\r\n\r\n* The module `qml.gradients.param_shift_hessian` has been renamed to `qml.gradients.parameter_shift_hessian` in order to distinguish it from the identically named function. Note that the `param_shift_hessian` function is unaffected by this change and can be invoked in the same manner as before via the `qml.gradients` module. [(#2528)](https://github.com/PennyLaneAI/pennylane/pull/2528)\r\n  \r\n* The properties `eigval` and `matrix` from the `Operator` class were replaced with the methods `eigval()` and `matrix(wire_order=None)`. [(#2498)](https://github.com/PennyLaneAI/pennylane/pull/2498)\r\n\r\n* `Operator.decomposition()` is now an instance method, and no longer accepts parameters. [(#2498)](https://github.com/PennyLaneAI/pennylane/pull/2498)\r\n\r\n* Adds tests, adds no-coverage directives, and removes inaccessible logic to improve code coverage. [(#2537)](https://github.com/PennyLaneAI/pennylane/pull/2537)\r\n\r\n* The base classes `QubitDevice` and `DefaultQubit` now accept data-types for a statevector. This enables a derived class (device) in a plugin to choose correct data-types: [(#2448)](https://github.com/PennyLaneAI/pennylane/pull/2448)\r\n\r\n  ```pycon\r\n  >>> dev = qml.device(\"default.qubit\", wires=4, r_dtype=np.float32, c_dtype=np.complex64)\r\n  >>> dev.R_DTYPE\r\n  <class 'numpy.float32'>\r\n  >>> dev.C_DTYPE\r\n  <class 'numpy.complex64'>\r\n  ```\r\n\r\n<h3>Bug fixes</h3>\r\n\r\n* Fixed a bug where returning `qml.density_matrix` using the PyTorch interface would return a density matrix with wrong shape. [(#2643)](https://github.com/PennyLaneAI/pennylane/pull/2643)\r\n\r\n* Fixed a bug to make `param_shift_hessian` work with QNodes in which gates marked as trainable do not have any impact on the QNode output. [(#2584)](https://github.com/PennyLaneAI/pennylane/pull/2584)\r\n\r\n* QNodes can now interpret variations on the interface name, like `\"tensorflow\"` or `\"jax-jit\"`, when requesting backpropagation. [(#2591)](https://github.com/PennyLaneAI/pennylane/pull/2591)\r\n\r\n* Fixed a bug for `diff_method=\"adjoint\"` where incorrect gradients were computed for QNodes with parametrized observables (e.g., `qml.Hermitian`). [(#2543)](https://github.com/PennyLaneAI/pennylane/pull/2543)\r\n\r\n* Fixed a bug where `QNGOptimizer` did not work with operators whose generator was a Hamiltonian. [(#2524)](https://github.com/PennyLaneAI/pennylane/pull/2524)\r\n\r\n* Fixed a bug with the decomposition of `qml.CommutingEvolution`. [(#2542)](https://github.com/PennyLaneAI/pennylane/pull/2542)\r\n\r\n* Fixed a bug enabling PennyLane to work with the latest version of Autoray. [(#2549)](https://github.com/PennyLaneAI/pennylane/pull/2549)\r\n\r\n* Fixed a bug which caused different behaviour for `Hamiltonian @ Observable` and `Observable @ Hamiltonian`. [(#2570)](https://github.com/PennyLaneAI/pennylane/pull/2570)\r\n\r\n* Fixed a bug in `DiagonalQubitUnitary._controlled` where an invalid operation was queued instead of the controlled version of the diagonal unitary. [(#2525)](https://github.com/PennyLaneAI/pennylane/pull/2525)\r\n\r\n* Updated the gradients fix to only apply to the `strawberryfields.gbs` device, since the original logic was breaking some devices. [(#2485)](https://github.com/PennyLaneAI/pennylane/pull/2485) [(#2595)](https://github.com/PennyLaneAI/pennylane/pull/2595)\r\n\r\n* Fixed a bug in `qml.transforms.insert` where operations were not inserted after gates within a template. [(#2704)](https://github.com/PennyLaneAI/pennylane/pull/2704)\r\n  \r\n* `Hamiltonian.wires` is now properly updated after in place operations. [(#2738)](https://github.com/PennyLaneAI/pennylane/pull/2738)\r\n\r\n<h3>Documentation</h3>\r\n\r\n* The centralized [Xanadu Sphinx Theme](https://github.com/XanaduAI/xanadu-sphinx-theme) is now used to style the Sphinx documentation. [(#2450)](https://github.com/PennyLaneAI/pennylane/pull/2450)\r\n\r\n* Added a reference to `qml.utils.sparse_hamiltonian` in `qml.SparseHamiltonian` to clarify how to construct sparse Hamiltonians in PennyLane. [(2572)](https://github.com/PennyLaneAI/pennylane/pull/2572)\r\n\r\n* Added a new section in the [Gradients and Training](https://pennylane.readthedocs.io/en/stable/introduction/interfaces.html) page that summarizes the supported device configurations and provides justification. In addition, [code examples](https://pennylane.readthedocs.io/en/stable/introduction/unsupported.html) were added for some selected configurations. [(#2540)](https://github.com/PennyLaneAI/pennylane/pull/2540)\r\n\r\n* Added a note for the [Depolarization Channel (https://pennylane.readthedocs.io/en/stable/code/api/pennylane.DepolarizingChannel.html) that specifies how the channel behaves for the different values of depolarization probability `p`. [(#2669)](https://github.com/PennyLaneAI/pennylane/pull/2669)\r\n\r\n* The quickstart documentation has been improved. [(#2530)](https://github.com/PennyLaneAI/pennylane/pull/2530) [(#2534)](https://github.com/PennyLaneAI/pennylane/pull/2534) [(#2564](https://github.com/PennyLaneAI/pennylane/pull/2564) [(#2565](https://github.com/PennyLaneAI/pennylane/pull/2565) [(#2566)](https://github.com/PennyLaneAI/pennylane/pull/2566) [(#2607)](https://github.com/PennyLaneAI/pennylane/pull/2607) [(#2608)](https://github.com/PennyLaneAI/pennylane/pull/2608)\r\n  \r\n* The quantum chemistry quickstart documentation has been improved. [(#2500)](https://github.com/PennyLaneAI/pennylane/pull/2500)\r\n  \r\n* Testing documentation has been improved. [(#2536)](https://github.com/PennyLaneAI/pennylane/pull/2536)\r\n  \r\n* Documentation for the `pre-commit` package has been added. [(#2567)](https://github.com/PennyLaneAI/pennylane/pull/2567)\r\n  \r\n* Documentation for draw control wires change has been updated. [(#2682)](https://github.com/PennyLaneAI/pennylane/pull/2682)\r\n  \r\n<h3>Contributors</h3>\r\n\r\nThis release contains contributions from (in alphabetical order):\r\n\r\nGuillermo Alonso-Linaje, Mikhail Andrenkov, Juan Miguel Arrazola, Ali Asadi, Utkarsh Azad, Samuel Banning, Avani Bhardwaj, Thomas Bromley, Albert Mitjans Coma, Isaac De Vlugt, Amintor Dusko, Trent Fridey, Christian Gogolin, Qi Hu, Katharine Hyatt, David Ittah, Josh Izaac, Soran Jahangiri, Edward Jiang, Nathan Killoran, Korbinian Kottmann, Ankit Khandelwal, Christina Lee, Chae-Yeun Park, Mason Moreland, Romain Moyard, Maria Schuld, Jay Soni, Antal Sz\u00e1va, tal66, David Wierichs, Roeland Wiersema, WingCode."}
{"url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/66383741", "assets_url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/66383741/assets", "upload_url": "https://uploads.github.com/repos/PennyLaneAI/pennylane/releases/66383741/assets{?name,label}", "html_url": "https://github.com/PennyLaneAI/pennylane/releases/tag/v0.23.1", "id": 66383741, "author": {"login": "antalszava", "id": 24476053, "node_id": "MDQ6VXNlcjI0NDc2MDUz", "avatar_url": "https://avatars.githubusercontent.com/u/24476053?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antalszava", "html_url": "https://github.com/antalszava", "followers_url": "https://api.github.com/users/antalszava/followers", "following_url": "https://api.github.com/users/antalszava/following{/other_user}", "gists_url": "https://api.github.com/users/antalszava/gists{/gist_id}", "starred_url": "https://api.github.com/users/antalszava/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antalszava/subscriptions", "organizations_url": "https://api.github.com/users/antalszava/orgs", "repos_url": "https://api.github.com/users/antalszava/repos", "events_url": "https://api.github.com/users/antalszava/events{/privacy}", "received_events_url": "https://api.github.com/users/antalszava/received_events", "type": "User", "site_admin": false}, "node_id": "RE_kwDOB76r6M4D9O99", "tag_name": "v0.23.1", "target_commitish": "v0.23.1-rc0", "name": "Release 0.23.1", "draft": false, "prerelease": false, "created_at": "2022-05-09T15:05:11Z", "published_at": "2022-05-09T15:09:40Z", "assets": [], "tarball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/tarball/v0.23.1", "zipball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/zipball/v0.23.1", "body": "<h3>Bug fixes</h3>\r\n\r\n* Fixed a bug enabling PennyLane to work with the latest version of Autoray. [(#2548)](https://github.com/PennyLaneAI/pennylane/pull/2548)\r\n\r\n<h3>Contributors</h3>\r\n\r\nThis release contains contributions from (in alphabetical order):\r\n\r\nJosh Izaac."}
{"url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/65286505", "assets_url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/65286505/assets", "upload_url": "https://uploads.github.com/repos/PennyLaneAI/pennylane/releases/65286505/assets{?name,label}", "html_url": "https://github.com/PennyLaneAI/pennylane/releases/tag/v0.23.0", "id": 65286505, "author": {"login": "antalszava", "id": 24476053, "node_id": "MDQ6VXNlcjI0NDc2MDUz", "avatar_url": "https://avatars.githubusercontent.com/u/24476053?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antalszava", "html_url": "https://github.com/antalszava", "followers_url": "https://api.github.com/users/antalszava/followers", "following_url": "https://api.github.com/users/antalszava/following{/other_user}", "gists_url": "https://api.github.com/users/antalszava/gists{/gist_id}", "starred_url": "https://api.github.com/users/antalszava/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antalszava/subscriptions", "organizations_url": "https://api.github.com/users/antalszava/orgs", "repos_url": "https://api.github.com/users/antalszava/repos", "events_url": "https://api.github.com/users/antalszava/events{/privacy}", "received_events_url": "https://api.github.com/users/antalszava/received_events", "type": "User", "site_admin": false}, "node_id": "RE_kwDOB76r6M4D5DFp", "tag_name": "v0.23.0", "target_commitish": "v0.23.0-rc0", "name": "Release 0.23.0", "draft": false, "prerelease": false, "created_at": "2022-04-25T22:05:00Z", "published_at": "2022-04-25T22:09:35Z", "assets": [], "tarball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/tarball/v0.23.0", "zipball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/zipball/v0.23.0", "body": "<h3>New features since last release</h3>\r\n\r\n<h4> More powerful circuit cutting \u2702\ufe0f</h4>\r\n\r\n* Quantum circuit cutting (running `N`-wire circuits on devices with fewer than `N` wires) is now supported for QNodes of finite-shots using the new `@qml.cut_circuit_mc` transform.  [(#2313)](https://github.com/PennyLaneAI/pennylane/pull/2313) [(#2321)](https://github.com/PennyLaneAI/pennylane/pull/2321) [(#2332)](https://github.com/PennyLaneAI/pennylane/pull/2332) [(#2358)](https://github.com/PennyLaneAI/pennylane/pull/2358) [(#2382)](https://github.com/PennyLaneAI/pennylane/pull/2382) [(#2399)](https://github.com/PennyLaneAI/pennylane/pull/2399) [(#2407)](https://github.com/PennyLaneAI/pennylane/pull/2407) [(#2444)](https://github.com/PennyLaneAI/pennylane/pull/2444)\r\n\r\n  With these new additions, samples from the original circuit can be simulated using a Monte Carlo method, using fewer qubits at the expense of more device executions. Additionally, this transform can take an optional classical processing function as an argument and return an expectation value.\r\n\r\n  The following `3`-qubit circuit contains a `WireCut` operation and a `sample` measurement. When decorated with `@qml.cut_circuit_mc`, we can cut the circuit into two `2`-qubit fragments:\r\n\r\n  ```python\r\n  dev = qml.device(\"default.qubit\", wires=2, shots=1000)\r\n\r\n  @qml.cut_circuit_mc\r\n  @qml.qnode(dev)\r\n  def circuit(x):\r\n      qml.RX(0.89, wires=0)\r\n      qml.RY(0.5, wires=1)\r\n      qml.RX(1.3, wires=2)\r\n\r\n      qml.CNOT(wires=[0, 1])\r\n      qml.WireCut(wires=1)\r\n      qml.CNOT(wires=[1, 2])\r\n\r\n      qml.RX(x, wires=0)\r\n      qml.RY(0.7, wires=1)\r\n      qml.RX(2.3, wires=2)\r\n      return qml.sample(wires=[0, 2])\r\n  ```\r\n\r\n  we can then execute the circuit as usual by calling the QNode:\r\n\r\n  ```pycon\r\n  >>> x = 0.3\r\n  >>> circuit(x)\r\n  tensor([[1, 1],\r\n          [0, 1],\r\n          [0, 1],\r\n          ...,\r\n          [0, 1],\r\n          [0, 1],\r\n          [0, 1]], requires_grad=True)\r\n  ```\r\n\r\n  Furthermore, the number of shots can be temporarily altered when calling the QNode:\r\n\r\n  ```pycon\r\n  >>> results = circuit(x, shots=123)\r\n  >>> results.shape\r\n  (123, 2)\r\n  ```\r\n\r\n  The `cut_circuit_mc` transform also supports returning sample-based expectation values of observables using the `classical_processing_fn` argument. Refer to the `UsageDetails` section of the [transform documentation](https://pennylane.readthedocs.io/en/latest/code/api/pennylane.cut_circuit_mc.html) for an example.\r\n\r\n* The `cut_circuit` transform now supports automatic graph partitioning by specifying `auto_cutter=True` to cut arbitrary tape-converted graphs using the general purpose graph partitioning framework [KaHyPar](https://pypi.org/project/kahypar/).  [(#2330)](https://github.com/PennyLaneAI/pennylane/pull/2330) [(#2428)](https://github.com/PennyLaneAI/pennylane/pull/2428)\r\n\r\n  Note that `KaHyPar` needs to be installed separately with the `auto_cutter=True` option.\r\n\r\n  For integration with the  existing low-level manual cut pipeline, refer to the [documentation of the\r\n  function](https://pennylane.readthedocs.io/en/latest/code/api/pennylane.transforms.qcut.find_and_place_cuts.html).\r\n  ```pycon\r\n  @qml.cut_circuit(auto_cutter=True)\r\n  @qml.qnode(dev)\r\n  def circuit(x):\r\n      qml.RX(x, wires=0)\r\n      qml.RY(0.9, wires=1)\r\n      qml.RX(0.3, wires=2)\r\n      qml.CZ(wires=[0, 1])\r\n      qml.RY(-0.4, wires=0)\r\n      qml.CZ(wires=[1, 2])\r\n      return qml.expval(qml.grouping.string_to_pauli_word(\"ZZZ\"))\r\n  ```\r\n  ```pycon\r\n  >>> x = np.array(0.531, requires_grad=True)\r\n  >>> circuit(x)\r\n  0.47165198882111165\r\n  >>> qml.grad(circuit)(x)\r\n  -0.276982865449393\r\n  ```\r\n\r\n<h4>Grand QChem unification \u269b\ufe0f  \ud83c\udff0</h4>\r\n\r\n* Quantum chemistry functionality --- previously split between an external `pennylane-qchem` package and internal `qml.hf` differentiable Hartree-Fock solver --- is now unified into a single, included, `qml.qchem` module.  [(#2164)](https://github.com/PennyLaneAI/pennylane/pull/2164) [(#2385)](https://github.com/PennyLaneAI/pennylane/pull/2385) [(#2352)](https://github.com/PennyLaneAI/pennylane/pull/2352) [(#2420)](https://github.com/PennyLaneAI/pennylane/pull/2420) [(#2454)](https://github.com/PennyLaneAI/pennylane/pull/2454)  [(#2199)](https://github.com/PennyLaneAI/pennylane/pull/2199) [(#2371)](https://github.com/PennyLaneAI/pennylane/pull/2371) [(#2272)](https://github.com/PennyLaneAI/pennylane/pull/2272) [(#2230)](https://github.com/PennyLaneAI/pennylane/pull/2230) [(#2415)](https://github.com/PennyLaneAI/pennylane/pull/2415) [(#2426)](https://github.com/PennyLaneAI/pennylane/pull/2426) [(#2465)](https://github.com/PennyLaneAI/pennylane/pull/2465)\r\n\r\n  The `qml.qchem` module provides a differentiable Hartree-Fock solver and the functionality to construct a fully-differentiable molecular Hamiltonian.\r\n  \r\n  For example, one can continue to generate molecular Hamiltonians using  `qml.qchem.molecular_hamiltonian`:\r\n\r\n  ```python\r\n  symbols = [\"H\", \"H\"]\r\n  geometry = np.array([[0., 0., -0.66140414], [0., 0., 0.66140414]])\r\n  hamiltonian, qubits = qml.qchem.molecular_hamiltonian(symbols, geometry, method=\"dhf\")\r\n  ```\r\n\r\n  By default, this will use the differentiable Hartree-Fock solver; however, simply set `method=\"pyscf\"` to continue to use PySCF for Hartree-Fock calculations.\r\n\r\n* Functions are added for building a differentiable dipole moment observable. Functions for computing multipole moment molecular integrals, needed for building the dipole moment observable, are also added.  [(#2173)](https://github.com/PennyLaneAI/pennylane/pull/2173) [(#2166)](https://github.com/PennyLaneAI/pennylane/pull/2166)\r\n\r\n  The dipole moment observable can be constructed using `qml.qchem.dipole_moment`:\r\n\r\n  ```python\r\n  symbols  = ['H', 'H']\r\n  geometry = np.array([[0.0, 0.0, 0.0], [0.0, 0.0, 1.0]])\r\n  mol = qml.qchem.Molecule(symbols, geometry)\r\n  args = [geometry]\r\n  D = qml.qchem.dipole_moment(mol)(*args)\r\n  ```\r\n  \r\n* The efficiency of computing molecular integrals and Hamiltonian is improved. This has been done by adding optimized functions for building fermionic and qubit observables and optimizing the functions used for computing the electron repulsion integrals.  [(#2316)](https://github.com/PennyLaneAI/pennylane/pull/2316)\r\n\r\n\r\n* The `6-31G` basis set is added to the qchem basis set repo. This addition allows performing differentiable Hartree-Fock calculations with basis sets beyond the minimal `sto-3g` basis set for atoms with atomic number 1-10.  [(#2372)](https://github.com/PennyLaneAI/pennylane/pull/2372)\r\n\r\n  The `6-31G` basis set can be used to construct a Hamiltonian as  \r\n\r\n  ```python\r\n  symbols = [\"H\", \"H\"]\r\n  geometry = np.array([[0.0, 0.0, 0.0], [0.0, 0.0, 1.0]])\r\n  H, qubits = qml.qchem.molecular_hamiltonian(symbols, geometry, basis=\"6-31g\")\r\n  ```\r\n\r\n* External dependencies are replaced with local functions for spin and particle number observables.  [(#2197)](https://github.com/PennyLaneAI/pennylane/pull/2197) [(#2362)](https://github.com/PennyLaneAI/pennylane/pull/2362)\r\n\r\n<h4>Pattern matching optimization \ud83d\udd0e \ud83d\udc8e </h4>\r\n\r\n* Added an optimization transform that matches pieces of user-provided identity templates in a circuit and replaces them with an equivalent component.  [(#2032)](https://github.com/PennyLaneAI/pennylane/pull/2032)\r\n\r\n  For example, consider the following circuit where we want to replace sequence of two `pennylane.S` gates with a `pennylane.PauliZ` gate.\r\n\r\n  ```python\r\n  def circuit():\r\n      qml.S(wires=0)\r\n      qml.PauliZ(wires=0)\r\n      qml.S(wires=1)\r\n      qml.CZ(wires=[0, 1])\r\n      qml.S(wires=1)\r\n      qml.S(wires=2)\r\n      qml.CZ(wires=[1, 2])\r\n      qml.S(wires=2)\r\n      return qml.expval(qml.PauliX(wires=0))\r\n  ```\r\n\r\n  We specify use the following pattern that implements the identity:\r\n\r\n  ```python\r\n  with qml.tape.QuantumTape() as pattern:\r\n      qml.S(wires=0)\r\n      qml.S(wires=0)\r\n      qml.PauliZ(wires=0)\r\n  ```\r\n\r\n  To optimize the circuit with this identity pattern, we apply the `qml.transforms.pattern_matching` transform.\r\n\r\n  ```pycon\r\n  >>> dev = qml.device('default.qubit', wires=5)\r\n  >>> qnode = qml.QNode(circuit, dev)\r\n  >>> optimized_qfunc = qml.transforms.pattern_matching_optimization(pattern_tapes=[pattern])(circuit)\r\n  >>> optimized_qnode = qml.QNode(optimized_qfunc, dev)\r\n  >>> print(qml.draw(qnode)())\r\n  0: \u2500\u2500S\u2500\u2500Z\u2500\u256dC\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  <X>\r\n  1: \u2500\u2500S\u2500\u2500\u2500\u2500\u2570Z\u2500\u2500S\u2500\u256dC\u2500\u2500\u2500\u2500\u2524\r\n  2: \u2500\u2500S\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2570Z\u2500\u2500S\u2500\u2524\r\n  >>> print(qml.draw(optimized_qnode)())\r\n  0: \u2500\u2500S\u207b\u00b9\u2500\u256dC\u2500\u2500\u2500\u2500\u2524  <X>\r\n  1: \u2500\u2500Z\u2500\u2500\u2500\u2570Z\u2500\u256dC\u2500\u2524\r\n  2: \u2500\u2500Z\u2500\u2500\u2500\u2500\u2500\u2500\u2570Z\u2500\u2524\r\n  ```\r\n\r\n  For more details on using pattern matching optimization you can check the [corresponding documentation](https://pennylane.readthedocs.io/en/latest/code/api/pennylane.pattern_matching_optimization.html) and also the following [paper](https://dl.acm.org/doi/full/10.1145/3498325).\r\n\r\n<h4>Measure the distance between two unitaries\ud83d\udccf</h4>\r\n\r\n* Added the `HilbertSchmidt` and the `LocalHilbertSchmidt` templates to be used for computing distance measures between unitaries.  [(#2364)](https://github.com/PennyLaneAI/pennylane/pull/2364)\r\n\r\n  Given a unitary `U`, `qml.HilberSchmidt` can be used to measure the distance between unitaries and to define a cost function (`cost_hst`) used for learning a unitary `V` that is equivalent to `U` up to a global phase:\r\n  ```python\r\n  # Represents unitary U\r\n  with qml.tape.QuantumTape(do_queue=False) as u_tape:\r\n      qml.Hadamard(wires=0)\r\n\r\n  # Represents unitary V\r\n  def v_function(params):\r\n      qml.RZ(params[0], wires=1)\r\n\r\n  @qml.qnode(dev)\r\n  def hilbert_test(v_params, v_function, v_wires, u_tape):\r\n      qml.HilbertSchmidt(v_params, v_function=v_function, v_wires=v_wires, u_tape=u_tape)\r\n      return qml.probs(u_tape.wires + v_wires)\r\n\r\n  def cost_hst(parameters, v_function, v_wires, u_tape):\r\n      return (1 - hilbert_test(v_params=parameters, v_function=v_function, v_wires=v_wires, u_tape=u_tape)[0])\r\n  ```\r\n  ```pycon\r\n  >>> cost_hst(parameters=[0.1], v_function=v_function, v_wires=[1], u_tape=u_tape)\r\n  tensor(0.999, requires_grad=True)\r\n  ```\r\n  For more information refer to the [documentation of qml.HilbertSchmidt](https://pennylane.readthedocs.io/en/latest/code/api/pennylane.HilbertSchmidt.html).\r\n\r\n<h4>More tensor network support \ud83d\udd78\ufe0f</h4>\r\n\r\n* Adds the `qml.MERA` template for implementing quantum circuits with the shape of a multi-scale entanglement renormalization ansatz (MERA).  [(#2418)](https://github.com/PennyLaneAI/pennylane/pull/2418)\r\n\r\n  MERA follows the style of previous tensor network templates and is similar to [quantum convolutional neural networks](https://arxiv.org/abs/1810.03787).\r\n\r\n  ```python\r\n    def block(weights, wires):\r\n        qml.CNOT(wires=[wires[0],wires[1]])\r\n        qml.RY(weights[0], wires=wires[0])\r\n        qml.RY(weights[1], wires=wires[1])\r\n\r\n    n_wires = 4\r\n    n_block_wires = 2\r\n    n_params_block = 2\r\n    n_blocks = qml.MERA.get_n_blocks(range(n_wires),n_block_wires)\r\n    template_weights = [[0.1,-0.3]]*n_blocks\r\n\r\n    dev= qml.device('default.qubit',wires=range(n_wires))\r\n    @qml.qnode(dev)\r\n    def circuit(template_weights):\r\n        qml.MERA(range(n_wires),n_block_wires,block, n_params_block, template_weights)\r\n        return qml.expval(qml.PauliZ(wires=1))\r\n  ```\r\n  It may be necessary to reorder the wires to see the MERA architecture clearly:\r\n  ```pycon\r\n  >>> print(qml.draw(circuit,expansion_strategy='device',wire_order=[2,0,1,3])(template_weights))\r\n  2: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256dC\u2500\u2500RY(0.10)\u2500\u2500\u256dX\u2500\u2500RY(-0.30)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n  0: \u2500\u256dX\u2500\u2500RY(-0.30)\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2570C\u2500\u2500RY(0.10)\u2500\u2500\u256dC\u2500\u2500RY(0.10)\u2500\u2500\u2524\r\n  1: \u2500\u2570C\u2500\u2500RY(0.10)\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256dX\u2500\u2500RY(-0.30)\u2500\u2570X\u2500\u2500RY(-0.30)\u2500\u2524  <Z>\r\n  3: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2570X\u2500\u2500RY(-0.30)\u2500\u2570C\u2500\u2500RY(0.10)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n  ```\r\n\r\n<h4>New transform for transpilation \u2699\ufe0f </h4>\r\n\r\n* Added a swap based transpiler transform.  [(#2118)](https://github.com/PennyLaneAI/pennylane/pull/2118)\r\n\r\n  The transpile function takes a quantum function and a coupling map as inputs and compiles the circuit to ensure that it can be executed on corresponding hardware. The transform can be used as a decorator in the following way:\r\n\r\n  ```python\r\n  dev = qml.device('default.qubit', wires=4)\r\n\r\n  @qml.qnode(dev)\r\n  @qml.transforms.transpile(coupling_map=[(0, 1), (1, 2), (2, 3)])\r\n  def circuit(param):\r\n      qml.CNOT(wires=[0, 1])\r\n      qml.CNOT(wires=[0, 2])\r\n      qml.CNOT(wires=[0, 3])\r\n      qml.PhaseShift(param, wires=0)\r\n      return qml.probs(wires=[0, 1, 2, 3])\r\n  ```\r\n  ```pycon\r\n  >>> print(qml.draw(circuit)(0.3))\r\n  0: \u2500\u256dC\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256dC\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256dC\u2500\u2500R\u03d5(0.30)\u2500\u2524 \u256dProbs\r\n  1: \u2500\u2570X\u2500\u256dSWAP\u2500\u2570X\u2500\u2500\u2500\u2500\u256dSWAP\u2500\u2570X\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u251cProbs\r\n  2: \u2500\u2500\u2500\u2500\u2570SWAP\u2500\u256dSWAP\u2500\u2570SWAP\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u251cProbs\r\n  3: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2570SWAP\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2570Probs\r\n  ```\r\n\r\n<h3>Improvements</h3>\r\n\r\n* `QuantumTape` objects are now iterable, allowing iteration over the contained operations and measurements.  [(#2342)](https://github.com/PennyLaneAI/pennylane/pull/2342)\r\n\r\n  ```python\r\n  with qml.tape.QuantumTape() as tape:\r\n      qml.RX(0.432, wires=0)\r\n      qml.RY(0.543, wires=0)\r\n      qml.CNOT(wires=[0, 'a'])\r\n      qml.RX(0.133, wires='a')\r\n      qml.expval(qml.PauliZ(wires=[0]))\r\n  ```\r\n\r\n  Given a `QuantumTape` object the underlying quantum circuit can be iterated over using a `for` loop:\r\n\r\n  ```pycon\r\n  >>> for op in tape:\r\n  ...     print(op)\r\n  RX(0.432, wires=[0])\r\n  RY(0.543, wires=[0])\r\n  CNOT(wires=[0, 'a'])\r\n  RX(0.133, wires=['a'])\r\n  expval(PauliZ(wires=[0]))\r\n  ```\r\n\r\n  Indexing into the circuit is also allowed via `tape[i]`:\r\n\r\n  ```pycon\r\n  >>> tape[0]\r\n  RX(0.432, wires=[0])\r\n  ```\r\n\r\n  A tape object can also be converted to a sequence (e.g., to a `list`) of operations and measurements:\r\n\r\n  ```pycon\r\n  >>> list(tape)\r\n  [RX(0.432, wires=[0]),\r\n   RY(0.543, wires=[0]),\r\n   CNOT(wires=[0, 'a']),\r\n   RX(0.133, wires=['a']),\r\n   expval(PauliZ(wires=[0]))]\r\n  ```\r\n\r\n* Added the `QuantumTape.shape` method and `QuantumTape.numeric_type` attribute to allow extracting information about the shape and numeric type of the output returned by a quantum tape after execution.  [(#2044)](https://github.com/PennyLaneAI/pennylane/pull/2044)\r\n\r\n  ```python\r\n  dev = qml.device(\"default.qubit\", wires=2)\r\n  a = np.array([0.1, 0.2, 0.3])\r\n\r\n  def func(a):\r\n      qml.RY(a[0], wires=0)\r\n      qml.RX(a[1], wires=0)\r\n      qml.RY(a[2], wires=0)\r\n\r\n  with qml.tape.QuantumTape() as tape:\r\n      func(a)\r\n      qml.state()\r\n  ```\r\n  ```pycon\r\n  >>> tape.shape(dev)\r\n  (1, 4)\r\n  >>> tape.numeric_type\r\n  complex\r\n  ```\r\n\r\n* Defined a `MeasurementProcess.shape` method and a `MeasurementProcess.numeric_type` attribute to allow extracting information about the shape and numeric type of results obtained when evaluating QNodes using the specific measurement process.  [(#2044)](https://github.com/PennyLaneAI/pennylane/pull/2044)\r\n\r\n* The parameter-shift Hessian can now be computed for arbitrary operations that support the general parameter-shift rule for gradients, using `qml.gradients.param_shift_hessian` [(#2319)](https://github.com/XanaduAI/pennylane/pull/2319)\r\n\r\n  Multiple ways to obtain the gradient recipe are supported, in the following order of preference:\r\n\r\n  - A custom `grad_recipe`. It is iterated to obtain the shift rule for the second-order derivatives in the diagonal entries of the Hessian.\r\n\r\n  - Custom `parameter_frequencies`. The second-order shift rule can directly be computed using them.\r\n\r\n  - An operation's `generator`. Its eigenvalues will be used to obtain `parameter_frequencies`, if they are not given explicitly for an operation.\r\n\r\n* The strategy for expanding a circuit can now be specified with the `qml.specs` transform, for example to calculate the specifications of the\r\n  circuit that will actually be executed by the device (`expansion_strategy=\"device\"`).  [(#2395)](https://github.com/PennyLaneAI/pennylane/pull/2395)\r\n\r\n* The `default.qubit` and `default.mixed` devices now skip over identity operators instead of performing matrix multiplication with the identity.  [(#2356)](https://github.com/PennyLaneAI/pennylane/pull/2356) [(#2365)](https://github.com/PennyLaneAI/pennylane/pull/2365)\r\n\r\n* The function `qml.eigvals` is modified to use the efficient `scipy.sparse.linalg.eigsh` method for obtaining the eigenvalues of a `SparseHamiltonian`. This `scipy` method is called to compute :math:`k` eigenvalues of a sparse :math:`N \\times N` matrix if `k` is smaller than :math:`N-1`. If a larger :math:`k` is requested, the dense matrix representation of the Hamiltonian is constructed and the regular `qml.math.linalg.eigvalsh` is applied.  [(#2333)](https://github.com/PennyLaneAI/pennylane/pull/2333)\r\n\r\n* The function `qml.ctrl` was given the optional argument `control_values=None`.  If overridden, `control_values` takes an integer or a list of integers corresponding to the binary value that each control value should take. The same change is reflected in `ControlledOperation`. Control values of `0` are implemented by `qml.PauliX` applied before and after the controlled operation [(#2288)](https://github.com/PennyLaneAI/pennylane/pull/2288)\r\n\r\n* Operators now have a `has_matrix` property denoting whether or not the operator defines a matrix.  [(#2331)](https://github.com/PennyLaneAI/pennylane/pull/2331) [(#2476)](https://github.com/PennyLaneAI/pennylane/pull/2476)\r\n\r\n* Circuit cutting now performs expansion to search for wire cuts in contained operations or tapes.  [(#2340)](https://github.com/PennyLaneAI/pennylane/pull/2340)\r\n\r\n* The `qml.draw` and `qml.draw_mpl` transforms are now located in the `drawer` module. They can still be accessed via the top-level `qml` namespace.  [(#2396)](https://github.com/PennyLaneAI/pennylane/pull/2396)\r\n\r\n* Raise a warning where caching produces identical shot noise on execution results with finite shots.  [(#2478)](https://github.com/PennyLaneAI/pennylane/pull/2478)\r\n\r\n<h3>Deprecations</h3>\r\n\r\n* The `ObservableReturnTypes` `Sample`, `Variance`, `Expectation`, `Probability`, `State`, and `MidMeasure` have been moved to `measurements` from `operation`.  [(#2329)](https://github.com/PennyLaneAI/pennylane/pull/2329) [(#2481)](https://github.com/PennyLaneAI/pennylane/pull/2481) \r\n\r\n<h3>Breaking changes</h3>\r\n\r\n* The caching ability of devices has been removed. Using the caching on the QNode level is the recommended alternative going forward.  [(#2443)](https://github.com/PennyLaneAI/pennylane/pull/2443)\r\n\r\n  One way for replicating the removed `QubitDevice` caching behaviour is by creating a `cache` object (e.g., a dictionary) and passing it to the `QNode`:\r\n  ```python\r\n  n_wires = 4\r\n  wires = range(n_wires)\r\n\r\n  dev = qml.device('default.qubit', wires=n_wires)\r\n\r\n  cache = {}\r\n\r\n  @qml.qnode(dev, diff_method='parameter-shift', cache=cache)\r\n  def expval_circuit(params):\r\n      qml.templates.BasicEntanglerLayers(params, wires=wires, rotation=qml.RX)\r\n      return qml.expval(qml.PauliZ(0) @ qml.PauliY(1) @ qml.PauliX(2) @ qml.PauliZ(3))\r\n\r\n  shape = qml.templates.BasicEntanglerLayers.shape(5, n_wires)\r\n  params = np.random.random(shape)\r\n  ```\r\n  ```pycon\r\n  >>> expval_circuit(params)\r\n  tensor(0.20598436, requires_grad=True)\r\n  >>> dev.num_executions\r\n  1\r\n  >>> expval_circuit(params)\r\n  tensor(0.20598436, requires_grad=True)\r\n  >>> dev.num_executions\r\n  1\r\n  ```\r\n\r\n* The `qml.finite_diff` function has been removed. Please use `qml.gradients.finite_diff` to compute the gradient of tapes of QNodes. Otherwise, manual implementation is required.  [(#2464)](https://github.com/PennyLaneAI/pennylane/pull/2464)\r\n\r\n* The `get_unitary_matrix` transform has been removed, please use `qml.matrix` instead.  [(#2457)](https://github.com/PennyLaneAI/pennylane/pull/2457)\r\n\r\n* The `update_stepsize` method has been removed from `GradientDescentOptimizer` and its child optimizers.  The `stepsize` property can be interacted with directly instead.  [(#2370)](https://github.com/PennyLaneAI/pennylane/pull/2370)\r\n\r\n* Most optimizers no longer flatten and unflatten arguments during computation. Due to this change, user provided gradient functions *must* return the same shape as `qml.grad`.  [(#2381)](https://github.com/PennyLaneAI/pennylane/pull/2381)\r\n\r\n* The old circuit text drawing infrastructure has been removed.  [(#2310)](https://github.com/PennyLaneAI/pennylane/pull/2310)\r\n\r\n  - `RepresentationResolver` was replaced by the `Operator.label` method.\r\n  - `qml.drawer.CircuitDrawer` was replaced by `qml.drawer.tape_text`.\r\n  - `qml.drawer.CHARSETS` was removed because unicode is assumed to be accessible.\r\n  - `Grid` and `qml.drawer.drawable_grid` were removed because the custom data class was replaced by list of sets of operators or measurements.\r\n  - `qml.transforms.draw_old` was replaced by `qml.draw`.\r\n  - `qml.CircuitGraph.greedy_layers` was deleted, as it was no longer needed by the circuit drawer and did not seem to have uses outside of that situation.\r\n  - `qml.CircuitGraph.draw` was deleted, as we draw tapes instead.\r\n  - The tape method `qml.tape.QuantumTape.draw` now simply calls `qml.drawer.tape_text`.\r\n  - In the new pathway, the `charset` keyword was deleted, the `max_length` keyword defaults to `100`, and the `decimals` and `show_matrices` keywords were added.\r\n\r\n* The deprecated QNode, available via `qml.qnode_old.QNode`, has been removed. Please transition to using the standard `qml.QNode`.  [(#2336)](https://github.com/PennyLaneAI/pennylane/pull/2336) [(#2337)](https://github.com/PennyLaneAI/pennylane/pull/2337) [(#2338)](https://github.com/PennyLaneAI/pennylane/pull/2338)\r\n\r\n  In addition, several other components which powered the deprecated QNode have been removed:\r\n\r\n  - The deprecated, non-batch compatible interfaces, have been removed.\r\n\r\n  - The deprecated tape subclasses `QubitParamShiftTape`, `JacobianTape`, `CVParamShiftTape`, and `ReversibleTape` have been removed.\r\n\r\n* The deprecated tape execution method `tape.execute(device)` has been removed. Please use `qml.execute([tape], device)` instead.  [(#2339)](https://github.com/PennyLaneAI/pennylane/pull/2339)\r\n\r\n<h3>Bug fixes</h3>\r\n\r\n* Fixed a bug in the `qml.PauliRot` operation, where computing the generator was not taking into account the operation wires.  [(#2466)](https://github.com/PennyLaneAI/pennylane/pull/2466)\r\n\r\n* Fixed a bug where non-trainable arguments were shifted in the `NesterovMomentumOptimizer` if a trainable argument was after it in the argument list.  [(#2466)](https://github.com/PennyLaneAI/pennylane/pull/2466)\r\n\r\n* Fixed a bug with `@jax.jit` for grad when `diff_method=\"adjoint\"` and `mode=\"backward\"`.  [(#2460)](https://github.com/PennyLaneAI/pennylane/pull/2460)\r\n\r\n* Fixed a bug where `qml.DiagonalQubitUnitary` did not support `@jax.jit` and `@tf.function`.  [(#2445)](https://github.com/PennyLaneAI/pennylane/pull/2445)\r\n\r\n* Fixed a bug in the `qml.PauliRot` operation, where computing the generator was not taking into account the operation wires.  [(#2442)](https://github.com/PennyLaneAI/pennylane/pull/2442)\r\n\r\n* Fixed a bug with the padding capability of `AmplitudeEmbedding` where the inputs are on the GPU.  [(#2431)](https://github.com/PennyLaneAI/pennylane/pull/2431)\r\n\r\n* Fixed a bug by adding a comprehensible error message for calling `qml.probs` without passing wires or an observable.  [(#2438)](https://github.com/PennyLaneAI/pennylane/pull/2438)\r\n\r\n* The behaviour of `qml.about()` was modified to avoid warnings being emitted due to legacy behaviour of `pip`.  [(#2422)](https://github.com/PennyLaneAI/pennylane/pull/2422)\r\n\r\n* Fixed a bug where observables were not considered when determining the use of the `jax-jit` interface.  [(#2427)](https://github.com/PennyLaneAI/pennylane/pull/2427) [(#2474)](https://github.com/PennyLaneAI/pennylane/pull/2474)\r\n\r\n* Fixed a bug where computing statistics for a relatively few number of shots (e.g., `shots=10`), an error arose due to indexing into an array using a `DeviceArray`.  [(#2427)](https://github.com/PennyLaneAI/pennylane/pull/2427)\r\n\r\n* PennyLane Lightning version in Docker container is pulled from latest wheel-builds.  [(#2416)](https://github.com/PennyLaneAI/pennylane/pull/2416)\r\n\r\n* Optimizers only consider a variable trainable if they have `requires_grad = True`.  [(#2381)](https://github.com/PennyLaneAI/pennylane/pull/2381)\r\n\r\n* Fixed a bug with `qml.expval`, `qml.var`, `qml.state` and `qml.probs` (when `qml.probs` is the only measurement) where the `dtype` specified on the device did not match the `dtype` of the QNode output.  [(#2367)](https://github.com/PennyLaneAI/pennylane/pull/2367)\r\n\r\n* Fixed a bug where the output shapes from batch transforms are inconsistent with the QNode output shape.  [(#2215)](https://github.com/PennyLaneAI/pennylane/pull/2215)\r\n\r\n* Fixed a bug caused by the squeezing in `qml.gradients.param_shift_hessian`.  [(#2215)](https://github.com/PennyLaneAI/pennylane/pull/2215)\r\n\r\n* Fixed a bug in which the `expval`/`var` of a `Tensor(Observable)` would depend on the order in which the observable is defined: [(#2276)](https://github.com/PennyLaneAI/pennylane/pull/2276)\r\n  ```pycon\r\n  >>> @qml.qnode(dev)\r\n  ... def circ(op):\r\n  ...   qml.RX(0.12, wires=0)\r\n  ...   qml.RX(1.34, wires=1)\r\n  ...   qml.RX(3.67, wires=2)\r\n  ...   return qml.expval(op)\r\n  >>> op1 = qml.Identity(wires=0) @ qml.Identity(wires=1) @ qml.PauliZ(wires=2)\r\n  >>> op2 = qml.PauliZ(wires=2) @ qml.Identity(wires=0) @ qml.Identity(wires=1)\r\n  >>> print(circ(op1), circ(op2))\r\n  -0.8636111153905662 -0.8636111153905662\r\n  ```\r\n\r\n* Fixed a bug where `qml.hf.transform_hf()` would fail due to missing wires in the qubit operator that is prepared for tapering the HF state.  [(#2441)](https://github.com/PennyLaneAI/pennylane/pull/2441)\r\n\r\n* Fixed a bug with custom device defined jacobians not being returned properly.  [(#2485)](https://github.com/PennyLaneAI/pennylane/pull/2485)\r\n\r\n<h3>Documentation</h3>\r\n\r\n* The sections on adding operator and observable support in the \"How to add a plugin\" section of the plugins page have been updated.  [(#2389)](https://github.com/PennyLaneAI/pennylane/pull/2389)\r\n\r\n* The missing arXiv reference in the `LieAlgebra` optimizer has been fixed.  [(#2325)](https://github.com/PennyLaneAI/pennylane/pull/2325)\r\n\r\n<h3>Contributors</h3>\r\n\r\nThis release contains contributions from (in alphabetical order):\r\n\r\nKarim Alaa El-Din, Guillermo Alonso-Linaje, Juan Miguel Arrazola, Ali Asadi, Utkarsh Azad, Sam Banning, Thomas Bromley, Alain Delgado, Isaac De Vlugt, Olivia Di Matteo, Amintor Dusko, Anthony Hayes, David Ittah, Josh Izaac, Soran Jahangiri, Nathan Killoran, Christina Lee, Angus Lowe, Romain Moyard, Zeyue Niu, Matthew Silverman, Lee James O'Riordan, Maria Schuld, Jay Soni, Antal Sz\u00e1va, Maurice Weber, David Wierichs."}
{"url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/63312405", "assets_url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/63312405/assets", "upload_url": "https://uploads.github.com/repos/PennyLaneAI/pennylane/releases/63312405/assets{?name,label}", "html_url": "https://github.com/PennyLaneAI/pennylane/releases/tag/v0.22.2", "id": 63312405, "author": {"login": "antalszava", "id": 24476053, "node_id": "MDQ6VXNlcjI0NDc2MDUz", "avatar_url": "https://avatars.githubusercontent.com/u/24476053?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antalszava", "html_url": "https://github.com/antalszava", "followers_url": "https://api.github.com/users/antalszava/followers", "following_url": "https://api.github.com/users/antalszava/following{/other_user}", "gists_url": "https://api.github.com/users/antalszava/gists{/gist_id}", "starred_url": "https://api.github.com/users/antalszava/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antalszava/subscriptions", "organizations_url": "https://api.github.com/users/antalszava/orgs", "repos_url": "https://api.github.com/users/antalszava/repos", "events_url": "https://api.github.com/users/antalszava/events{/privacy}", "received_events_url": "https://api.github.com/users/antalszava/received_events", "type": "User", "site_admin": false}, "node_id": "RE_kwDOB76r6M4DxhIV", "tag_name": "v0.22.2", "target_commitish": "v0.22.2-rc0", "name": "Release 0.22.2", "draft": false, "prerelease": false, "created_at": "2022-03-31T20:52:22Z", "published_at": "2022-04-01T17:48:57Z", "assets": [], "tarball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/tarball/v0.22.2", "zipball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/zipball/v0.22.2", "body": "<h3>Bug fixes</h3>\r\n\r\n* Most compilation transforms, and relevant subroutines, have been updated to support just-in-time compilation with `jax.jit`. This fix was intended to be included in `v0.22.0`, but due to a bug was incomplete. [(#2397)](https://github.com/PennyLaneAI/pennylane/pull/2397)\r\n\r\n<h3>Documentation</h3>\r\n\r\n* The documentation run has been updated to require `jinja2==3.0.3` due to an issue that arises with `jinja2` `v3.1.0` and `sphinx` `v3.5.3`. [(#2378)](https://github.com/PennyLaneAI/pennylane/pull/2378)\r\n\r\n<h3>Contributors</h3>\r\n\r\nThis release contains contributions from (in alphabetical order):\r\n\r\nOlivia Di Matteo, Christina Lee, Romain Moyard, Antal Sz\u00e1va."}
{"url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/61950072", "assets_url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/61950072/assets", "upload_url": "https://uploads.github.com/repos/PennyLaneAI/pennylane/releases/61950072/assets{?name,label}", "html_url": "https://github.com/PennyLaneAI/pennylane/releases/tag/v0.22.1", "id": 61950072, "author": {"login": "antalszava", "id": 24476053, "node_id": "MDQ6VXNlcjI0NDc2MDUz", "avatar_url": "https://avatars.githubusercontent.com/u/24476053?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antalszava", "html_url": "https://github.com/antalszava", "followers_url": "https://api.github.com/users/antalszava/followers", "following_url": "https://api.github.com/users/antalszava/following{/other_user}", "gists_url": "https://api.github.com/users/antalszava/gists{/gist_id}", "starred_url": "https://api.github.com/users/antalszava/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antalszava/subscriptions", "organizations_url": "https://api.github.com/users/antalszava/orgs", "repos_url": "https://api.github.com/users/antalszava/repos", "events_url": "https://api.github.com/users/antalszava/events{/privacy}", "received_events_url": "https://api.github.com/users/antalszava/received_events", "type": "User", "site_admin": false}, "node_id": "RE_kwDOB76r6M4DsUh4", "tag_name": "v0.22.1", "target_commitish": "v0.22.1-rc0", "name": "Release 0.22.1", "draft": false, "prerelease": false, "created_at": "2022-03-16T01:39:23Z", "published_at": "2022-03-16T02:44:40Z", "assets": [], "tarball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/tarball/v0.22.1", "zipball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/zipball/v0.22.1", "body": "<h3>Bug fixes</h3>\r\n\r\n* Fixes cases with `qml.measure` where unexpected operations were added to the circuit.  [(#2328)](https://github.com/PennyLaneAI/pennylane/pull/2328)\r\n\r\n<h3>Contributors</h3>\r\n\r\nThis release contains contributions from (in alphabetical order):\r\n\r\nGuillermo Alonso-Linaje, Antal Sz\u00e1va."}
{"url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/61827364", "assets_url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/61827364/assets", "upload_url": "https://uploads.github.com/repos/PennyLaneAI/pennylane/releases/61827364/assets{?name,label}", "html_url": "https://github.com/PennyLaneAI/pennylane/releases/tag/v0.22.0", "id": 61827364, "author": {"login": "antalszava", "id": 24476053, "node_id": "MDQ6VXNlcjI0NDc2MDUz", "avatar_url": "https://avatars.githubusercontent.com/u/24476053?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antalszava", "html_url": "https://github.com/antalszava", "followers_url": "https://api.github.com/users/antalszava/followers", "following_url": "https://api.github.com/users/antalszava/following{/other_user}", "gists_url": "https://api.github.com/users/antalszava/gists{/gist_id}", "starred_url": "https://api.github.com/users/antalszava/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antalszava/subscriptions", "organizations_url": "https://api.github.com/users/antalszava/orgs", "repos_url": "https://api.github.com/users/antalszava/repos", "events_url": "https://api.github.com/users/antalszava/events{/privacy}", "received_events_url": "https://api.github.com/users/antalszava/received_events", "type": "User", "site_admin": false}, "node_id": "RE_kwDOB76r6M4Dr2kk", "tag_name": "v0.22.0", "target_commitish": "v0.22.0-rc0", "name": "Release 0.22.0", "draft": false, "prerelease": false, "created_at": "2022-03-15T06:11:44Z", "published_at": "2022-03-15T06:13:25Z", "assets": [], "tarball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/tarball/v0.22.0", "zipball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/zipball/v0.22.0", "body": "<h3>New features since last release</h3>\r\n\r\n<h4>Quantum circuit cutting \u2702\ufe0f</h4>\r\n\r\n* You can now run `N`-wire circuits on devices with fewer than `N` wires, by strategically placing `WireCut` operations that allow their circuit to be partitioned into smaller fragments, at a cost of needing to perform a greater number of device executions. Circuit cutting is enabled by decorating a QNode with the `@qml.cut_circuit` transform. [(#2107)](https://github.com/PennyLaneAI/pennylane/pull/2107) [(#2124)](https://github.com/PennyLaneAI/pennylane/pull/2124) [(#2153)](https://github.com/PennyLaneAI/pennylane/pull/2153) [(#2165)](https://github.com/PennyLaneAI/pennylane/pull/2165) [(#2158)](https://github.com/PennyLaneAI/pennylane/pull/2158) [(#2169)](https://github.com/PennyLaneAI/pennylane/pull/2169) [(#2192)](https://github.com/PennyLaneAI/pennylane/pull/2192) [(#2216)](https://github.com/PennyLaneAI/pennylane/pull/2216) [(#2168)](https://github.com/PennyLaneAI/pennylane/pull/2168) [(#2223)](https://github.com/PennyLaneAI/pennylane/pull/2223) [(#2231)](https://github.com/PennyLaneAI/pennylane/pull/2231) [(#2234)](https://github.com/PennyLaneAI/pennylane/pull/2234) [(#2244)](https://github.com/PennyLaneAI/pennylane/pull/2244) [(#2251)](https://github.com/PennyLaneAI/pennylane/pull/2251) [(#2265)](https://github.com/PennyLaneAI/pennylane/pull/2265) [(#2254)](https://github.com/PennyLaneAI/pennylane/pull/2254) [(#2260)](https://github.com/PennyLaneAI/pennylane/pull/2260) [(#2257)](https://github.com/PennyLaneAI/pennylane/pull/2257) [(#2279)](https://github.com/PennyLaneAI/pennylane/pull/2279)\r\n\r\n  The example below shows how a three-wire circuit can be run on a two-wire device:\r\n\r\n  ```python\r\n  dev = qml.device(\"default.qubit\", wires=2)\r\n\r\n  @qml.cut_circuit\r\n  @qml.qnode(dev)\r\n  def circuit(x):\r\n      qml.RX(x, wires=0)\r\n      qml.RY(0.9, wires=1)\r\n      qml.RX(0.3, wires=2)\r\n\r\n      qml.CZ(wires=[0, 1])\r\n      qml.RY(-0.4, wires=0)\r\n\r\n      qml.WireCut(wires=1)\r\n\r\n      qml.CZ(wires=[1, 2])\r\n\r\n      return qml.expval(qml.grouping.string_to_pauli_word(\"ZZZ\"))\r\n  ```\r\n\r\n  Instead of executing the circuit directly, it will be partitioned into smaller fragments according to the `WireCut` locations, and each fragment executed multiple times. Combining the results of the fragment executions will recover the expected output of the original uncut circuit.\r\n\r\n    ```pycon\r\n  >>> x = np.array(0.531, requires_grad=True)\r\n  >>> circuit(0.531)\r\n  0.47165198882111165\r\n  ```\r\n\r\n  Circuit cutting support is also differentiable:\r\n\r\n  ```pycon\r\n  >>> qml.grad(circuit)(x)\r\n  -0.276982865449393\r\n  ```\r\n\r\n  For more details on circuit cutting, check out the [qml.cut_circuit](https://pennylane.readthedocs.io/en/latest/code/api/pennylane.cut_circuit.html) documentation page or [Peng et. al](https://arxiv.org/abs/1904.00102).\r\n\r\n<h4>Conditional operations: quantum teleportation unlocked \ud83d\udd13\ud83c\udf00</h4>\r\n\r\n* Support for mid-circuit measurements and conditional operations has been added, to enable use cases like quantum teleportation, quantum error correction and quantum error mitigation.  [(#2211)](https://github.com/PennyLaneAI/pennylane/pull/2211) [(#2236)](https://github.com/PennyLaneAI/pennylane/pull/2236) [(#2275)](https://github.com/PennyLaneAI/pennylane/pull/2275)\r\n\r\n  Two new functions have been added to support this capability:\r\n\r\n  - `qml.measure()` places mid-circuit measurements in the middle of a quantum function.\r\n\r\n  - `qml.cond()` allows operations and quantum functions to be conditioned on the result of a previous measurement.\r\n\r\n  For example, the code below shows how to teleport a qubit from wire 0 to wire 2:\r\n\r\n  ```python\r\n  dev = qml.device(\"default.qubit\", wires=3)\r\n  input_state = np.array([1, -1], requires_grad=False) / np.sqrt(2)\r\n\r\n  @qml.qnode(dev)\r\n  def teleport(state):\r\n      # Prepare input state\r\n      qml.QubitStateVector(state, wires=0)\r\n\r\n      # Prepare Bell state\r\n      qml.Hadamard(wires=1)\r\n      qml.CNOT(wires=[1, 2])\r\n\r\n      # Apply gates\r\n      qml.CNOT(wires=[0, 1])\r\n      qml.Hadamard(wires=0)\r\n\r\n      # Measure first two wires\r\n      m1 = qml.measure(0)\r\n      m2 = qml.measure(1)\r\n\r\n      # Condition final wire on results\r\n      qml.cond(m2 == 1, qml.PauliX)(wires=2)\r\n      qml.cond(m1 == 1, qml.PauliZ)(wires=2)\r\n\r\n      # Return state on final wire\r\n      return qml.density_matrix(wires=2)\r\n  ```\r\n\r\n  We can double-check that the qubit has been teleported by computing the overlap between the input state and the resulting state on wire 2:\r\n\r\n  ```pycon\r\n  >>> output_state = teleport(input_state)\r\n  >>> output_state\r\n  tensor([[ 0.5+0.j, -0.5+0.j],\r\n          [-0.5+0.j,  0.5+0.j]], requires_grad=True)\r\n  >>> input_state.conj() @ output_state @ input_state\r\n  tensor(1.+0.j, requires_grad=True)\r\n  ```\r\n\r\n  For a full description of new capabilities, refer to the [Mid-circuit measurements and conditional operations](https://pennylane.readthedocs.io/en/latest/introduction/measurements.html#mid-circuit-measurements-and-conditional-operations) section in the documentation.\r\n\r\n* Train mid-circuit measurements by deferring them, via the new `@qml.defer_measurements` transform.  [(#2211)](https://github.com/PennyLaneAI/pennylane/pull/2211) [(#2236)](https://github.com/PennyLaneAI/pennylane/pull/2236) [(#2275)](https://github.com/PennyLaneAI/pennylane/pull/2275)\r\n\r\n  If a device doesn't natively support mid-circuit measurements, the `@qml.defer_measurements` transform can be applied to the QNode to transform the QNode into one with _terminal_ measurements and _controlled_ operations:\r\n\r\n  ```python\r\n  dev = qml.device(\"default.qubit\", wires=2)\r\n\r\n  @qml.qnode(dev)\r\n  @qml.defer_measurements\r\n  def circuit(x):\r\n      qml.Hadamard(wires=0)\r\n\r\n      m = qml.measure(0)\r\n\r\n      def op_if_true():\r\n          return qml.RX(x**2, wires=1)\r\n\r\n      def op_if_false():\r\n          return qml.RY(x, wires=1)\r\n\r\n      qml.cond(m==1, op_if_true, op_if_false)()\r\n\r\n      return qml.expval(qml.PauliZ(1))\r\n  ```\r\n\r\n  ```pycon\r\n  >>> x = np.array(0.7, requires_grad=True)\r\n  >>> print(qml.draw(circuit, expansion_strategy=\"device\")(x))\r\n  0: \u2500\u2500H\u2500\u256dC\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500X\u2500\u256dC\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500X\u2500\u2524\r\n  1: \u2500\u2500\u2500\u2500\u2570RX(0.49)\u2500\u2500\u2500\u2500\u2570RY(0.70)\u2500\u2500\u2500\u2500\u2524  <Z>\r\n  >>> circuit(x)\r\n  tensor(0.82358752, requires_grad=True)\r\n  ```\r\n\r\n  Deferring mid-circuit measurements also enables differentiation:\r\n\r\n  ```pycon\r\n  >>> qml.grad(circuit)(x)\r\n  -0.651546965338656\r\n  ```\r\n\r\n<h4>Debug with mid-circuit quantum snapshots \ud83d\udcf7</h4>\r\n\r\n* A new operation `qml.Snapshot` has been added to assist in debugging quantum functions.  [(#2233)](https://github.com/PennyLaneAI/pennylane/pull/2233) [(#2289)](https://github.com/PennyLaneAI/pennylane/pull/2289) [(#2291)](https://github.com/PennyLaneAI/pennylane/pull/2291) [(#2315)](https://github.com/PennyLaneAI/pennylane/pull/2315)\r\n\r\n  `qml.Snapshot` saves the internal state of devices at arbitrary points of execution.\r\n\r\n  Currently supported devices include:\r\n\r\n  - `default.qubit`: each snapshot saves the quantum state vector\r\n  - `default.mixed`: each snapshot saves the density matrix\r\n  - `default.gaussian`: each snapshot saves the covariance matrix and vector of means\r\n\r\n  During normal execution, the snapshots are ignored:\r\n\r\n  ```python\r\n  dev = qml.device(\"default.qubit\", wires=2)\r\n\r\n  @qml.qnode(dev, interface=None)\r\n  def circuit():\r\n      qml.Snapshot()\r\n      qml.Hadamard(wires=0)\r\n      qml.Snapshot(\"very_important_state\")\r\n      qml.CNOT(wires=[0, 1])\r\n      qml.Snapshot()\r\n      return qml.expval(qml.PauliX(0))\r\n  ```\r\n\r\n  However, when using the `qml.snapshots` transform, intermediate device states will be stored and returned alongside the results.\r\n\r\n  ```pycon\r\n  >>> qml.snapshots(circuit)()\r\n  {0: array([1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]),\r\n   'very_important_state': array([0.70710678+0.j, 0.        +0.j, 0.70710678+0.j, 0.        +0.j]),\r\n   2: array([0.70710678+0.j, 0.        +0.j, 0.        +0.j, 0.70710678+0.j]),\r\n   'execution_results': array(0.)}\r\n  ```\r\n\r\n<h4>Batch embedding and state preparation data \ud83d\udce6</h4>\r\n\r\n* Added the `@qml.batch_input` transform to enable batching non-trainable gate parameters.  In addition, the `qml.qnn.KerasLayer` class has been updated to natively support batched training data.  [(#2069)](https://github.com/PennyLaneAI/pennylane/pull/2069)\r\n\r\n  As with other transforms, `@qml.batch_input` can be used to decorate QNodes:\r\n  ```python\r\n  dev = qml.device(\"default.qubit\", wires=2, shots=None)\r\n\r\n  @qml.batch_input(argnum=0)\r\n  @qml.qnode(dev, diff_method=\"parameter-shift\", interface=\"tf\")\r\n  def circuit(inputs, weights):\r\n      # add a batch dimension to the embedding data\r\n      qml.AngleEmbedding(inputs, wires=range(2), rotation=\"Y\")\r\n      qml.RY(weights[0], wires=0)\r\n      qml.RY(weights[1], wires=1)\r\n      return qml.expval(qml.PauliZ(1))\r\n  ```\r\n\r\n  Batched input parameters can then be passed during QNode evaluation:\r\n\r\n  ```pycon\r\n  >>> x = tf.random.uniform((10, 2), 0, 1)\r\n  >>> w = tf.random.uniform((2,), 0, 1)\r\n  >>> circuit(x, w)\r\n  <tf.Tensor: shape=(10,), dtype=float64, numpy=\r\n  array([0.46230079, 0.73971315, 0.95666004, 0.5355225 , 0.66180948,\r\n          0.44519553, 0.93874261, 0.9483197 , 0.78737918, 0.90866411])>\r\n  ```\r\n\r\n<h4>Even more mighty quantum transforms \ud83d\udc1b\u27a1\ud83e\udd8b</h4>\r\n\r\n* New functions and transforms of operators have been added:\r\n\r\n  - `qml.matrix()` for computing the matrix representation of one or more unitary operators.  [(#2241)](https://github.com/PennyLaneAI/pennylane/pull/2241)\r\n\r\n  - `qml.eigvals()` for computing the eigenvalues of one or more operators.  [(#2248)](https://github.com/PennyLaneAI/pennylane/pull/2248)\r\n\r\n  - `qml.generator()` for computing the generator of a single-parameter unitary operation.  [(#2256)](https://github.com/PennyLaneAI/pennylane/pull/2256)\r\n\r\n  All operator transforms can be used on instantiated operators,\r\n\r\n  ```pycon\r\n  >>> op = qml.RX(0.54, wires=0)\r\n  >>> qml.matrix(op)\r\n  [[0.9637709+0.j         0.       -0.26673144j]\r\n  [0.       -0.26673144j 0.9637709+0.j        ]]\r\n  ```\r\n\r\n  Operator transforms can also be used in a functional form:\r\n\r\n  ```pycon\r\n  >>> x = torch.tensor(0.6, requires_grad=True)\r\n  >>> matrix_fn = qml.matrix(qml.RX)\r\n  >>> matrix_fn(x, wires=[0])\r\n  tensor([[0.9553+0.0000j, 0.0000-0.2955j],\r\n          [0.0000-0.2955j, 0.9553+0.0000j]], grad_fn=<AddBackward0>)\r\n  ```\r\n\r\n  In its functional form, it is fully differentiable with respect to gate arguments:\r\n\r\n  ```pycon\r\n  >>> loss = torch.real(torch.trace(matrix_fn(x, wires=0)))\r\n  >>> loss.backward()\r\n  >>> x.grad\r\n  tensor(-0.2955)\r\n  ```\r\n\r\n  Some operator transform can also act on multiple operations, by passing quantum functions or tapes:\r\n\r\n  ```pycon\r\n  >>> def circuit(theta):\r\n  ...     qml.RX(theta, wires=1)\r\n  ...     qml.PauliZ(wires=0)\r\n  >>> qml.matrix(circuit)(np.pi / 4)\r\n  array([[ 0.92387953+0.j,  0.+0.j ,  0.-0.38268343j,  0.+0.j],\r\n  [ 0.+0.j,  -0.92387953+0.j,  0.+0.j,  0. +0.38268343j],\r\n  [ 0. -0.38268343j,  0.+0.j,  0.92387953+0.j,  0.+0.j],\r\n  [ 0.+0.j,  0.+0.38268343j,  0.+0.j,  -0.92387953+0.j]])\r\n  ```\r\n\r\n* A new transform has been added to construct the pairwise-commutation directed acyclic graph (DAG) representation of a quantum circuit.  [(#1712)](https://github.com/PennyLaneAI/pennylane/pull/1712)\r\n\r\n  In the DAG, each node represents a quantum operation, and edges represent non-commutation between two operations.\r\n\r\n  This transform takes into account that not all operations can be moved next to each other by pairwise commutation:\r\n\r\n  ```pycon\r\n  >>> def circuit(x, y, z):\r\n  ...     qml.RX(x, wires=0)\r\n  ...     qml.RX(y, wires=0)\r\n  ...     qml.CNOT(wires=[1, 2])\r\n  ...     qml.RY(y, wires=1)\r\n  ...     qml.Hadamard(wires=2)\r\n  ...     qml.CRZ(z, wires=[2, 0])\r\n  ...     qml.RY(-y, wires=1)\r\n  ...     return qml.expval(qml.PauliZ(0))\r\n  >>> dag_fn = qml.commutation_dag(circuit)\r\n  >>> dag = dag_fn(np.pi / 4, np.pi / 3, np.pi / 2)\r\n  ```\r\n\r\n  Nodes in the commutation DAG can be accessed via the `get_nodes()` method, returning a list of the  form `(ID, CommutationDAGNode)`:\r\n\r\n  ```pycon\r\n  >>> nodes = dag.get_nodes()\r\n  >>> nodes\r\n  NodeDataView({0: <pennylane.transforms.commutation_dag.CommutationDAGNode object at 0x7f461c4bb580>, ...}, data='node')\r\n  ```\r\n\r\n  Specific nodes in the commutation DAG can be accessed via the `get_node()` method:\r\n\r\n  ```\r\n  >>> second_node = dag.get_node(2)\r\n  >>> second_node\r\n  <pennylane.transforms.commutation_dag.CommutationDAGNode object at 0x136f8c4c0>\r\n  >>> second_node.op\r\n  CNOT(wires=[1, 2])\r\n  >>> second_node.successors\r\n  [3, 4, 5, 6]\r\n  >>> second_node.predecessors\r\n  []\r\n  ```\r\n\r\n<h3>Improvements</h3>\r\n\r\n* The text-based drawer accessed via `qml.draw()` has been optimized and improved.  [(#2128)](https://github.com/PennyLaneAI/pennylane/pull/2128) [(#2198)](https://github.com/PennyLaneAI/pennylane/pull/2198)\r\n\r\n  The new drawer has:\r\n\r\n  * a `decimals` keyword for controlling parameter rounding\r\n  * a `show_matrices` keyword for controlling display of matrices\r\n  * a different algorithm for determining positions\r\n  * deprecation of the `charset` keyword\r\n  * additional minor cosmetic changes\r\n\r\n  ```python\r\n  @qml.qnode(qml.device('lightning.qubit', wires=2))\r\n  def circuit(a, w):\r\n      qml.Hadamard(0)\r\n      qml.CRX(a, wires=[0, 1])\r\n      qml.Rot(*w, wires=[1])\r\n      qml.CRX(-a, wires=[0, 1])\r\n      return qml.expval(qml.PauliZ(0) @ qml.PauliZ(1))\r\n  ```\r\n\r\n  ```pycon\r\n  >>> print(qml.draw(circuit, decimals=2)(a=2.3, w=[1.2, 3.2, 0.7]))\r\n  0: \u2500\u2500H\u2500\u256dC\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256dC\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u256d<Z@Z>\r\n  1: \u2500\u2500\u2500\u2500\u2570RX(2.30)\u2500\u2500Rot(1.20,3.20,0.70)\u2500\u2570RX(-2.30)\u2500\u2524 \u2570<Z@Z>\r\n  ```\r\n\r\n* The frequencies of gate parameters are now accessible as an operation property and can be used for circuit analysis, optimization via the `RotosolveOptimizer` and differentiation with the parameter-shift rule (including the general shift rule).  [(#2180)](https://github.com/PennyLaneAI/pennylane/pull/2180) [(#2182)](https://github.com/PennyLaneAI/pennylane/pull/2182) [(#2227)](https://github.com/PennyLaneAI/pennylane/pull/2227)\r\n\r\n  ```pycon\r\n  >>> op = qml.CRot(0.4, 0.1, 0.3, wires=[0, 1])\r\n  >>> op.parameter_frequencies\r\n  [(0.5, 1.0), (0.5, 1.0), (0.5, 1.0)]\r\n  ```\r\n\r\n  When using `qml.gradients.param_shift`, either a custom `grad_recipe` or the parameter frequencies are used to obtain the shift rule for the operation, in that order of preference.\r\n\r\n  See [Vidal and Theis (2018)](https://arxiv.org/abs/1812.06323) and [Wierichs et al. (2021)](https://arxiv.org/abs/2107.12390) for theoretical background information on the general parameter-shift rule.\r\n\r\n* No two-term parameter-shift rule is assumed anymore by default.  [(#2227)](https://github.com/PennyLaneAI/pennylane/pull/2227)\r\n\r\n  Previously, operations marked for analytic differentiation that did not provide a `generator`, `parameter_frequencies` or a custom `grad_recipe` were assumed to satisfy the two-term shift rule. This now has to be made explicit for custom operations by adding any of the above attributes.\r\n\r\n* Most compilation transforms, and relevant subroutines, have been updated to support just-in-time compilation with `jax.jit`.  [(#1894)](https://github.com/PennyLaneAI/pennylane/pull/1894/)\r\n\r\n* The `qml.draw_mpl` transform supports a `expansion_strategy` keyword argument.  [(#2271)](https://github.com/PennyLaneAI/pennylane/pull/2271/)\r\n\r\n* The `qml.gradients` module has been streamlined and special-purpose functions moved closer to their use cases, while preserving existing behaviour.  [(#2200)](https://github.com/PennyLaneAI/pennylane/pull/2200)\r\n\r\n* Added a new `partition_pauli_group` function to the `grouping` module for efficiently measuring the `N`-qubit Pauli group with `3 ** N` qubit-wise commuting terms.  [(#2185)](https://github.com/PennyLaneAI/pennylane/pull/2185)\r\n\r\n* The Operator class has undergone a major refactor with the following changes:\r\n\r\n  * **Matrices**: the static method `Operator.compute_matrices()` defines the matrix representation of the operator, and the function `qml.matrix(op)` computes this for a given instance.  [(#1996)](https://github.com/PennyLaneAI/pennylane/pull/1996)\r\n\r\n  * **Eigvals**: the static method `Operator.compute_eigvals()` defines the matrix representation of the operator, and the function `qml.eigvals(op)` computes this for a given instance.  [(#2048)](https://github.com/PennyLaneAI/pennylane/pull/2048)\r\n\r\n  * **Decompositions**: the static method `Operator.compute_decomposition()` defines the matrix representation of the operator, and the method `op.decomposition()` computes this for a given instance.  [(#2024)](https://github.com/PennyLaneAI/pennylane/pull/2024) [(#2053)](https://github.com/PennyLaneAI/pennylane/pull/2053)\r\n\r\n  * **Sparse matrices**: the static method `Operator.compute_sparse_matrix()` defines the sparse matrix representation of the operator, and the method `op.sparse_matrix()` computes this for a given instance.  [(#2050)](https://github.com/PennyLaneAI/pennylane/pull/2050)\r\n\r\n  * **Linear combinations of operators**: The static method `compute_terms()`, used for representing the linear combination of coefficients and operators representing the operator, has been added.  The method `op.terms()` computes this for a given instance.  Currently, only the `Hamiltonian` class overwrites `compute_terms()` to store coefficients and operators. The `Hamiltonian.terms` property hence becomes a proper method called by `Hamiltonian.terms()`.  [(#2036)](https://github.com/PennyLaneAI/pennylane/pull/2036)\r\n\r\n  * **Diagonalization**: The `diagonalizing_gates()` representation has been moved to the highest-level `Operator` class and is therefore available to all subclasses. A condition `qml.operation.defines_diagonalizing_gates` has been added, which can be used in tape contexts without queueing. In addition, a static `compute_diagonalizing_gates` method has been added, which is called by default in `diagonalizing_gates()`.  [(#1985)](https://github.com/PennyLaneAI/pennylane/pull/1985) [(#1993)](https://github.com/PennyLaneAI/pennylane/pull/1993)\r\n\r\n  * Error handling has been improved for Operator representations. Custom errors subclassing `OperatorPropertyUndefined` are raised if a representation has not been defined. This replaces the `NotImplementedError` and allows finer control for developers.  [(#2064)](https://github.com/PennyLaneAI/pennylane/pull/2064) [(#2287)](https://github.com/PennyLaneAI/pennylane/pull/2287/)\r\n\r\n  * A `Operator.hyperparameters` attribute, used for storing operation parameters that are *never* trainable, has been added to the operator class.  [(#2017)](https://github.com/PennyLaneAI/pennylane/pull/2017)\r\n\r\n  * The `string_for_inverse` attribute is removed.  [(#2021)](https://github.com/PennyLaneAI/pennylane/pull/2021)\r\n\r\n  * The `expand()` method was moved from the `Operation` class to the main `Operator` class.  [(#2053)](https://github.com/PennyLaneAI/pennylane/pull/2053) [(#2239)](https://github.com/PennyLaneAI/pennylane/pull/2239)\r\n\r\n<h3>Deprecations</h3>\r\n\r\n* There are several important changes when creating custom operations: [(#2214)](https://github.com/PennyLaneAI/pennylane/pull/2214) [(#2227)](https://github.com/PennyLaneAI/pennylane/pull/2227) [(#2030)](https://github.com/PennyLaneAI/pennylane/pull/2030) [(#2061)](https://github.com/PennyLaneAI/pennylane/pull/2061)\r\n\r\n  - The `Operator.matrix` method has been deprecated and `Operator.compute_matrix` should be defined instead. Operator matrices should be accessed using `qml.matrix(op)`.  If you were previously defining the class method `Operator._matrix()`, this is a a **breaking change** --- please update your operation to instead overwrite `Operator.compute_matrix`.\r\n\r\n  - The `Operator.decomposition` method has been deprecated and `Operator.compute_decomposition` should be defined instead. Operator decompositions should be accessed using `Operator.decomposition()`.\r\n\r\n  - The `Operator.eigvals` method has been deprecated and `Operator.compute_eigvals` should be defined instead. Operator eigenvalues should be accessed using `qml.eigvals(op)`.\r\n\r\n  - The `Operator.generator` property is now a method, and should return an *operator instance* representing the generator. Note that unlike the other representations above, this is a **breaking change**. Operator generators should be accessed using `qml.generator(op)`.\r\n\r\n  - The `Operation.get_parameter_shift` method has been deprecated and will be removed in a future release.\r\n\r\n    Instead, the functionalities for general parameter-shift rules in the `qml.gradients` module should be used, together with the operation attributes `parameter_frequencies` or `grad_recipe`.\r\n\r\n* Executing tapes using `tape.execute(dev)` is deprecated.  Please use the `qml.execute([tape], dev)` function instead.  [(#2306)](https://github.com/PennyLaneAI/pennylane/pull/2306)\r\n\r\n* The subclasses of the quantum tape, including `JacobianTape`, `QubitParamShiftTape`, `CVParamShiftTape`, and `ReversibleTape` are deprecated. Instead of calling `JacobianTape.jacobian()` and `JacobianTape.hessian()`, please use a standard `QuantumTape`, and apply gradient transforms using the `qml.gradients` module.  [(#2306)](https://github.com/PennyLaneAI/pennylane/pull/2306)\r\n\r\n* `qml.transforms.get_unitary_matrix()` has been deprecated and will be removed in a future release. For extracting matrices of operations and quantum functions, please use `qml.matrix()`.  [(#2248)](https://github.com/PennyLaneAI/pennylane/pull/2248)\r\n\r\n* The `qml.finite_diff()` function has been deprecated and will be removed in an upcoming release. Instead, `qml.gradients.finite_diff()` can be used to compute purely quantum gradients (that is, gradients of tapes or QNode).  [(#2212)](https://github.com/PennyLaneAI/pennylane/pull/2212)\r\n\r\n* The `MultiControlledX` operation now accepts a single `wires` keyword argument for both `control_wires` and `wires`.  The single `wires` keyword should be all the control wires followed by a single target wire.  [(#2121)](https://github.com/PennyLaneAI/pennylane/pull/2121) [(#2278)](https://github.com/PennyLaneAI/pennylane/pull/2278)\r\n\r\n<h3>Breaking changes</h3>\r\n\r\n* The representation of an operator as a matrix has been overhauled.  [(#1996)](https://github.com/PennyLaneAI/pennylane/pull/1996)\r\n\r\n  The \"canonical matrix\", which is independent of wires, is now defined in the static method `compute_matrix()` instead of `_matrix`.  By default, this method is assumed to take all parameters and non-trainable hyperparameters that define the operation.\r\n\r\n  ```pycon\r\n  >>> qml.RX.compute_matrix(0.5)\r\n  [[0.96891242+0.j         0.        -0.24740396j]\r\n   [0.        -0.24740396j 0.96891242+0.j        ]]\r\n  ```\r\n\r\n  If no canonical matrix is specified for a gate, `compute_matrix()` raises a `MatrixUndefinedError`.\r\n\r\n* The generator property has been updated to an instance method, `Operator.generator()`. It now returns an instantiated operation, representing the generator of the instantiated operator.  [(#2030)](https://github.com/PennyLaneAI/pennylane/pull/2030) [(#2061)](https://github.com/PennyLaneAI/pennylane/pull/2061)\r\n\r\n  Various operators have been updated to specify the generator as either an `Observable`, `Tensor`, `Hamiltonian`, `SparseHamiltonian`, or `Hermitian` operator.\r\n\r\n  In addition, `qml.generator(operation)` has been added to aid in retrieving generator representations of operators.\r\n\r\n* The argument `wires` in `heisenberg_obs`, `heisenberg_expand` and `heisenberg_tr` was renamed to `wire_order` to be consistent with other matrix representations.  [(#2051)](https://github.com/PennyLaneAI/pennylane/pull/2051)\r\n\r\n* The property `kraus_matrices` has been changed to a method, and `_kraus_matrices` renamed to `compute_kraus_matrices`, which is now a static method.  [(#2055)](https://github.com/PennyLaneAI/pennylane/pull/2055)\r\n\r\n* The `pennylane.measure` module has been renamed to `pennylane.measurements`.  [(#2236)](https://github.com/PennyLaneAI/pennylane/pull/2236)\r\n\r\n<h3>Bug fixes</h3>\r\n\r\n* The `basis` property of `qml.SWAP` was set to `\"X\"`, which is incorrect; it is now set to `None`.  [(#2287)](https://github.com/PennyLaneAI/pennylane/pull/2287/)\r\n\r\n* The `qml.RandomLayers` template now decomposes when the weights are a list of lists.  [(#2266)](https://github.com/PennyLaneAI/pennylane/pull/2266/)\r\n\r\n* The `qml.QubitUnitary` operation now supports just-in-time compilation using JAX.  [(#2249)](https://github.com/PennyLaneAI/pennylane/pull/2249)\r\n\r\n* Fixes a bug in the JAX interface where `DeviceArray` objects were not being converted to NumPy arrays before executing an external device.  [(#2255)](https://github.com/PennyLaneAI/pennylane/pull/2255)\r\n\r\n* The `qml.ctrl` transform now works correctly with gradient transforms such as the parameter-shift rule.  [(#2238)](https://github.com/PennyLaneAI/pennylane/pull/2238)\r\n\r\n* Fixes a bug in which passing required arguments into operations as keyword arguments would throw an error because the documented call signature didn't match the function definition.  [(#1976)](https://github.com/PennyLaneAI/pennylane/pull/1976)\r\n\r\n* The operation `OrbitalRotation` previously was wrongfully registered to satisfy the four-term parameter shift rule. The correct eight-term rule will now be used when using the parameter-shift rule.  [(#2180)](https://github.com/PennyLaneAI/pennylane/pull/2180)\r\n\r\n* Fixes a bug where `qml.gradients.param_shift_hessian` would produce an error whenever all elements of the Hessian are known in advance to be 0.  [(#2299)](https://github.com/PennyLaneAI/pennylane/pull/2299)\r\n\r\n<h3>Documentation</h3>\r\n\r\n* The developer guide on adding templates and the architecture overview were rewritten to reflect the past and planned changes of the operator refactor.  [(#2066)](https://github.com/PennyLaneAI/pennylane/pull/2066)\r\n\r\n* Links to the Strawberry Fields documentation for information on the CV model.  [(#2259)](https://github.com/PennyLaneAI/pennylane/pull/2259)\r\n\r\n* Fixes the documentation example for `qml.QFT`.  [(#2232)](https://github.com/PennyLaneAI/pennylane/pull/2232)\r\n\r\n* Fixes the documentation example for using `qml.sample` with `jax.jit`.  [(#2196)](https://github.com/PennyLaneAI/pennylane/pull/2196)\r\n\r\n* The `qml.numpy` subpackage is now included in the PennyLane API documentation.  [(#2179)](https://github.com/PennyLaneAI/pennylane/pull/2179)\r\n\r\n* Improves the documentation of `RotosolveOptimizer` regarding the usage of the passed `substep_optimizer` and its keyword arguments.  [(#2160)](https://github.com/PennyLaneAI/pennylane/pull/2160)\r\n\r\n* Ensures that signatures of `@qml.qfunc_transform` decorated functions display correctly in the docs.  [(#2286)](https://github.com/PennyLaneAI/pennylane/pull/2286)\r\n\r\n* Docstring examples now display using the updated text-based circuit drawer.  [(#2252)](https://github.com/PennyLaneAI/pennylane/pull/2252)\r\n\r\n* Add docstring to `OrbitalRotation.grad_recipe`.  [(#2193)](https://github.com/PennyLaneAI/pennylane/pull/2193)\r\n\r\n<h3>Contributors</h3>\r\n\r\nThis release contains contributions from (in alphabetical order):\r\n\r\nCatalina Albornoz, Jack Y. Araz, Juan Miguel Arrazola, Ali Asadi, Utkarsh Azad, Sam Banning, Thomas Bromley, Olivia Di Matteo, Christian Gogolin, Diego Guala, Anthony Hayes, David Ittah, Josh Izaac, Soran Jahangiri, Nathan Killoran, Christina Lee, Angus Lowe, Maria Fernanda Morris, Romain Moyard, Zeyue Niu, Lee James O'Riordan, Chae-Yeun Park, Maria Schuld, Jay Soni, Antal Sz\u00e1va, David Wierichs."}
{"url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/58951702", "assets_url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/58951702/assets", "upload_url": "https://uploads.github.com/repos/PennyLaneAI/pennylane/releases/58951702/assets{?name,label}", "html_url": "https://github.com/PennyLaneAI/pennylane/releases/tag/v0.21.0", "id": 58951702, "author": {"login": "antalszava", "id": 24476053, "node_id": "MDQ6VXNlcjI0NDc2MDUz", "avatar_url": "https://avatars.githubusercontent.com/u/24476053?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antalszava", "html_url": "https://github.com/antalszava", "followers_url": "https://api.github.com/users/antalszava/followers", "following_url": "https://api.github.com/users/antalszava/following{/other_user}", "gists_url": "https://api.github.com/users/antalszava/gists{/gist_id}", "starred_url": "https://api.github.com/users/antalszava/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antalszava/subscriptions", "organizations_url": "https://api.github.com/users/antalszava/orgs", "repos_url": "https://api.github.com/users/antalszava/repos", "events_url": "https://api.github.com/users/antalszava/events{/privacy}", "received_events_url": "https://api.github.com/users/antalszava/received_events", "type": "User", "site_admin": false}, "node_id": "RE_kwDOB76r6M4Dg4gW", "tag_name": "v0.21.0", "target_commitish": "v0.21.0-rc0", "name": "Release 0.21.0", "draft": false, "prerelease": false, "created_at": "2022-02-08T07:12:35Z", "published_at": "2022-02-08T07:13:57Z", "assets": [], "tarball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/tarball/v0.21.0", "zipball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/zipball/v0.21.0", "body": "<h3>New features since last release</h3>\r\n\r\n<h4>Reduce qubit requirements of simulating Hamiltonians \u269b\ufe0f</h4>\r\n\r\n* Functions for tapering qubits based on molecular symmetries have been added, following results from [Setia et al](https://arxiv.org/abs/1910.14644).  [(#1966)](https://github.com/PennyLaneAI/pennylane/pull/1966) [(#1974)](https://github.com/PennyLaneAI/pennylane/pull/1974) [(#2041)](https://github.com/PennyLaneAI/pennylane/pull/2041) [(#2042)](https://github.com/PennyLaneAI/pennylane/pull/2042)\r\n\r\n  With this functionality, a molecular Hamiltonian and the corresponding Hartree-Fock (HF) state can be transformed to a new Hamiltonian and HF state that acts on a reduced number of qubits, respectively.\r\n  ```python\r\n  # molecular geometry\r\n  symbols = [\"He\", \"H\"]\r\n  geometry = np.array([[0.0, 0.0, 0.0], [0.0, 0.0, 1.4588684632]])\r\n  mol = qml.hf.Molecule(symbols, geometry, charge=1)\r\n\r\n  # generate the qubit Hamiltonian\r\n  H = qml.hf.generate_hamiltonian(mol)(geometry)\r\n\r\n  # determine Hamiltonian symmetries\r\n  generators, paulix_ops = qml.hf.generate_symmetries(H, len(H.wires))\r\n  opt_sector = qml.hf.optimal_sector(H, generators, mol.n_electrons)\r\n\r\n  # taper the Hamiltonian\r\n  H_tapered = qml.hf.transform_hamiltonian(H, generators, paulix_ops, opt_sector)\r\n  ```\r\n\r\n  We can compare the number of qubits required by the original Hamiltonian and the tapered Hamiltonian:\r\n\r\n  ```pycon\r\n  >>> len(H.wires)\r\n  4\r\n  >>> len(H_tapered.wires)\r\n  2\r\n  ```\r\n\r\n  For quantum chemistry algorithms, the Hartree-Fock state can also be tapered:\r\n\r\n  ```python\r\n  n_elec = mol.n_electrons\r\n  n_qubits = mol.n_orbitals * 2\r\n\r\n  hf_tapered = qml.hf.transform_hf(\r\n      generators, paulix_ops, opt_sector, n_elec, n_qubits\r\n  )\r\n  ```\r\n  ```pycon\r\n  >>> hf_tapered\r\n  tensor([1, 1], requires_grad=True)\r\n  ```\r\n\r\n<h4>New tensor network templates \ud83e\udea2</h4>\r\n\r\n* Quantum circuits with the shape of a matrix product state tensor network can now be easily implemented using the new `qml.MPS` template, based on the work [arXiv:1803.11537](https://arxiv.org/abs/1803.11537).  [(#1871)](https://github.com/PennyLaneAI/pennylane/pull/1871)\r\n\r\n  ```python\r\n  def block(weights, wires):\r\n      qml.CNOT(wires=[wires[0], wires[1]])\r\n      qml.RY(weights[0], wires=wires[0])\r\n      qml.RY(weights[1], wires=wires[1])\r\n\r\n  n_wires = 4\r\n  n_block_wires = 2\r\n  n_params_block = 2\r\n  template_weights = np.array([[0.1, -0.3], [0.4, 0.2], [-0.15, 0.5]], requires_grad=True)\r\n\r\n  dev = qml.device(\"default.qubit\", wires=range(n_wires))\r\n\r\n  @qml.qnode(dev)\r\n  def circuit(weights):\r\n      qml.MPS(range(n_wires), n_block_wires, block, n_params_block, weights)\r\n      return qml.expval(qml.PauliZ(wires=n_wires - 1))\r\n  ```\r\n\r\n  The resulting circuit is:\r\n  ```pycon\r\n  >>> print(qml.draw(circuit, expansion_strategy=\"device\")(template_weights))\r\n  0: \u2500\u2500\u256dC\u2500\u2500RY(0.1)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n  1: \u2500\u2500\u2570X\u2500\u2500RY(-0.3)\u2500\u2500\u256dC\u2500\u2500RY(0.4)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n  2: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2570X\u2500\u2500RY(0.2)\u2500\u2500\u256dC\u2500\u2500RY(-0.15)\u2500\u2500\u2524\r\n  3: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2570X\u2500\u2500RY(0.5)\u2500\u2500\u2500\u2500\u2524 \u27e8Z\u27e9\r\n  ```\r\n\r\n* Added a template for tree tensor networks, `qml.TTN`.  [(#2043)](https://github.com/PennyLaneAI/pennylane/pull/2043)\r\n  ```python\r\n  def block(weights, wires):\r\n      qml.CNOT(wires=[wires[0], wires[1]])\r\n      qml.RY(weights[0], wires=wires[0])\r\n      qml.RY(weights[1], wires=wires[1])\r\n\r\n  n_wires = 4\r\n  n_block_wires = 2\r\n  n_params_block = 2\r\n  n_blocks = qml.MPS.get_n_blocks(range(n_wires), n_block_wires)\r\n  template_weights = [[0.1, -0.3]] * n_blocks\r\n\r\n  dev = qml.device(\"default.qubit\", wires=range(n_wires))\r\n\r\n  @qml.qnode(dev)\r\n  def circuit(template_weights):\r\n      qml.TTN(range(n_wires), n_block_wires, block, n_params_block, template_weights)\r\n      return qml.expval(qml.PauliZ(wires=n_wires - 1))\r\n  ```\r\n  The resulting circuit is:\r\n  ```pycon\r\n  >>> print(qml.draw(circuit, expansion_strategy=\"device\")(template_weights))\r\n  0: \u2500\u2500\u256dC\u2500\u2500RY(0.1)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n  1: \u2500\u2500\u2570X\u2500\u2500RY(-0.3)\u2500\u2500\u256dC\u2500\u2500RY(0.1)\u2500\u2500\u2500\u2524\r\n  2: \u2500\u2500\u256dC\u2500\u2500RY(0.1)\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n  3: \u2500\u2500\u2570X\u2500\u2500RY(-0.3)\u2500\u2500\u2570X\u2500\u2500RY(-0.3)\u2500\u2500\u2524 \u27e8Z\u27e9\r\n  ```\r\n\r\n<h4>Generalized RotosolveOptmizer \ud83d\udcc9</h4>\r\n\r\n* The `RotosolveOptimizer` has been generalized to arbitrary frequency spectra in the cost function. Also note the changes in behaviour listed under *Breaking changes*.  [(#2081)](https://github.com/PennyLaneAI/pennylane/pull/2081)\r\n\r\n  Previously, the RotosolveOptimizer only supported variational circuits using special gates such as single-qubit Pauli rotations. Now, circuits with arbitrary gates are supported natively without decomposition, as long as the frequencies of the gate parameters are known. This new generalization extends the Rotosolve optimization method to a larger class of circuits, and can reduce the cost of the optimization compared to decomposing all gates to single-qubit rotations.\r\n\r\n  Consider the QNode\r\n  ```python\r\n  dev = qml.device(\"default.qubit\", wires=2)\r\n\r\n  @qml.qnode(dev)\r\n  def qnode(x, Y):\r\n      qml.RX(2.5 * x, wires=0)\r\n      qml.CNOT(wires=[0, 1])\r\n      qml.RZ(0.3 * Y[0], wires=0)\r\n      qml.CRY(1.1 * Y[1], wires=[1, 0])\r\n      return qml.expval(qml.PauliX(0) @ qml.PauliZ(1))\r\n\r\n  x = np.array(0.8, requires_grad=True)\r\n  Y = np.array([-0.2, 1.5], requires_grad=True)\r\n  ```\r\n\r\n  Its frequency spectra can be easily obtained via `qml.fourier.qnode_spectrum`:\r\n  ```pycon\r\n  >>> spectra = qml.fourier.qnode_spectrum(qnode)(x, Y)\r\n  >>> spectra\r\n  {'x': {(): [-2.5, 0.0, 2.5]},\r\n   'Y': {(0,): [-0.3, 0.0, 0.3], (1,): [-1.1, -0.55, 0.0, 0.55, 1.1]}}\r\n  ```\r\n\r\n  We may then initialize the `RotosolveOptimizer` and minimize the QNode cost function by providing this information about the frequency spectra. We also compare the cost at each step to the initial cost.\r\n  ```pycon\r\n  >>> cost_init = qnode(x, Y)\r\n  >>> opt = qml.RotosolveOptimizer()\r\n  >>> for _ in range(2):\r\n  ...     x, Y = opt.step(qnode, x, Y, spectra=spectra)\r\n  ...     print(f\"New cost: {np.round(qnode(x, Y), 3)}; Initial cost: {np.round(cost_init, 3)}\")\r\n  New cost: 0.0; Initial cost: 0.706\r\n  New cost: -1.0; Initial cost: 0.706\r\n  ```\r\n\r\n  The optimization with `RotosolveOptimizer` is performed in substeps. The minimal cost of these substeps can be retrieved by setting `full_output=True`.\r\n  ```pycon\r\n  >>> x = np.array(0.8, requires_grad=True)\r\n  >>> Y = np.array([-0.2, 1.5], requires_grad=True)\r\n  >>> opt = qml.RotosolveOptimizer()\r\n  >>> for _ in range(2):\r\n  ...     (x, Y), history = opt.step(qnode, x, Y, spectra=spectra, full_output=True)\r\n  ...     print(f\"New cost: {np.round(qnode(x, Y), 3)} reached via substeps {np.round(history, 3)}\")\r\n  New cost: 0.0 reached via substeps [-0.  0.  0.]\r\n  New cost: -1.0 reached via substeps [-1. -1. -1.]\r\n  ```\r\n  However, note that these intermediate minimal values are evaluations of the *reconstructions* that Rotosolve creates and uses internally for the optimization, and not of the original objective function. For noisy cost functions, these intermediate evaluations may differ significantly from evaluations of the original cost function.\r\n\r\n<h4>Improved JAX support \ud83d\udcbb</h4>\r\n\r\n* The JAX interface now supports evaluating vector-valued QNodes.  [(#2110)](https://github.com/PennyLaneAI/pennylane/pull/2110)\r\n\r\n  Vector-valued QNodes include those with:\r\n  * `qml.probs`;\r\n  * `qml.state`;\r\n  * `qml.sample` or\r\n  * multiple `qml.expval` / `qml.var` measurements.\r\n\r\n  Consider a QNode that returns basis-state probabilities:\r\n  ```python\r\n  dev = qml.device('default.qubit', wires=2)\r\n  x = jnp.array(0.543)\r\n  y = jnp.array(-0.654)\r\n\r\n  @qml.qnode(dev, diff_method=\"parameter-shift\", interface=\"jax\")\r\n  def circuit(x, y):\r\n      qml.RX(x, wires=[0])\r\n      qml.RY(y, wires=[1])\r\n      qml.CNOT(wires=[0, 1])\r\n      return qml.probs(wires=[1])\r\n  ```\r\n  The QNode can be evaluated and its jacobian can be computed:\r\n  ```pycon\r\n  >>> circuit(x, y)\r\n  DeviceArray([0.8397495 , 0.16025047], dtype=float32)\r\n  >>> jax.jacobian(circuit, argnums=[0, 1])(x, y)\r\n  (DeviceArray([-0.2050439,  0.2050439], dtype=float32, weak_type=True),\r\n   DeviceArray([ 0.26043, -0.26043], dtype=float32, weak_type=True))\r\n  ```\r\n  Note that `jax.jit` is not yet supported for vector-valued QNodes.\r\n\r\n<h4>Speedier quantum natural gradient \u26a1</h4>\r\n\r\n* A new function for computing the metric tensor on simulators, `qml.adjoint_metric_tensor`, has been added, that uses classically efficient methods to massively improve performance.  [(#1992)](https://github.com/PennyLaneAI/pennylane/pull/1992)\r\n\r\n  This method, detailed in [Jones (2020)](https://arxiv.org/abs/2011.02991), computes the metric tensor using four copies of the state vector and a number of operations that scales quadratically in the number of trainable parameters.\r\n\r\n  Note that as it makes use of state cloning, it is inherently classical and can only be used with statevector simulators and `shots=None`.\r\n\r\n  It is particularly useful for larger circuits for which backpropagation requires inconvenient or even unfeasible amounts of storage, but is slower.  Furthermore, the adjoint method is only available for analytic computation, not for measurements simulation with `shots!=None`.\r\n\r\n  ```python\r\n  dev = qml.device(\"default.qubit\", wires=3)\r\n\r\n  @qml.qnode(dev)\r\n  def circuit(x, y):\r\n      qml.Rot(*x[0], wires=0)\r\n      qml.Rot(*x[1], wires=1)\r\n      qml.Rot(*x[2], wires=2)\r\n      qml.CNOT(wires=[0, 1])\r\n      qml.CNOT(wires=[1, 2])\r\n      qml.CNOT(wires=[2, 0])\r\n      qml.RY(y[0], wires=0)\r\n      qml.RY(y[1], wires=1)\r\n      qml.RY(y[0], wires=2)\r\n      return qml.expval(qml.PauliZ(0) @ qml.PauliZ(1)), qml.expval(qml.PauliY(1))\r\n\r\n  x = np.array([[0.2, 0.4, -0.1], [-2.1, 0.5, -0.2], [0.1, 0.7, -0.6]], requires_grad=False)\r\n  y = np.array([1.3, 0.2], requires_grad=True)\r\n  ```\r\n\r\n  ```pycon\r\n  >>> qml.adjoint_metric_tensor(circuit)(x, y)\r\n  tensor([[ 0.25495723, -0.07086695],\r\n          [-0.07086695,  0.24945606]], requires_grad=True)\r\n  ```\r\n\r\n  Computational cost\r\n\r\n  The adjoint method uses :math:`2P^2+4P+1` gates and state cloning operations if the circuit is composed only of trainable gates, where :math:`P` is the number of trainable operations.  If non-trainable gates are included, each of them is applied about :math:`n^2-n` times, where :math:`n` is the number of trainable operations that follow after the respective non-trainable operation in the circuit. This means that non-trainable gates later in the circuit are executed less often, making the adjoint method a bit cheaper if such gates appear later.  The adjoint method requires memory for 4 independent state vectors, which corresponds roughly\r\n  to storing a state vector of a system with 2 additional qubits.\r\n\r\n<h4>Compute the Hessian on hardware \u2b06\ufe0f</h4>\r\n\r\n* A new gradient transform `qml.gradients.param_shift_hessian` has been added to directly compute the Hessian (2nd order partial derivative matrix) of\r\n  QNodes on hardware.\r\n  [(#1884)](https://github.com/PennyLaneAI/pennylane/pull/1884)\r\n\r\n  The function generates parameter-shifted tapes which allow the Hessian to be computed analytically on hardware and software devices. Compared to using an auto-differentiation framework to compute the Hessian via parameter shifts, this function will use fewer device invocations and can be used to inspect the parameter-shifted \"Hessian tapes\" directly. The function remains fully differentiable on all supported PennyLane interfaces.\r\n\r\n  Additionally, the parameter-shift Hessian comes with a new batch transform decorator `@qml.gradients.hessian_transform`, which can be used to create custom Hessian functions.\r\n\r\n  The following code demonstrates how to use the parameter-shift Hessian:\r\n\r\n  ```python\r\n  dev = qml.device(\"default.qubit\", wires=2)\r\n\r\n  @qml.qnode(dev)\r\n  def circuit(x):\r\n      qml.RX(x[0], wires=0)\r\n      qml.RY(x[1], wires=0)\r\n      return qml.expval(qml.PauliZ(0))\r\n\r\n  x = np.array([0.1, 0.2], requires_grad=True)\r\n\r\n  hessian = qml.gradients.param_shift_hessian(circuit)(x)\r\n  ```\r\n  ```pycon\r\n  >>> hessian\r\n  tensor([[-0.97517033,  0.01983384],\r\n          [ 0.01983384, -0.97517033]], requires_grad=True)\r\n  ```\r\n\r\n<h3>Improvements</h3>\r\n\r\n* The `qml.transforms.insert` transform now supports adding operation after or before certain specific gates.  [(#1980)](https://github.com/PennyLaneAI/pennylane/pull/1980)\r\n\r\n* Added a modified version of the `simplify` function to the `hf` module.  [(#2103)](https://github.com/PennyLaneAI/pennylane/pull/2103)\r\n\r\n  This function combines redundant terms in a Hamiltonian and eliminates terms with a coefficient smaller than a cutoff value. The new function makes construction of molecular Hamiltonians more efficient. For LiH, as an example, the time to construct the Hamiltonian is reduced roughly by a factor of 20.\r\n\r\n* The QAOA module now accepts both NetworkX and RetworkX graphs as function inputs.  [(#1791)](https://github.com/PennyLaneAI/pennylane/pull/1791)\r\n\r\n* The `CircuitGraph`, used to represent circuits via directed acyclic graphs, now uses RetworkX for its internal representation. This results in significant speedup for algorithms that rely on a directed acyclic graph representation.  [(#1791)](https://github.com/PennyLaneAI/pennylane/pull/1791)\r\n\r\n* For subclasses of `Operator` where the number of parameters is known before instantiation, the `num_params` is reverted back to being a static property. This allows to programmatically know the number of parameters before an operator is instantiated without changing the user interface. A test was added to ensure that different ways of defining `num_params` work as expected.  [(#2101)](https://github.com/PennyLaneAI/pennylane/pull/2101) [(#2135)](https://github.com/PennyLaneAI/pennylane/pull/2135)\r\n\r\n* A `WireCut` operator has been added for manual wire cut placement when constructing a QNode.  [(#2093)](https://github.com/PennyLaneAI/pennylane/pull/2093)\r\n\r\n* The new function `qml.drawer.tape_text` produces a string drawing of a tape. This function differs in implementation and minor stylistic details from the old string circuit drawing infrastructure.  [(#1885)](https://github.com/PennyLaneAI/pennylane/pull/1885)\r\n\r\n* The `RotosolveOptimizer` now raises an error if no trainable arguments are detected, instead of silently skipping update steps for all arguments.  [(#2109)](https://github.com/PennyLaneAI/pennylane/pull/2109)\r\n\r\n* The function `qml.math.safe_squeeze` is introduced and `gradient_transform` allows for QNode argument axes of size `1`.  [(#2080)](https://github.com/PennyLaneAI/pennylane/pull/2080)\r\n\r\n  `qml.math.safe_squeeze` wraps `qml.math.squeeze`, with slight modifications:\r\n\r\n  - When provided the `axis` keyword argument, axes that do not have size `1` will be ignored, instead of raising an error.\r\n\r\n  - The keyword argument `exclude_axis` allows to explicitly exclude axes from the squeezing.\r\n\r\n* The `adjoint` transform now raises and error whenever the object it is applied to is not callable.  [(#2060)](https://github.com/PennyLaneAI/pennylane/pull/2060)\r\n\r\n  An example is a list of operations to which one might apply `qml.adjoint`:\r\n\r\n  ```python\r\n  dev = qml.device(\"default.qubit\", wires=2)\r\n  @qml.qnode(dev)\r\n  def circuit_wrong(params):\r\n      # Note the difference:                  v                         v\r\n      qml.adjoint(qml.templates.AngleEmbedding(params, wires=dev.wires))\r\n      return qml.state()\r\n\r\n  @qml.qnode(dev)\r\n  def circuit_correct(params):\r\n      # Note the difference:                  v                         v\r\n      qml.adjoint(qml.templates.AngleEmbedding)(params, wires=dev.wires)\r\n      return qml.state()\r\n\r\n  params = list(range(1, 3))\r\n  ```\r\n\r\n  Evaluating `circuit_wrong(params)` now raises a `ValueError` and if we apply `qml.adjoint` correctly, we get\r\n\r\n  ```pycon\r\n  >>> circuit_correct(params)\r\n  [ 0.47415988+0.j          0.         0.73846026j  0.         0.25903472j\r\n   -0.40342268+0.j        ]\r\n  ```\r\n\r\n* A precision argument has been added to the tape's ``to_openqasm`` function to control the precision of parameters.  [(#2071)](https://github.com/PennyLaneAI/pennylane/pull/2071)\r\n\r\n* Interferometer now has a `shape` method.  [(#1946)](https://github.com/PennyLaneAI/pennylane/pull/1946)\r\n\r\n* The Barrier and Identity operations now support the `adjoint` method.  [(#2062)](https://github.com/PennyLaneAI/pennylane/pull/2062) [(#2063)](https://github.com/PennyLaneAI/pennylane/pull/2063)\r\n\r\n* `qml.BasisStatePreparation` now supports the `batch_params` decorator.  [(#2091)](https://github.com/PennyLaneAI/pennylane/pull/2091)\r\n\r\n* Added a new `multi_dispatch` decorator that helps ease the definition of new functions inside PennyLane. The decorator is used throughout the math module, demonstrating use cases.  [(#2082)](https://github.com/PennyLaneAI/pennylane/pull/2084) [(#2096)](https://github.com/PennyLaneAI/pennylane/pull/2096)\r\n\r\n  We can decorate a function, indicating the arguments that are tensors handled by the interface:\r\n\r\n  ```pycon\r\n  >>> @qml.math.multi_dispatch(argnum=[0, 1])\r\n  ... def some_function(tensor1, tensor2, option, like):\r\n  ...     # the interface string is stored in ``like``.\r\n  ...     ...\r\n  ```\r\n\r\n  Previously, this was done using the private utility function `_multi_dispatch`.\r\n\r\n  ```pycon\r\n  >>> def some_function(tensor1, tensor2, option):\r\n  ...     interface = qml.math._multi_dispatch([tensor1, tensor2])\r\n  ...     ...\r\n  ```\r\n\r\n* The `IsingZZ` gate was added to the `diagonal_in_z_basis` attribute. For this an explicit `_eigvals` method was added.  [(#2113)](https://github.com/PennyLaneAI/pennylane/pull/2113)\r\n\r\n* The `IsingXX`, `IsingYY` and `IsingZZ` gates were added to the `composable_rotations` attribute.  [(#2113)](https://github.com/PennyLaneAI/pennylane/pull/2113)\r\n\r\n<h3>Breaking changes</h3>\r\n\r\n* QNode arguments will no longer be considered trainable by default when using the Autograd interface. In order to obtain derivatives with respect to a parameter, it should be instantiated via PennyLane's NumPy wrapper using the `requires_grad=True` attribute. The previous behaviour was deprecated in version v0.19.0 of PennyLane.  [(#2116)](https://github.com/PennyLaneAI/pennylane/pull/2116) [(#2125)](https://github.com/PennyLaneAI/pennylane/pull/2125) [(#2139)](https://github.com/PennyLaneAI/pennylane/pull/2139) [(#2148)](https://github.com/PennyLaneAI/pennylane/pull/2148) [(#2156)](https://github.com/PennyLaneAI/pennylane/pull/2156)\r\n\r\n  ```python\r\n  from pennylane import numpy as np\r\n\r\n  @qml.qnode(qml.device(\"default.qubit\", wires=2))\r\n  def circuit(x):\r\n    ...\r\n\r\n  x = np.array([0.1, 0.2], requires_grad=True)\r\n  qml.grad(circuit)(x)\r\n  ```\r\n\r\n  For the `qml.grad` and `qml.jacobian` functions, trainability can alternatively be indicated via the `argnum` keyword:\r\n\r\n  ```python\r\n  import numpy as np\r\n\r\n  @qml.qnode(qml.device(\"default.qubit\", wires=2))\r\n  def circuit(hyperparam, param):\r\n    ...\r\n\r\n  x = np.array([0.1, 0.2])\r\n  qml.grad(circuit, argnum=1)(0.5, x)\r\n  ```\r\n\r\n* `qml.jacobian` now follows a different convention regarding its output shape.  [(#2059)](https://github.com/PennyLaneAI/pennylane/pull/2059)\r\n\r\n  Previously, `qml.jacobian` would attempt to stack the Jacobian for multiple QNode arguments, which succeeded whenever the arguments have the same shape.  In this case, the stacked Jacobian would also be transposed, leading to the output shape `(*reverse_QNode_args_shape, *reverse_output_shape, num_QNode_args)`\r\n\r\n  If no stacking and transposing occurs, the output shape instead is a `tuple` where each entry corresponds to one QNode argument and has the shape `(*output_shape, *QNode_arg_shape)`.\r\n\r\n  This breaking change alters the behaviour in the first case and removes the attempt to stack and transpose, so that the output always has the shape of the second type.\r\n\r\n  Note that the behaviour is unchanged --- that is, the Jacobian tuple is unpacked into a single Jacobian --- if `argnum=None` and there is only one QNode argument with respect to which the differentiation takes place, or if an integer is provided as `argnum`.\r\n\r\n  A workaround that allowed `qml.jacobian` to differentiate multiple QNode arguments will no longer support higher-order derivatives. In such cases, combining multiple arguments into a single array is recommended.\r\n\r\n* `qml.metric_tensor`, `qml.adjoint_metric_tensor` and `qml.transforms.classical_jacobian` now follow a different convention regarding their output shape when being used with the Autograd interface [(#2059)](https://github.com/PennyLaneAI/pennylane/pull/2059)\r\n\r\n  See the previous entry for details. This breaking change immediately follows from the change in `qml.jacobian` whenever `hybrid=True` is used in the above methods.\r\n\r\n* The behaviour of `RotosolveOptimizer` has been changed regarding its keyword arguments.  [(#2081)](https://github.com/PennyLaneAI/pennylane/pull/2081)\r\n\r\n  The keyword arguments `optimizer` and `optimizer_kwargs` for the `RotosolveOptimizer` have been renamed to `substep_optimizer` and `substep_kwargs`, respectively. Furthermore they have been moved from `step` and `step_and_cost` to the initialization `__init__`.\r\n\r\n  The keyword argument `num_freqs` has been renamed to `nums_frequency` and is expected to take a different shape now: Previously, it was expected to be an `int` or a list of entries, with each entry in turn being either an `int` or a `list` of `int` entries.  Now the expected structure is a nested dictionary, matching the formatting expected by [qml.fourier.reconstruct](https://pennylane.readthedocs.io/en/stable/code/api/pennylane.fourier.reconstruct.html) This also matches the expected formatting of the new keyword arguments `spectra` and `shifts`.\r\n\r\n  For more details, see the [RotosolveOptimizer documentation](https://pennylane.readthedocs.io/en/stable/code/api/pennylane.RotosolveOptimizer.html).\r\n\r\n<h3>Deprecations</h3>\r\n\r\n* Deprecates the caching ability provided by `QubitDevice`.  [(#2154)](https://github.com/PennyLaneAI/pennylane/pull/2154)\r\n\r\n  Going forward, the preferred way is to use the caching abilities of the QNode:\r\n  ```python\r\n  dev = qml.device(\"default.qubit\", wires=2)\r\n\r\n  cache = {}\r\n\r\n  @qml.qnode(dev, diff_method='parameter-shift', cache=cache)\r\n  def circuit():\r\n      qml.RY(0.345, wires=0)\r\n      return qml.expval(qml.PauliZ(0))\r\n  ```\r\n  ```pycon\r\n  >>> for _ in range(10):\r\n  ...    circuit()\r\n  >>> dev.num_executions\r\n  1\r\n  ```\r\n\r\n<h3>Bug fixes</h3>\r\n\r\n* Fixes a bug where an incorrect number of executions are recorded by a QNode using a custom cache with `diff_method=\"backprop\"`.  [(#2171)](https://github.com/PennyLaneAI/pennylane/pull/2171)\r\n\r\n* Fixes a bug where the `default.qubit.jax` device can't be used with `diff_method=None` and jitting.  [(#2136)](https://github.com/PennyLaneAI/pennylane/pull/2136)\r\n\r\n* Fixes a bug where the Torch interface was not properly unwrapping Torch tensors to NumPy arrays before executing gradient tapes on devices.  [(#2117)](https://github.com/PennyLaneAI/pennylane/pull/2117)\r\n\r\n* Fixes a bug for the TensorFlow interface where the dtype of input tensors was not cast.  [(#2120)](https://github.com/PennyLaneAI/pennylane/pull/2120)\r\n\r\n* Fixes a bug where batch transformed QNodes would fail to apply batch transforms provided by the underlying device.  [(#2111)](https://github.com/PennyLaneAI/pennylane/pull/2111)\r\n\r\n* An error is now raised during QNode creation if backpropagation is requested on a device with finite shots specified.  [(#2114)](https://github.com/PennyLaneAI/pennylane/pull/2114)\r\n\r\n* Pytest now ignores any `DeprecationWarning` raised within autograd's `numpy_wrapper` module.  Other assorted minor test warnings are fixed.  [(#2007)](https://github.com/PennyLaneAI/pennylane/pull/2007)\r\n\r\n* Fixes a bug where the QNode was not correctly diagonalizing qubit-wise commuting observables.  [(#2097)](https://github.com/PennyLaneAI/pennylane/pull/2097) \r\n\r\n* Fixes a bug in `gradient_transform` where the hybrid differentiation of circuits with a single parametrized gate failed and QNode argument axes of size `1` where removed from the output gradient.  [(#2080)](https://github.com/PennyLaneAI/pennylane/pull/2080)\r\n\r\n* The available `diff_method` options for QNodes has been corrected in both the error messages and the documentation.  [(#2078)](https://github.com/PennyLaneAI/pennylane/pull/2078)\r\n\r\n* Fixes a bug in `DefaultQubit` where the second derivative of QNodes at positions corresponding to vanishing state vector amplitudes is wrong.  [(#2057)](https://github.com/PennyLaneAI/pennylane/pull/2057)\r\n\r\n* Fixes a bug where PennyLane didn't require v0.20.0 of PennyLane-Lightning, but raised an error with versions of Lightning earlier than v0.20.0 due to the new batch execution pipeline.  [(#2033)](https://github.com/PennyLaneAI/pennylane/pull/2033)\r\n\r\n* Fixes a bug in `classical_jacobian` when used with Torch, where the Jacobian of the preprocessing was also computed for non-trainable parameters.  [(#2020)](https://github.com/PennyLaneAI/pennylane/pull/2020)\r\n\r\n* Fixes a bug in queueing of the `two_qubit_decomposition` method that originally led to circuits with >3 two-qubit unitaries failing when passed through the `unitary_to_rot` optimization transform.  [(#2015)](https://github.com/PennyLaneAI/pennylane/pull/2015)\r\n\r\n* Fixes a bug which allows using `jax.jit` to be compatible with circuits which return `qml.probs` when the `default.qubit.jax` is provided with a custom shot vector.  [(#2028)](https://github.com/PennyLaneAI/pennylane/pull/2028)\r\n\r\n* Updated the `adjoint()` method for non-parametric qubit operations to solve a bug where repeated `adjoint()` calls don't return the correct operator.  [(#2133)](https://github.com/PennyLaneAI/pennylane/pull/2133)\r\n\r\n* Fixed a bug in `insert()` which prevented operations that inherited from multiple classes to be inserted.  [(#2172)](https://github.com/PennyLaneAI/pennylane/pull/2172)\r\n\r\n<h3>Documentation</h3>\r\n\r\n* Fixes an error in the signs of equations in the `DoubleExcitation` page.  [(#2072)](https://github.com/PennyLaneAI/pennylane/pull/2072)\r\n\r\n* Extends the interfaces description page to explicitly mention device compatibility.  [(#2031)](https://github.com/PennyLaneAI/pennylane/pull/2031)\r\n\r\n<h3>Contributors</h3>\r\n\r\nThis release contains contributions from (in alphabetical order):\r\n\r\nJuan Miguel Arrazola, Ali Asadi, Utkarsh Azad, Sam Banning, Thomas Bromley, Esther Cruz, Christian Gogolin, Nathan Killoran, Christina Lee, Olivia Di Matteo, Diego Guala, Anthony Hayes, David Ittah, Josh Izaac, Soran Jahangiri, Edward Jiang, Ankit Khandelwal, Korbinian Kottmann, Romain Moyard, Lee James O'Riordan, Maria Schuld, Jay Soni, Antal Sz\u00e1va, David Wierichs, Shaoming Zhang."}
{"url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/55241640", "assets_url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/55241640/assets", "upload_url": "https://uploads.github.com/repos/PennyLaneAI/pennylane/releases/55241640/assets{?name,label}", "html_url": "https://github.com/PennyLaneAI/pennylane/releases/tag/v0.20.0", "id": 55241640, "author": {"login": "antalszava", "id": 24476053, "node_id": "MDQ6VXNlcjI0NDc2MDUz", "avatar_url": "https://avatars.githubusercontent.com/u/24476053?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antalszava", "html_url": "https://github.com/antalszava", "followers_url": "https://api.github.com/users/antalszava/followers", "following_url": "https://api.github.com/users/antalszava/following{/other_user}", "gists_url": "https://api.github.com/users/antalszava/gists{/gist_id}", "starred_url": "https://api.github.com/users/antalszava/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antalszava/subscriptions", "organizations_url": "https://api.github.com/users/antalszava/orgs", "repos_url": "https://api.github.com/users/antalszava/repos", "events_url": "https://api.github.com/users/antalszava/events{/privacy}", "received_events_url": "https://api.github.com/users/antalszava/received_events", "type": "User", "site_admin": false}, "node_id": "RE_kwDOB76r6M4DSuuo", "tag_name": "v0.20.0", "target_commitish": "v0.20.0-rc0", "name": "Release 0.20.0", "draft": false, "prerelease": false, "created_at": "2021-12-14T07:42:06Z", "published_at": "2021-12-14T07:47:14Z", "assets": [], "tarball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/tarball/v0.20.0", "zipball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/zipball/v0.20.0", "body": "<h3>New features since last release</h3>\r\n\r\n<h4>Shiny new circuit drawer!\ud83c\udfa8\ud83d\udd8c\ufe0f </h4>\r\n\r\n* PennyLane now supports drawing a QNode with matplotlib!   [(#1803)](https://github.com/PennyLaneAI/pennylane/pull/1803)   [(#1811)](https://github.com/PennyLaneAI/pennylane/pull/1811)   [(#1931)](https://github.com/PennyLaneAI/pennylane/pull/1931)   [(#1954)](https://github.com/PennyLaneAI/pennylane/pull/1954)\r\n\r\n  ```python\r\n  dev = qml.device(\"default.qubit\", wires=4)\r\n\r\n  @qml.qnode(dev)\r\n  def circuit(x, z):\r\n      qml.QFT(wires=(0,1,2,3))\r\n      qml.Toffoli(wires=(0,1,2))\r\n      qml.CSWAP(wires=(0,2,3))\r\n      qml.RX(x, wires=0)\r\n      qml.CRZ(z, wires=(3,0))\r\n      return qml.expval(qml.PauliZ(0))\r\n  fig, ax = qml.draw_mpl(circuit)(1.2345, 1.2345)\r\n  fig.show()\r\n  ```\r\n\r\n  <img src=\"https://pennylane.readthedocs.io/en/latest/_images/main_example.png\" width=70%/>\r\n\r\n<h4>New and improved quantum-aware optimizers</h4>\r\n\r\n\r\n* Added `qml.LieAlgebraOptimizer`, a new quantum-aware Lie Algebra optimizer that allows one to perform gradient descent on the special unitary group. [(#1911)](https://github.com/PennyLaneAI/pennylane/pull/1911)\r\n\r\n  ```python\r\n  dev = qml.device(\"default.qubit\", wires=2)\r\n  H = -1.0 * qml.PauliX(0) - qml.PauliZ(1) - qml.PauliY(0) @ qml.PauliX(1)\r\n\r\n  @qml.qnode(dev)\r\n  def circuit():\r\n      qml.RX(0.1, wires=[0])\r\n      qml.RY(0.5, wires=[1])\r\n      qml.CNOT(wires=[0,1])\r\n      qml.RY(0.6, wires=[0])\r\n      return qml.expval(H)\r\n  opt = qml.LieAlgebraOptimizer(circuit=circuit, stepsize=0.1)\r\n  ```\r\n\r\n  Note that, unlike other optimizers, the `LieAlgebraOptimizer` accepts a QNode with *no* parameters, and instead grows the circuit by pending operations during the optimization:\r\n\r\n  ```pycon\r\n  >>> circuit()\r\n  tensor(-1.3351865, requires_grad=True)\r\n  >>> circuit1, cost = opt.step_and_cost()\r\n  >>> circuit1()\r\n  tensor(-1.99378872, requires_grad=True)\r\n  ```\r\n\r\n  For more details, see the [LieAlgebraOptimizer documentation](https://pennylane.readthedocs.io/en/stable/code/api/pennylane.LieAlgebraOptimizer.html).\r\n\r\n* The `qml.metric_tensor` transform can now be used to compute the full tensor, beyond the block diagonal approximation. [(#1725)](https://github.com/PennyLaneAI/pennylane/pull/1725)\r\n\r\n  This is performed using Hadamard tests, and requires an additional wire  on the device to execute the circuits produced by the transform, as compared to the number of wires required by the original circuit. The transform defaults to computing the full tensor, which can be controlled by the `approx` keyword argument.\r\n\r\n  As an example, consider the QNode\r\n\r\n  ```python\r\n  dev = qml.device(\"default.qubit\", wires=3)\r\n\r\n  @qml.qnode(dev)\r\n  def circuit(weights):\r\n      qml.RX(weights[0], wires=0)\r\n      qml.RY(weights[1], wires=0)\r\n      qml.CNOT(wires=[0, 1])\r\n      qml.RZ(weights[2], wires=1)\r\n      return qml.expval(qml.PauliZ(0) @ qml.PauliZ(1))\r\n\r\n  weights = np.array([0.2, 1.2, -0.9], requires_grad=True)\r\n  ```\r\n\r\n  Then we can compute the (block) diagonal metric tensor as before, now using the `approx=\"block-diag\"` keyword:\r\n\r\n  ```pycon\r\n  >>> qml.metric_tensor(circuit, approx=\"block-diag\")(weights)\r\n  [[0.25       0.         0.        ]\r\n   [0.         0.24013262 0.        ]\r\n   [0.         0.         0.21846983]]\r\n  ```\r\n\r\n  Instead, we now can also compute the full metric tensor, using Hadamard tests on the additional wire of the device:\r\n\r\n  ```pycon\r\n  >>> qml.metric_tensor(circuit)(weights)\r\n  [[ 0.25        0.         -0.23300977]\r\n   [ 0.          0.24013262  0.01763859]\r\n   [-0.23300977  0.01763859  0.21846983]]\r\n  ```\r\n\r\n  See the [metric tensor documentation](https://pennylane.readthedocs.io/en/latest/code/api/pennylane.transforms.metric_tensor.html) for more information and usage details.\r\n\r\n<h4>Faster performance with optimized quantum workflows</h4>\r\n\r\n* The QNode has been re-written to support batch execution across the board,   custom gradients, better decomposition strategies, and higher-order derivatives. [(#1807)](https://github.com/PennyLaneAI/pennylane/pull/1807) [(#1969)](https://github.com/PennyLaneAI/pennylane/pull/1969)\r\n\r\n  - Internally, if multiple circuits are generated for simultaneous execution, they will be packaged into a single job for execution on the device. This can lead to significant performance improvement when executing the QNode on remote quantum hardware or simulator devices with parallelization capabilities.\r\n\r\n  - Custom gradient transforms can be specified as the differentiation method:\r\n\r\n    ```python\r\n    @qml.gradients.gradient_transform\r\n    def my_gradient_transform(tape):\r\n        ...\r\n        return tapes, processing_fn\r\n\r\n    @qml.qnode(dev, diff_method=my_gradient_transform)\r\n    def circuit():\r\n    ```\r\n\r\n  For breaking changes related to the use of the new QNode, refer to the Breaking Changes section.\r\n\r\n  Note that the old QNode remains accessible at `@qml.qnode_old.qnode`, however this will be removed in the next release.\r\n\r\n* Custom decompositions can now be applied to operations at the device level. [(#1900)](https://github.com/PennyLaneAI/pennylane/pull/1900)\r\n\r\n  For example, suppose we would like to implement the following QNode:\r\n\r\n  ```python\r\n  def circuit(weights):\r\n      qml.BasicEntanglerLayers(weights, wires=[0, 1, 2])\r\n      return qml.expval(qml.PauliZ(0))\r\n\r\n  original_dev = qml.device(\"default.qubit\", wires=3)\r\n  original_qnode = qml.QNode(circuit, original_dev)\r\n  ```\r\n\r\n  ```pycon\r\n  >>> weights = np.array([[0.4, 0.5, 0.6]])\r\n  >>> print(qml.draw(original_qnode, expansion_strategy=\"device\")(weights))\r\n   0: \u2500\u2500RX(0.4)\u2500\u2500\u256dC\u2500\u2500\u2500\u2500\u2500\u2500\u256dX\u2500\u2500\u2524 \u27e8Z\u27e9\r\n   1: \u2500\u2500RX(0.5)\u2500\u2500\u2570X\u2500\u2500\u256dC\u2500\u2500\u2502\u2500\u2500\u2500\u2524\r\n   2: \u2500\u2500RX(0.6)\u2500\u2500\u2500\u2500\u2500\u2500\u2570X\u2500\u2500\u2570C\u2500\u2500\u2524\r\n  ```\r\n\r\n  Now, let's swap out the decomposition of the `CNOT` gate into `CZ` and `Hadamard`, and furthermore the decomposition of `Hadamard` into `RZ` and `RY` rather than the decomposition already available in PennyLane. We define the two decompositions like so, and pass them to a device:\r\n\r\n  ```python\r\n  def custom_cnot(wires):\r\n      return [\r\n          qml.Hadamard(wires=wires[1]),\r\n          qml.CZ(wires=[wires[0], wires[1]]),\r\n          qml.Hadamard(wires=wires[1])\r\n      ]\r\n\r\n  def custom_hadamard(wires):\r\n      return [\r\n          qml.RZ(np.pi, wires=wires),\r\n          qml.RY(np.pi / 2, wires=wires)\r\n      ]\r\n\r\n  # Can pass the operation itself, or a string\r\n  custom_decomps = {qml.CNOT : custom_cnot, \"Hadamard\" : custom_hadamard}\r\n\r\n  decomp_dev = qml.device(\"default.qubit\", wires=3, custom_decomps=custom_decomps)\r\n  decomp_qnode = qml.QNode(circuit, decomp_dev)\r\n  ```\r\n\r\n  Now when we draw or run a QNode on this device, the gates will be expanded according to our specifications:\r\n\r\n  ```pycon\r\n  >>> print(qml.draw(decomp_qnode, expansion_strategy=\"device\")(weights))\r\n   0: \u2500\u2500RX(0.4)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256dC\u2500\u2500RZ(3.14)\u2500\u2500RY(1.57)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256dZ\u2500\u2500RZ(3.14)\u2500\u2500RY(1.57)\u2500\u2500\u2524 \u27e8Z\u27e9\r\n   1: \u2500\u2500RX(0.5)\u2500\u2500RZ(3.14)\u2500\u2500RY(1.57)\u2500\u2500\u2570Z\u2500\u2500RZ(3.14)\u2500\u2500RY(1.57)\u2500\u2500\u256dC\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n   2: \u2500\u2500RX(0.6)\u2500\u2500RZ(3.14)\u2500\u2500RY(1.57)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2570Z\u2500\u2500RZ(3.14)\u2500\u2500RY(1.57)\u2500\u2500\u2570C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n  ```\r\n\r\n  A separate context manager, `set_decomposition`, has also been implemented to enable  application of custom decompositions on devices that have already been created.\r\n\r\n  ```pycon\r\n  >>> with qml.transforms.set_decomposition(custom_decomps, original_dev):\r\n  ...     print(qml.draw(original_qnode, expansion_strategy=\"device\")(weights))\r\n   0: \u2500\u2500RX(0.4)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256dC\u2500\u2500RZ(3.14)\u2500\u2500RY(1.57)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256dZ\u2500\u2500RZ(3.14)\u2500\u2500RY(1.57)\u2500\u2500\u2524 \u27e8Z\u27e9\r\n   1: \u2500\u2500RX(0.5)\u2500\u2500RZ(3.14)\u2500\u2500RY(1.57)\u2500\u2500\u2570Z\u2500\u2500RZ(3.14)\u2500\u2500RY(1.57)\u2500\u2500\u256dC\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n   2: \u2500\u2500RX(0.6)\u2500\u2500RZ(3.14)\u2500\u2500RY(1.57)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2570Z\u2500\u2500RZ(3.14)\u2500\u2500RY(1.57)\u2500\u2500\u2570C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n  ```\r\n\r\n* Given an operator of the form :math:`U=e^{iHt}`, where :math:`H` has  commuting terms and known eigenvalues,  `qml.gradients.generate_shift_rule` computes the generalized parameter shift rules for determining the gradient of the expectation value :math:`f(t) = \\langle 0|U(t)^\\dagger \\hat{O} U(t)|0\\rangle` on hardware. [(#1788)](https://github.com/PennyLaneAI/pennylane/pull/1788) [(#1932)](https://github.com/PennyLaneAI/pennylane/pull/1932)\r\n\r\n  Given $H = \\sum_i a_i h_i$, where the eigenvalues of :math:`H` are known and all :math:`h_i` commute, we can compute the *frequencies* (the unique positive differences of any two eigenvalues) using `qml.gradients.eigvals_to_frequencies`.\r\n\r\n  `qml.gradients.generate_shift_rule` can then be used to compute the parameter shift rules to compute :math:`f'(t)` using `2R` shifted cost function evaluations. This becomes cheaper than the standard application of the chain rule and two-term shift rule when `R` is less than the number of Pauli words in the generator.\r\n\r\n  For example, consider the case where :math:`H` has eigenspectrum `(-1, 0, 1)`:\r\n\r\n  ```pycon\r\n  >>> frequencies = qml.gradients.eigvals_to_frequencies((-1, 0, 1))\r\n  >>> frequencies\r\n  (1, 2)\r\n  >>> coeffs, shifts = qml.gradients.generate_shift_rule(frequencies)\r\n  >>> coeffs\r\n  array([ 0.85355339, -0.85355339, -0.14644661,  0.14644661])\r\n  >>> shifts\r\n  array([ 0.78539816, -0.78539816,  2.35619449, -2.35619449])\r\n  ```\r\n\r\n  As we can see, `generate_shift_rule` returns four coefficients :math:`c_i` and shifts :math:`s_i` corresponding to a four term parameter shift rule. The gradient can then be reconstructed via:\r\n\r\n  .. math:: \\frac{\\partial}{\\partial\\phi}f = \\sum_{i} c_i f(\\phi + s_i),\r\n\r\n  where :math:`f(\\phi) = \\langle 0|U(\\phi)^\\dagger \\hat{O} U(\\phi)|0\\rangle` for some observable :math:`\\hat{O}` and the unitary :math:`U(\\phi)=e^{iH\\phi}`.\r\n\r\n<h4>Support for TensorFlow AutoGraph mode with quantum hardware</h4>\r\n\r\n* It is now possible to use TensorFlow's [AutoGraph\r\n  mode](https://www.tensorflow.org/guide/function) with QNodes on all devices and with arbitrary\r\n  differentiation methods. Previously, AutoGraph mode only support `diff_method=\"backprop\"`. This\r\n  will result in significantly more performant model execution, at the cost of a more expensive   initial compilation. [(#1866)](https://github.com/PennyLaneAI/pennylane/pull/1886)\r\n\r\n  Use AutoGraph to convert your QNodes or cost functions into TensorFlow   graphs by decorating them with `@tf.function`:\r\n\r\n  ```python\r\n  dev = qml.device(\"lightning.qubit\", wires=2)\r\n\r\n  @qml.qnode(dev, diff_method=\"adjoint\", interface=\"tf\", max_diff=1)\r\n  def circuit(x):\r\n      qml.RX(x[0], wires=0)\r\n      qml.RY(x[1], wires=1)\r\n      return qml.expval(qml.PauliZ(0) @ qml.PauliZ(1)), qml.expval(qml.PauliZ(0))\r\n\r\n  @tf.function\r\n  def cost(x):\r\n      return tf.reduce_sum(circuit(x))\r\n\r\n  x = tf.Variable([0.5, 0.7], dtype=tf.float64)\r\n\r\n  with tf.GradientTape() as tape:\r\n      loss = cost(x)\r\n\r\n  grad = tape.gradient(loss, x)\r\n  ```\r\n\r\n  The initial execution may take slightly longer than when executing the circuit in\r\n  eager mode; this is because TensorFlow is tracing the function to create the graph.   Subsequent executions will be much more performant.\r\n\r\n  Note that using AutoGraph with backprop-enabled devices, such as `default.qubit`,   will yield the best performance.\r\n\r\n  For more details, please see the [TensorFlow AutoGraph   documentation](https://www.tensorflow.org/guide/function).\r\n\r\n<h4>Characterize your quantum models with classical QNode reconstruction</h4>\r\n\r\n* The `qml.fourier.reconstruct` function is added. It can be used to   reconstruct QNodes outputting expectation values along a specified   parameter dimension, with a minimal number of calls to the   original QNode. The returned   reconstruction is exact and purely classical, and can be evaluated   without any quantum executions.   [(#1864)](https://github.com/PennyLaneAI/pennylane/pull/1864)\r\n\r\n  The reconstruction technique differs for functions with equidistant frequencies   that are reconstructed using the function value at equidistant sampling points, and   for functions with arbitrary frequencies reconstructed using arbitrary sampling points.\r\n\r\n  As an example, consider the following QNode:\r\n\r\n  ```python\r\n  dev = qml.device(\"default.qubit\", wires=2)\r\n\r\n  @qml.qnode(dev)\r\n  def circuit(x, Y, f=1.0):\r\n      qml.RX(f * x, wires=0)\r\n      qml.RY(Y[0], wires=0)\r\n      qml.RY(Y[1], wires=1)\r\n      qml.CNOT(wires=[0, 1])\r\n      qml.RY(3 * Y[1], wires=1)\r\n      return qml.expval(qml.PauliZ(0) @ qml.PauliZ(1))\r\n  ```\r\n\r\n  It has three variational parameters overall: A scalar input `x`   and an array-valued input `Y` with two entries. Additionally, we can   tune the dependence on `x` with the frequency `f`.   We then can reconstruct the QNode output function with respect to `x` via\r\n\r\n  ```pycon\r\n  >>> x = 0.3\r\n  >>> Y = np.array([0.1, -0.9])\r\n  >>> rec = qml.fourier.reconstruct(circuit, ids=\"x\", nums_frequency={\"x\": {0: 1}})(x, Y)\r\n  >>> rec\r\n  {'x': {0: <function pennylane.fourier.reconstruct._reconstruct_equ.<locals>._reconstruction(x)>}}\r\n  ```\r\n\r\n  As we can see, we get a nested dictionary in the format of the input `nums_frequency`   with functions as values. These functions are simple float-to-float callables:\r\n\r\n  ```pycon\r\n  >>> univariate = rec[\"x\"][0]\r\n  >>> univariate(x)\r\n  -0.880208251507\r\n  ```\r\n\r\n  For more details on usage, reconstruction cost and differentiability support, please see the   [fourier.reconstruct docstring](https://pennylane.readthedocs.io/en/latest/code/api/pennylane.fourier.reconstruct.html).\r\n\r\n<h4>State-of-the-art operations and templates</h4>\r\n\r\n* A circuit template for time evolution under a commuting Hamiltonian utilizing generalized   parameter shift rules for cost function gradients is available as `qml.CommutingEvolution`.   [(#1788)](https://github.com/PennyLaneAI/pennylane/pull/1788)\r\n\r\n  If the template is handed a frequency spectrum during its instantiation, then `generate_shift_rule`   is internally called to obtain the general parameter shift rules with respect to   `CommutingEvolution`'s :math:`t` parameter, otherwise the shift rule for a decomposition of   `CommutingEvolution` will be used.\r\n\r\n  The template can be initialized within a `qnode` as:\r\n\r\n  ```python\r\n  import pennylane as qml\r\n\r\n  n_wires = 2\r\n  dev = qml.device('default.qubit', wires=n_wires)\r\n\r\n  coeffs = [1, -1]\r\n  obs = [qml.PauliX(0) @ qml.PauliY(1), qml.PauliY(0) @ qml.PauliX(1)]\r\n  hamiltonian = qml.Hamiltonian(coeffs, obs)\r\n  frequencies = (2,4)\r\n\r\n  @qml.qnode(dev)\r\n  def circuit(time):\r\n      qml.PauliX(0)\r\n      qml.CommutingEvolution(hamiltonian, time, frequencies)\r\n      return qml.expval(qml.PauliZ(0))\r\n  ```\r\n\r\n  Note that there is no internal validation that 1) the input `qml.Hamiltonian` is fully commuting   and 2) the eigenvalue frequency spectrum is correct, since these checks become   prohibitively expensive for large Hamiltonians.\r\n\r\n* The `qml.Barrier()` operator has been added. With it we can separate blocks   in compilation or use it as a visual tool.   [(#1844)](https://github.com/PennyLaneAI/pennylane/pull/1844)\r\n\r\n* Added the identity observable to be an operator. Now we can explicitly call the identity   operation on our quantum circuits for both qubit and CV devices.   [(#1829)](https://github.com/PennyLaneAI/pennylane/pull/1829)\r\n\r\n* Added the `qml.QubitDensityMatrix` initialization gate for   mixed state simulation.   [(#1850)](https://github.com/PennyLaneAI/pennylane/pull/1850)\r\n\r\n* A thermal relaxation channel is added to the Noisy channels. The channel description can be   found on the supplementary information of [Quantum classifier with tailored quantum kernels](https://arxiv.org/abs/1909.02611).   [(#1766)](https://github.com/PennyLaneAI/pennylane/pull/1766)\r\n\r\n<h4>Manipulate QNodes to your \u2764\ufe0fs content with new transforms</h4>\r\n\r\n* The `merge_amplitude_embedding` transformation has been created to   automatically merge all gates of this type into one.   [(#1933)](https://github.com/PennyLaneAI/pennylane/pull/1933)\r\n  ```python\r\n  from pennylane.transforms import merge_amplitude_embedding\r\n\r\n  dev = qml.device(\"default.qubit\", wires = 3)\r\n\r\n  @qml.qnode(dev)\r\n  @merge_amplitude_embedding\r\n  def qfunc():\r\n      qml.AmplitudeEmbedding([0,1,0,0], wires = [0,1])\r\n      qml.AmplitudeEmbedding([0,1], wires = 2)\r\n      return qml.expval(qml.PauliZ(wires = 0))\r\n  ```\r\n  ```pycon\r\n  >>> print(qml.draw(qnode)())\r\n   0: \u2500\u2500\u256dAmplitudeEmbedding(M0)\u2500\u2500\u2524 \u27e8Z\u27e9\r\n   1: \u2500\u2500\u251cAmplitudeEmbedding(M0)\u2500\u2500\u2524\r\n   2: \u2500\u2500\u2570AmplitudeEmbedding(M0)\u2500\u2500\u2524\r\n   M0 =\r\n   [0.+0.j 0.+0.j 0.+0.j 1.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j]\r\n  ```\r\n\r\n* The `undo_swaps` transformation has been created to automatically remove all   swaps of a circuit.   [(#1960)](https://github.com/PennyLaneAI/pennylane/pull/1960)\r\n  ```python\r\n  dev = qml.device('default.qubit', wires=3)\r\n\r\n  @qml.qnode(dev)\r\n  @qml.transforms.undo_swaps\r\n  def qfunc():\r\n      qml.Hadamard(wires=0)\r\n      qml.PauliX(wires=1)\r\n      qml.SWAP(wires=[0,1])\r\n      qml.SWAP(wires=[0,2])\r\n      qml.PauliY(wires=0)\r\n      return qml.expval(qml.PauliZ(0))\r\n\r\n  ```\r\n  ```pycon\r\n  >>> print(qml.draw(qfunc)())\r\n   0: \u2500\u2500Y\u2500\u2500\u2524 \u27e8Z\u27e9\r\n   1: \u2500\u2500H\u2500\u2500\u2524\r\n   2: \u2500\u2500X\u2500\u2500\u2524\r\n  ```\r\n\r\n<h3>Improvements</h3>\r\n\r\n* Added functions for computing the values of atomic and molecular orbitals at a given position.\r\n  [(#1867)](https://github.com/PennyLaneAI/pennylane/pull/1867)\r\n\r\n  The functions `atomic_orbital` and `molecular_orbital` can be used, as shown in the   following codeblock, to evaluate the orbitals. By generating values of the orbitals at different   positions, one can plot the spatial shape of a desired orbital.\r\n\r\n  ```python\r\n  symbols  = ['H', 'H']\r\n  geometry = np.array([[0.0, 0.0, 0.0], [0.0, 0.0, 1.0]], requires_grad = False)\r\n  mol = hf.Molecule(symbols, geometry)\r\n  hf.generate_scf(mol)()\r\n\r\n  ao = mol.atomic_orbital(0)\r\n  mo = mol.molecular_orbital(1)\r\n  ```\r\n\r\n  ```pycon\r\n  >>> print(ao(0.0, 0.0, 0.0))\r\n  >>> print(mo(0.0, 0.0, 0.0))\r\n  0.6282468778183719\r\n  0.018251285973461928\r\n  ```\r\n\r\n* Added support for Python 3.10.   [(#1964)](https://github.com/PennyLaneAI/pennylane/pull/1964)\r\n\r\n* The execution of QNodes that have\r\n\r\n  - multiple return types;\r\n  - a return type other than Variance and Expectation\r\n\r\n  now raises a descriptive error message when using the JAX interface.   [(#2011)](https://github.com/PennyLaneAI/pennylane/pull/2011)\r\n\r\n* The PennyLane `qchem` package is now lazily imported; it will only be imported   the first time it is accessed.   [(#1962)](https://github.com/PennyLaneAI/pennylane/pull/1962)\r\n\r\n* `qml.math.scatter_element_add` now supports adding multiple values at   multiple indices with a single function call, in all interfaces   [(#1864)](https://github.com/PennyLaneAI/pennylane/pull/1864)\r\n\r\n  For example, we may set five values of a three-dimensional tensor   in the following way:\r\n\r\n  ```pycon\r\n  >>> X = tf.zeros((3, 2, 9), dtype=tf.float64)\r\n  >>> indices = [(0, 0, 1, 2, 2), (0, 0, 0, 0, 1), (1, 3, 8, 6, 7)]\r\n  >>> values = [1 * i for i in range(1,6)]\r\n  >>> qml.math.scatter_element_add(X, indices, values)\r\n  <tf.Tensor: shape=(3, 2, 9), dtype=float64, numpy=\r\n  array([[[0., 1., 0., 2., 0., 0., 0., 0., 0.],\r\n          [0., 0., 0., 0., 0., 0., 0., 0., 0.]],\r\n\r\n         [[0., 0., 0., 0., 0., 0., 0., 0., 3.],\r\n          [0., 0., 0., 0., 0., 0., 0., 0., 0.]],\r\n\r\n         [[0., 0., 0., 0., 0., 0., 4., 0., 0.],\r\n          [0., 0., 0., 0., 0., 0., 0., 5., 0.]]])>\r\n  ```\r\n\r\n* All instances of `str.format` have been replace with f-strings.   [(#1970)](https://github.com/PennyLaneAI/pennylane/pull/1970)\r\n\r\n* Tests do not loop over automatically imported and instantiated operations any more,   which was opaque and created unnecessarily many tests.   [(#1895)](https://github.com/PennyLaneAI/pennylane/pull/1895)\r\n\r\n* A `decompose()` method has been added to the `Operator` class such that we can   obtain (and queue) decompositions directly from instances of operations.   [(#1873)](https://github.com/PennyLaneAI/pennylane/pull/1873)\r\n\r\n  ```pycon\r\n  >>> op = qml.PhaseShift(0.3, wires=0)\r\n  >>> op.decompose()\r\n  [RZ(0.3, wires=[0])]\r\n  ```\r\n\r\n* `qml.circuit_drawer.tape_mpl` produces a matplotlib figure and axes given a tape.   [(#1787)](https://github.com/PennyLaneAI/pennylane/pull/1787)\r\n\r\n* The `AngleEmbedding`, `BasicEntanglerLayers` and `MottonenStatePreparation`  templates now support the `batch_params` decorator.   [(#1812)](https://github.com/PennyLaneAI/pennylane/pull/1812)   [(#1883)](https://github.com/PennyLaneAI/pennylane/pull/1883)   [(#1893)](https://github.com/PennyLaneAI/pennylane/pull/1893)\r\n\r\n* Added a new `qml.PauliError` channel that allows the application of an   arbitrary number of Pauli operators on an arbitrary number of wires.   [(#1781)](https://github.com/PennyLaneAI/pennylane/pull/1781)\r\n\r\n* CircuitDrawer now supports a `max_length` argument to help prevent text overflows when printing circuits to the CLI.   [(#1892)](https://github.com/PennyLaneAI/pennylane/pull/1892)\r\n\r\n* `Identity` operation is now part of both the `ops.qubit` and `ops.cv`   modules.   [(#1956)](https://github.com/PennyLaneAI/pennylane/pull/1956)\r\n\r\n<h3>Breaking changes</h3>\r\n\r\n* The QNode has been re-written to support batch execution across the board,   custom gradients, better decomposition strategies, and higher-order derivatives.   [(#1807)](https://github.com/PennyLaneAI/pennylane/pull/1807)   [(#1969)](https://github.com/PennyLaneAI/pennylane/pull/1969)\r\n\r\n  - Arbitrary :math:`n`-th order derivatives are supported on hardware using gradient transforms     such as the parameter-shift rule. To specify that an :math:`n`-th order derivative of a QNode     will be computed, the `max_diff` argument should be set. By default, this is set to 1     (first-order derivatives only). Increasing this value allows for higher order derivatives to be     extracted, at the cost of additional (classical) computational overhead during the backwards     pass.\r\n\r\n  - When decomposing the circuit, the default decomposition strategy `expansion_strategy=\"gradient\"`     will prioritize decompositions that result in the smallest number of parametrized operations     required to satisfy the differentiation method. While this may lead to a slight increase in     classical processing, it significantly reduces the number of circuit evaluations needed to     compute gradients of complicated unitaries.\r\n\r\n    To return to the old behaviour, `expansion_strategy=\"device\"` can be specified.\r\n\r\n  Note that the old QNode remains accessible at `@qml.qnode_old.qnode`, however this will   be removed in the next release.\r\n\r\n* Certain features deprecated in `v0.19.0` have been removed: [(#1963)](https://github.com/PennyLaneAI/pennylane/pull/1963) [(#1981)](https://github.com/PennyLaneAI/pennylane/pull/1981)\r\n\r\n  - The `qml.template` decorator (use a [`QuantumTape`](https://pennylane.readthedocs.io/en/stable/code/api/pennylane.tape.QuantumTape.html)     as a context manager to record operations and its `operations` attribute to     return them, see the linked page for examples);\r\n  - The `default.tensor` and `default.tensor.tf` experimental devices;\r\n  - The `qml.fourier.spectrum` function (use the `qml.fourier.circuit_spectrum`\r\n    or `qml.fourier.qnode_spectrum` functions instead);\r\n  - The `diag_approx` keyword argument of `qml.metric_tensor` and\r\n    `qml.QNGOptimizer` (pass `approx='diag'` instead).   \r\n\r\n* The default behaviour of the `qml.metric_tensor` transform has been modified.   By default, the full metric tensor is computed, leading to higher cost than the previous   default of computing the block diagonal only. At the same time, the Hadamard tests for   the full metric tensor require an additional wire on the device, so that\r\n\r\n  ```pycon\r\n  >>> qml.metric_tensor(some_qnode)(weights)\r\n  ```\r\n\r\n  will revert back to the block diagonal restriction and raise a warning if the   used device does not have an additional wire.   [(#1725)](https://github.com/PennyLaneAI/pennylane/pull/1725)\r\n\r\n* The `circuit_drawer` module has been renamed `drawer`.   [(#1949)](https://github.com/PennyLaneAI/pennylane/pull/1949)\r\n\r\n* The `par_domain` attribute in the operator class has been removed.   [(#1907)](https://github.com/PennyLaneAI/pennylane/pull/1907)\r\n\r\n* The `mutable` keyword argument has been removed from the QNode,   due to underlying bugs that result in incorrect results being   returned from immutable QNodes. This functionality will return   in an upcoming release.   [(#1807)](https://github.com/PennyLaneAI/pennylane/pull/1807)\r\n\r\n* The reversible QNode differentiation method has been removed; the adjoint   differentiation method is preferred instead (`diff_method='adjoint'`).   [(#1807)](https://github.com/PennyLaneAI/pennylane/pull/1807)\r\n\r\n* `QuantumTape.trainable_params` now is a list instead of a set. This   means that `tape.trainable_params` will return a list unlike before,   but setting the `trainable_params` with a set works exactly as before.   [(#1904)](https://github.com/PennyLaneAI/pennylane/pull/1904)\r\n\r\n* The `num_params` attribute in the operator class is now dynamic. This makes it easier   to define operator subclasses with a flexible number of parameters.   [(#1898)](https://github.com/PennyLaneAI/pennylane/pull/1898)   [(#1909)](https://github.com/PennyLaneAI/pennylane/pull/1909)\r\n\r\n* The static method `decomposition()`, formerly in the `Operation` class, has   been moved to the base `Operator` class.   [(#1873)](https://github.com/PennyLaneAI/pennylane/pull/1873)\r\n\r\n* `DiagonalOperation` is not a separate subclass any more.   [(#1889)](https://github.com/PennyLaneAI/pennylane/pull/1889)\r\n\r\n  Instead, devices can check for the diagonal   property using attributes:\r\n\r\n  ```python\r\n  from pennylane.ops.qubit.attributes import diagonal_in_z_basis\r\n\r\n  if op in diagonal_in_z_basis:\r\n      # do something\r\n  ```\r\n  Custom operations can be added to this attribute at runtime via   `diagonal_in_z_basis.add(\"MyCustomOp\")`.\r\n\r\n<h3>Bug fixes</h3>\r\n\r\n* Fixes a bug with `qml.probs` when using `default.qubit.jax`.   [(#1998)](https://github.com/PennyLaneAI/pennylane/pull/1998)\r\n\r\n* Fixes a bug where output tensors of a QNode would always be put on the   default GPU with `default.qubit.torch`.   [(#1982)](https://github.com/PennyLaneAI/pennylane/pull/1982)\r\n\r\n* Device test suite doesn't use empty circuits so that it can also   test the IonQ plugin, and it checks if operations are supported in   more places.   [(#1979)](https://github.com/PennyLaneAI/pennylane/pull/1979)\r\n\r\n* Fixes a bug where the metric tensor was computed incorrectly when using   gates with `gate.inverse=True`.   [(#1987)](https://github.com/PennyLaneAI/pennylane/pull/1987)\r\n\r\n* Corrects the documentation of `qml.transforms.classical_jacobian`   for the Autograd interface (and improves test coverage).   [(#1978)](https://github.com/PennyLaneAI/pennylane/pull/1978)\r\n\r\n* Fixes a bug where differentiating a QNode with `qml.state` using the JAX   interface raised an error.   [(#1906)](https://github.com/PennyLaneAI/pennylane/pull/1906)\r\n\r\n* Fixes a bug with the adjoint of `qml.QFT`.   [(#1955)](https://github.com/PennyLaneAI/pennylane/pull/1955)\r\n\r\n* Fixes a bug where the `ApproxTimeEvolution` template was not correctly   computing the operation wires from the input Hamiltonian. This did not   affect computation with the `ApproxTimeEvolution` template, but did   cause circuit drawing to fail.   [(#1952)](https://github.com/PennyLaneAI/pennylane/pull/1952)\r\n\r\n* Fixes a bug where the classical preprocessing Jacobian   computed by `qml.transforms.classical_jacobian` with JAX   returned a reduced submatrix of the Jacobian.   [(#1948)](https://github.com/PennyLaneAI/pennylane/pull/1948)\r\n\r\n* Fixes a bug where the operations are not accessed in the correct order   in `qml.fourier.qnode_spectrum`, leading to wrong outputs.   [(#1935)](https://github.com/PennyLaneAI/pennylane/pull/1935)\r\n\r\n* Fixes several Pylint errors.   [(#1951)](https://github.com/PennyLaneAI/pennylane/pull/1951)\r\n\r\n* Fixes a bug where the device test suite wasn't testing certain operations.   [(#1943)](https://github.com/PennyLaneAI/pennylane/pull/1943)\r\n\r\n* Fixes a bug where batch transforms would mutate a QNodes execution options.   [(#1934)](https://github.com/PennyLaneAI/pennylane/pull/1934)\r\n\r\n* `qml.draw` now supports arbitrary templates with matrix parameters.   [(#1917)](https://github.com/PennyLaneAI/pennylane/pull/1917)\r\n\r\n* `QuantumTape.trainable_params` now is a list instead of a set, making   it more stable in very rare edge cases.   [(#1904)](https://github.com/PennyLaneAI/pennylane/pull/1904)\r\n\r\n* `ExpvalCost` now returns corrects results shape when `optimize=True` with   shots batch.   [(#1897)](https://github.com/PennyLaneAI/pennylane/pull/1897)\r\n\r\n* `qml.circuit_drawer.MPLDrawer` was slightly modified to work with   matplotlib version 3.5.   [(#1899)](https://github.com/PennyLaneAI/pennylane/pull/1899)\r\n\r\n* `qml.CSWAP` and `qml.CRot` now define `control_wires`, and `qml.SWAP`   returns the default empty wires object.   [(#1830)](https://github.com/PennyLaneAI/pennylane/pull/1830)\r\n\r\n* The `requires_grad` attribute of `qml.numpy.tensor` objects is now   preserved when pickling/unpickling the object.   [(#1856)](https://github.com/PennyLaneAI/pennylane/pull/1856)\r\n\r\n* Device tests no longer throw warnings about the `requires_grad`   attribute of variational parameters.   [(#1913)](https://github.com/PennyLaneAI/pennylane/pull/1913)\r\n\r\n* `AdamOptimizer` and `AdagradOptimizer` had small fixes to their   optimization step updates.   [(#1929)](https://github.com/PennyLaneAI/pennylane/pull/1929)\r\n\r\n* Fixes a bug where differentiating a QNode with multiple array   arguments via `qml.gradients.param_shift` throws an error.   [(#1989)](https://github.com/PennyLaneAI/pennylane/pull/1989)\r\n\r\n* `AmplitudeEmbedding` template no longer produces a `ComplexWarning`   when the `features` parameter is batched and provided as a 2D array.   [(#1990)](https://github.com/PennyLaneAI/pennylane/pull/1990)\r\n\r\n* `qml.circuit_drawer.CircuitDrawer` no longer produces an error   when attempting to draw tapes inside of circuits (e.g. from   decomposition of an operation or manual placement).   [(#1994)](https://github.com/PennyLaneAI/pennylane/pull/1994)\r\n\r\n* Fixes a bug where using SciPy sparse matrices with the new QNode   could lead to a warning being raised about prioritizing the TensorFlow   and PyTorch interfaces.   [(#2001)](https://github.com/PennyLaneAI/pennylane/pull/2001)\r\n\r\n* Fixed a bug where the `QueueContext` was not empty when first importing PennyLane.   [(#1957)](https://github.com/PennyLaneAI/pennylane/pull/1957)\r\n\r\n* Fixed circuit drawing problem with `Interferometer` and `CVNeuralNet`.   [(#1953)](https://github.com/PennyLaneAI/pennylane/pull/1953)\r\n\r\n<h3>Documentation</h3>\r\n\r\n* Added examples in documentation for some operations.   [(#1902)](https://github.com/PennyLaneAI/pennylane/pull/1902)\r\n\r\n* Improves the Developer's Guide Testing document.   [(#1896)](https://github.com/PennyLaneAI/pennylane/pull/1896)\r\n\r\n* Added documentation examples for `AngleEmbedding`, `BasisEmbedding`, `StronglyEntanglingLayers`,   `SqueezingEmbedding`, `DisplacementEmbedding`, `MottonenStatePreparation` and `Interferometer`.   [(#1910)](https://github.com/PennyLaneAI/pennylane/pull/1910)   [(#1908)](https://github.com/PennyLaneAI/pennylane/pull/1908)   [(#1912)](https://github.com/PennyLaneAI/pennylane/pull/1912)   [(#1920)](https://github.com/PennyLaneAI/pennylane/pull/1920)   [(#1936)](https://github.com/PennyLaneAI/pennylane/pull/1936)   [(#1937)](https://github.com/PennyLaneAI/pennylane/pull/1937)\r\n\r\n<h3>Contributors</h3>\r\n\r\nThis release contains contributions from (in alphabetical order):\r\n\r\nCatalina Albornoz, Guillermo Alonso-Linaje, Juan Miguel Arrazola, Ali Asadi, Utkarsh Azad, Samuel Banning, Benjamin Cordier, Alain Delgado, Olivia Di Matteo, Anthony Hayes, David Ittah, Josh Izaac, Soran Jahangiri, Jalani Kanem, Ankit Khandelwal, Nathan Killoran, Shumpei Kobayashi, Robert Lang, Christina Lee, Cedric Lin, Alejandro Montanez, Romain Moyard, Lee James O'Riordan, Chae-Yeun Park, Isidor Schoch, Maria Schuld, Jay Soni, Antal Sz\u00e1va, Rodrigo Vargas, David Wierichs, Roeland Wiersema, Moritz Willmann"}
{"url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/54039703", "assets_url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/54039703/assets", "upload_url": "https://uploads.github.com/repos/PennyLaneAI/pennylane/releases/54039703/assets{?name,label}", "html_url": "https://github.com/PennyLaneAI/pennylane/releases/tag/v0.19.1", "id": 54039703, "author": {"login": "antalszava", "id": 24476053, "node_id": "MDQ6VXNlcjI0NDc2MDUz", "avatar_url": "https://avatars.githubusercontent.com/u/24476053?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antalszava", "html_url": "https://github.com/antalszava", "followers_url": "https://api.github.com/users/antalszava/followers", "following_url": "https://api.github.com/users/antalszava/following{/other_user}", "gists_url": "https://api.github.com/users/antalszava/gists{/gist_id}", "starred_url": "https://api.github.com/users/antalszava/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antalszava/subscriptions", "organizations_url": "https://api.github.com/users/antalszava/orgs", "repos_url": "https://api.github.com/users/antalszava/repos", "events_url": "https://api.github.com/users/antalszava/events{/privacy}", "received_events_url": "https://api.github.com/users/antalszava/received_events", "type": "User", "site_admin": false}, "node_id": "RE_kwDOB76r6M4DOJSX", "tag_name": "v0.19.1", "target_commitish": "v0.19.1-rc0", "name": "Release 0.19.1", "draft": false, "prerelease": false, "created_at": "2021-11-25T01:48:52Z", "published_at": "2021-11-25T06:56:45Z", "assets": [], "tarball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/tarball/v0.19.1", "zipball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/zipball/v0.19.1", "body": "<h3>Bug fixes</h3>\r\n\r\n* Fixes several bugs when using parametric operations with the `default.qubit.torch` device on GPU. The device takes the `torch_device` argument once again to allow running non-parametric QNodes on the GPU. [(#1927)](https://github.com/PennyLaneAI/pennylane/pull/1927)\r\n\r\n* Fixes a bug where using JAX's jit function on certain QNodes that contain the `qml.QubitStateVector` operation raised an error with earlier JAX versions (e.g., `jax==0.2.10` and `jaxlib==0.1.64`). [(#1924)](https://github.com/PennyLaneAI/pennylane/pull/1924)\r\n\r\n<h3>Contributors</h3>\r\n\r\nThis release contains contributions from (in alphabetical order):\r\n\r\nJosh Izaac, Christina Lee, Romain Moyard, Lee James O'Riordan, Antal Sz\u00e1va."}
{"url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/52961724", "assets_url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/52961724/assets", "upload_url": "https://uploads.github.com/repos/PennyLaneAI/pennylane/releases/52961724/assets{?name,label}", "html_url": "https://github.com/PennyLaneAI/pennylane/releases/tag/v0.19.0", "id": 52961724, "author": {"login": "antalszava", "id": 24476053, "node_id": "MDQ6VXNlcjI0NDc2MDUz", "avatar_url": "https://avatars.githubusercontent.com/u/24476053?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antalszava", "html_url": "https://github.com/antalszava", "followers_url": "https://api.github.com/users/antalszava/followers", "following_url": "https://api.github.com/users/antalszava/following{/other_user}", "gists_url": "https://api.github.com/users/antalszava/gists{/gist_id}", "starred_url": "https://api.github.com/users/antalszava/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antalszava/subscriptions", "organizations_url": "https://api.github.com/users/antalszava/orgs", "repos_url": "https://api.github.com/users/antalszava/repos", "events_url": "https://api.github.com/users/antalszava/events{/privacy}", "received_events_url": "https://api.github.com/users/antalszava/received_events", "type": "User", "site_admin": false}, "node_id": "RE_kwDOB76r6M4DKCG8", "tag_name": "v0.19.0", "target_commitish": "v0.19.0-rc0", "name": "Release 0.19.0", "draft": false, "prerelease": false, "created_at": "2021-11-09T00:25:06Z", "published_at": "2021-11-09T05:24:20Z", "assets": [], "tarball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/tarball/v0.19.0", "zipball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/zipball/v0.19.0", "body": "<h3>New features since last release</h3>\r\n\r\n<h4>Differentiable Hartree-Fock solver</h4>\r\n\r\n* A differentiable Hartree-Fock (HF) solver has been added. It can be used to construct molecular   Hamiltonians that can be differentiated with respect to nuclear coordinates and basis-set   parameters. [(#1610)](https://github.com/PennyLaneAI/pennylane/pull/1610)\r\n\r\n  The HF solver computes the integrals over basis functions, constructs the relevant matrices, and   performs self-consistent-field iterations to obtain a set of optimized molecular orbital   coefficients. These coefficients and the computed integrals over basis functions are used to   construct the one- and two-body electron integrals in the molecular orbital basis which can be   used to generate a differentiable second-quantized Hamiltonian in the fermionic and qubit basis.\r\n\r\n  The following code shows the construction of the Hamiltonian for the hydrogen molecule where the   geometry of the molecule is differentiable.\r\n\r\n  ```python\r\n  symbols = [\"H\", \"H\"]\r\n  geometry = np.array([[0.0000000000, 0.0000000000, -0.6943528941],\r\n                       [0.0000000000, 0.0000000000,  0.6943528941]], requires_grad=True)\r\n\r\n  mol = qml.hf.Molecule(symbols, geometry)\r\n  args_mol = [geometry]\r\n\r\n  hamiltonian = qml.hf.generate_hamiltonian(mol)(*args_mol)\r\n  ```\r\n  ```pycon\r\n  >>> hamiltonian.coeffs\r\n  tensor([-0.09041082+0.j,  0.17220382+0.j,  0.17220382+0.j,\r\n           0.16893367+0.j,  0.04523101+0.j, -0.04523101+0.j,\r\n          -0.04523101+0.j,  0.04523101+0.j, -0.22581352+0.j,\r\n           0.12092003+0.j, -0.22581352+0.j,  0.16615103+0.j,\r\n           0.16615103+0.j,  0.12092003+0.j,  0.17464937+0.j], requires_grad=True)\r\n  ```\r\n\r\n  The generated Hamiltonian can be used in a circuit where the atomic   coordinates and circuit parameters are optimized simultaneously.\r\n\r\n  ```python\r\n  symbols = [\"H\", \"H\"]\r\n  geometry = np.array([[0.0000000000, 0.0000000000, 0.0],\r\n                       [0.0000000000, 0.0000000000, 2.0]], requires_grad=True)\r\n\r\n  mol = qml.hf.Molecule(symbols, geometry)\r\n\r\n  dev = qml.device(\"default.qubit\", wires=4)\r\n  params = [np.array([0.0], requires_grad=True)]\r\n\r\n  def generate_circuit(mol):\r\n      @qml.qnode(dev)\r\n      def circuit(*args):\r\n          qml.BasisState(np.array([1, 1, 0, 0]), wires=[0, 1, 2, 3])\r\n          qml.DoubleExcitation(*args[0][0], wires=[0, 1, 2, 3])\r\n          return qml.expval(qml.hf.generate_hamiltonian(mol)(*args[1:]))\r\n      return circuit\r\n\r\n  for n in range(25):\r\n\r\n      mol = qml.hf.Molecule(symbols, geometry)\r\n      args = [params, geometry] # initial values of the differentiable parameters\r\n\r\n      g_params = qml.grad(generate_circuit(mol), argnum = 0)(*args)\r\n      params = params - 0.5 * g_params[0]\r\n\r\n      forces = qml.grad(generate_circuit(mol), argnum = 1)(*args)\r\n      geometry = geometry - 0.5 * forces\r\n\r\n      print(f'Step: {n}, Energy: {generate_circuit(mol)(*args)}, Maximum Force: {forces.max()}')\r\n  ```\r\n  In addition, the new Hartree-Fock solver can further be used to optimize the   basis set parameters. For details, please refer to the [differentiable   Hartree-Fock solver   documentation](https://pennylane.readthedocs.io/en/latest/code/qml_hf.html#using-the-differentiable-hf-solver).\r\n\r\n<h4>Integration with Mitiq</h4>\r\n\r\n* Error mitigation using the zero-noise extrapolation method is now available through the   `transforms.mitigate_with_zne` transform. This transform can integrate with the   [Mitiq](https://mitiq.readthedocs.io/en/stable/) package for unitary folding and extrapolation   functionality.   [(#1813)](https://github.com/PennyLaneAI/pennylane/pull/1813)\r\n\r\n  Consider the following noisy device:\r\n\r\n  ```python\r\n  noise_strength = 0.05\r\n  dev = qml.device(\"default.mixed\", wires=2)\r\n  dev = qml.transforms.insert(qml.AmplitudeDamping, noise_strength)(dev)\r\n  ```\r\n\r\n  We can mitigate the effects of this noise for circuits run on this device by using the added\r\n  transform:\r\n\r\n  ```python\r\n  from mitiq.zne.scaling import fold_global\r\n  from mitiq.zne.inference import RichardsonFactory\r\n\r\n  n_wires = 2\r\n  n_layers = 2\r\n\r\n  shapes = qml.SimplifiedTwoDesign.shape(n_wires, n_layers)\r\n  np.random.seed(0)\r\n  w1, w2 = [np.random.random(s) for s in shapes]\r\n\r\n  @qml.transforms.mitigate_with_zne([1, 2, 3], fold_global, RichardsonFactory.extrapolate)\r\n  @qml.beta.qnode(dev)\r\n  def circuit(w1, w2):\r\n      qml.SimplifiedTwoDesign(w1, w2, wires=range(2))\r\n      return qml.expval(qml.PauliZ(0))\r\n  ```\r\n\r\n  Now, when we execute `circuit`, errors will be automatically mitigated:\r\n\r\n  ```pycon\r\n  >>> circuit(w1, w2)\r\n  0.19113067083636542\r\n  ```\r\n\r\n<h4>Powerful new transforms</h4>\r\n\r\n* The unitary matrix corresponding to a quantum circuit can now be generated using the new   `get_unitary_matrix()` transform.   [(#1609)](https://github.com/PennyLaneAI/pennylane/pull/1609)   [(#1786)](https://github.com/PennyLaneAI/pennylane/pull/1786)\r\n\r\n  This transform is fully differentiable across all supported PennyLane autodiff frameworks.\r\n\r\n  ```python\r\n  def circuit(theta):\r\n      qml.RX(theta, wires=1)\r\n      qml.PauliZ(wires=0)\r\n      qml.CNOT(wires=[0, 1])\r\n  ```\r\n\r\n  ```pycon\r\n  >>> theta = torch.tensor(0.3, requires_grad=True)\r\n  >>> matrix = qml.transforms.get_unitary_matrix(circuit)(theta)\r\n  >>> print(matrix)\r\n  tensor([[ 0.9888+0.0000j,  0.0000+0.0000j,  0.0000-0.1494j,  0.0000+0.0000j],\r\n        [ 0.0000+0.0000j,  0.0000+0.1494j,  0.0000+0.0000j, -0.9888+0.0000j],\r\n        [ 0.0000-0.1494j,  0.0000+0.0000j,  0.9888+0.0000j,  0.0000+0.0000j],\r\n        [ 0.0000+0.0000j, -0.9888+0.0000j,  0.0000+0.0000j,  0.0000+0.1494j]],\r\n       grad_fn=<MmBackward>)\r\n  >>> loss = torch.real(torch.trace(matrix))\r\n  >>> loss.backward()\r\n  >>> theta.grad\r\n  tensor(-0.1494)\r\n  ```\r\n\r\n* Arbitrary two-qubit unitaries can now be decomposed into elementary gates. This   functionality has been incorporated into the `qml.transforms.unitary_to_rot` transform, and is   available separately as `qml.transforms.two_qubit_decomposition`.   [(#1552)](https://github.com/PennyLaneAI/pennylane/pull/1552)\r\n\r\n  As an example, consider the following randomly-generated matrix and circuit that uses it:\r\n\r\n  ```python\r\n  U = np.array([\r\n      [-0.03053706-0.03662692j,  0.01313778+0.38162226j, 0.4101526 -0.81893687j, -0.03864617+0.10743148j],\r\n      [-0.17171136-0.24851809j,  0.06046239+0.1929145j, -0.04813084-0.01748555j, -0.29544883-0.88202604j],\r\n      [ 0.39634931-0.78959795j, -0.25521689-0.17045233j, -0.1391033 -0.09670952j, -0.25043606+0.18393466j],\r\n      [ 0.29599198-0.19573188j,  0.55605806+0.64025769j, 0.06140516+0.35499559j,  0.02674726+0.1563311j ]\r\n  ])\r\n\r\n  dev = qml.device('default.qubit', wires=2)\r\n\r\n  @qml.qnode(dev)\r\n  @qml.transforms.unitary_to_rot\r\n  def circuit(x, y):\r\n      qml.QubitUnitary(U, wires=[0, 1])\r\n      return qml.expval(qml.PauliZ(wires=0))\r\n  ```\r\n\r\n  If we run the circuit, we can see the new decomposition:\r\n\r\n  ```pycon\r\n  >>> circuit(0.3, 0.4)\r\n  tensor(-0.81295986, requires_grad=True)\r\n  >>> print(qml.draw(circuit)(0.3, 0.4))\r\n  0: \u2500\u2500Rot(2.78, 0.242, -2.28)\u2500\u2500\u256dX\u2500\u2500RZ(0.176)\u2500\u2500\u2500\u256dC\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256dX\u2500\u2500Rot(-3.87, 0.321, -2.09)\u2500\u2500\u2524 \u27e8Z\u27e9\r\n  1: \u2500\u2500Rot(4.64, 2.69, -1.56)\u2500\u2500\u2500\u2570C\u2500\u2500RY(-0.883)\u2500\u2500\u2570X\u2500\u2500RY(-1.47)\u2500\u2500\u2570C\u2500\u2500Rot(1.68, 0.337, 0.587)\u2500\u2500\u2500\u2524\r\n  ```\r\n\r\n* A new transform, `@qml.batch_params`, has been added, that makes QNodes   handle a batch dimension in trainable parameters.   [(#1710)](https://github.com/PennyLaneAI/pennylane/pull/1710)   [(#1761)](https://github.com/PennyLaneAI/pennylane/pull/1761)\r\n\r\n  This transform will create multiple circuits, one per batch dimension.   As a result, it is both simulator and hardware compatible.\r\n\r\n  ```python\r\n  @qml.batch_params\r\n  @qml.beta.qnode(dev)\r\n  def circuit(x, weights):\r\n      qml.RX(x, wires=0)\r\n      qml.RY(0.2, wires=1)\r\n      qml.templates.StronglyEntanglingLayers(weights, wires=[0, 1, 2])\r\n      return qml.expval(qml.Hadamard(0))\r\n  ```\r\n\r\n  The `qml.batch_params` decorator allows us to pass arguments `x` and `weights`   that have a batch dimension. For example,\r\n\r\n  ```pycon\r\n  >>> batch_size = 3\r\n  >>> x = np.linspace(0.1, 0.5, batch_size)\r\n  >>> weights = np.random.random((batch_size, 10, 3, 3))\r\n  ```\r\n\r\n  If we evaluate the QNode with these inputs, we will get an output   of shape ``(batch_size,)``:\r\n\r\n  ```pycon\r\n  >>> circuit(x, weights)\r\n  tensor([0.08569816, 0.12619101, 0.21122004], requires_grad=True)\r\n  ```\r\n\r\n* The `insert` transform has now been added, providing a way to insert single-qubit operations into   a quantum circuit. The transform can apply to quantum functions, tapes, and devices.   [(#1795)](https://github.com/PennyLaneAI/pennylane/pull/1795)\r\n\r\n  The following QNode can be transformed to add noise to the circuit:\r\n\r\n  ```python\r\n  dev = qml.device(\"default.mixed\", wires=2)\r\n\r\n  @qml.qnode(dev)\r\n  @qml.transforms.insert(qml.AmplitudeDamping, 0.2, position=\"end\")\r\n  def f(w, x, y, z):\r\n      qml.RX(w, wires=0)\r\n      qml.RY(x, wires=1)\r\n      qml.CNOT(wires=[0, 1])\r\n      qml.RY(y, wires=0)\r\n      qml.RX(z, wires=1)\r\n      return qml.expval(qml.PauliZ(0) @ qml.PauliZ(1))\r\n  ```\r\n\r\n  Executions of this circuit will differ from the noise-free value:\r\n\r\n  ```pycon\r\n  >>> f(0.9, 0.4, 0.5, 0.6)\r\n  tensor(0.754847, requires_grad=True)\r\n  >>> print(qml.draw(f)(0.9, 0.4, 0.5, 0.6))\r\n   0: \u2500\u2500RX(0.9)\u2500\u2500\u256dC\u2500\u2500RY(0.5)\u2500\u2500AmplitudeDamping(0.2)\u2500\u2500\u256d\u2524 \u27e8Z \u2297 Z\u27e9\r\n   1: \u2500\u2500RY(0.4)\u2500\u2500\u2570X\u2500\u2500RX(0.6)\u2500\u2500AmplitudeDamping(0.2)\u2500\u2500\u2570\u2524 \u27e8Z \u2297 Z\u27e9\r\n  ```\r\n\r\n* Common tape expansion functions are now available in `qml.transforms`,   alongside a new `create_expand_fn` function for easily creating expansion functions   from stopping criteria.   [(#1734)](https://github.com/PennyLaneAI/pennylane/pull/1734)   [(#1760)](https://github.com/PennyLaneAI/pennylane/pull/1760)\r\n\r\n  `create_expand_fn` takes the default depth to which the expansion function   should expand a tape, a stopping criterion, an optional device, and a docstring to be set for the   created function.   The stopping criterion must take a queuable object and return a boolean.\r\n\r\n  For example, to create an expansion function that decomposes all trainable,   multi-parameter operations:\r\n\r\n  ```python\r\n  >>> stop_at = ~(qml.operation.has_multipar & qml.operation.is_trainable)\r\n  >>> expand_fn = qml.transforms.create_expand_fn(depth=5, stop_at=stop_at)\r\n  ```\r\n\r\n  The created expansion function can be used within a custom transform. Devices can also be provided, producing expansion functions that decompose   tapes to support the native gate set of the device.\r\n\r\n<h4>Batch execution of circuits</h4>\r\n\r\n* A new, experimental QNode has been added, that adds support for batch execution of circuits,   custom quantum gradient support, and arbitrary order derivatives. This QNode is available via   `qml.beta.QNode`, and `@qml.beta.qnode`.   [(#1642)](https://github.com/PennyLaneAI/pennylane/pull/1642)   [(#1646)](https://github.com/PennyLaneAI/pennylane/pull/1646)   [(#1651)](https://github.com/PennyLaneAI/pennylane/pull/1651)   [(#1804)](https://github.com/PennyLaneAI/pennylane/pull/1804)\r\n\r\n  It differs from the standard QNode in several ways:\r\n\r\n  - Custom gradient transforms can be specified as the differentiation method:\r\n\r\n    ```python\r\n    @qml.gradients.gradient_transform\r\n    def my_gradient_transform(tape):\r\n        ...\r\n        return tapes, processing_fn\r\n\r\n    @qml.beta.qnode(dev, diff_method=my_gradient_transform)\r\n    def circuit():\r\n    ```\r\n\r\n  - Arbitrary :math:`n`-th order derivatives are supported on hardware using gradient transforms such as the parameter-shift rule. To specify that an :math:`n`-th order derivative of a QNode will be computed, the `max_diff` argument should be set.     By default, this is set to 1 (first-order derivatives only).\r\n\r\n  - Internally, if multiple circuits are generated for execution simultaneously, they     will be packaged into a single job for execution on the device. This can lead to     significant performance improvement when executing the QNode on remote     quantum hardware.\r\n\r\n  - When decomposing the circuit, the default decomposition strategy will prioritize     decompositions that result in the smallest number of parametrized operations     required to satisfy the differentiation method. Additional decompositions required     to satisfy the native gate set of the quantum device will be performed later, by the     device at execution time. While this may lead to a slight increase in classical processing,     it significantly reduces the number of circuit evaluations needed to compute     gradients of complex unitaries.\r\n\r\n  In an upcoming release, this QNode will replace the existing one. If you come across any bugs   while using this QNode, please let us know via a [bug   report](https://github.com/PennyLaneAI/pennylane/issues/new?assignees=&labels=bug+%3Abug%3A&template=bug_report.yml&title=%5BBUG%5D)   on our GitHub bug tracker.\r\n\r\n  Currently, this beta QNode does not support the following features:\r\n\r\n  - Non-mutability via the `mutable` keyword argument\r\n  - The `reversible` QNode differentiation method\r\n  - The ability to specify a `dtype` when using PyTorch and TensorFlow.\r\n\r\n  It is also not tested with the `qml.qnn` module.\r\n\r\n<h4>New operations and templates</h4>\r\n\r\n* Added a new operation `OrbitalRotation`, which implements the spin-adapted spatial orbital   rotation gate. [(#1665)](https://github.com/PennyLaneAI/pennylane/pull/1665)\r\n\r\n  An example circuit that uses `OrbitalRotation` operation is:\r\n\r\n  ```python\r\n  dev = qml.device('default.qubit', wires=4)\r\n\r\n  @qml.qnode(dev)\r\n  def circuit(phi):\r\n      qml.BasisState(np.array([1, 1, 0, 0]), wires=[0, 1, 2, 3])\r\n      qml.OrbitalRotation(phi, wires=[0, 1, 2, 3])\r\n      return qml.state()\r\n  ```\r\n\r\n  If we run this circuit, we will get the following output\r\n\r\n  ```pycon\r\n  >>> circuit(0.1)\r\n  array([ 0.        +0.j,  0.        +0.j,  0.        +0.j,\r\n          0.00249792+0.j,  0.        +0.j,  0.        +0.j,\r\n          -0.04991671+0.j,  0.        +0.j,  0.        +0.j,\r\n          -0.04991671+0.j,  0.        +0.j,  0.        +0.j,\r\n          0.99750208+0.j,  0.        +0.j,  0.        +0.j,\r\n          0.        +0.j])\r\n  ```\r\n\r\n* Added a new template `GateFabric`, which implements a local, expressive, quantum-number-preserving   ansatz proposed by Anselmetti *et al.* in [arXiv:2104.05692](https://arxiv.org/abs/2104.05695).   [(#1687)](https://github.com/PennyLaneAI/pennylane/pull/1687)\r\n\r\n  An example of a circuit using `GateFabric` template is:\r\n\r\n  ```python\r\n  coordinates = np.array([0.0, 0.0, -0.6614, 0.0, 0.0, 0.6614])\r\n  H, qubits = qml.qchem.molecular_hamiltonian([\"H\", \"H\"], coordinates)\r\n  ref_state = qml.qchem.hf_state(electrons=2, orbitals=qubits)\r\n\r\n  dev = qml.device('default.qubit', wires=qubits)\r\n\r\n  @qml.qnode(dev)\r\n  def ansatz(weights):\r\n      qml.templates.GateFabric(weights, wires=[0,1,2,3],\r\n                                  init_state=ref_state, include_pi=True)\r\n      return qml.expval(H)\r\n  ```\r\n\r\n  For more details, see the [GateFabric   documentation](https://pennylane.readthedocs.io/en/latest/code/api/pennylane.GateFabric.html).\r\n\r\n* Added a new template `kUpCCGSD`, which implements a unitary coupled cluster ansatz with   generalized singles and pair doubles excitation operators, proposed by Joonho Lee *et al.*   in [arXiv:1810.02327](https://arxiv.org/abs/1810.02327).   [(#1743)](https://github.com/PennyLaneAI/pennylane/pull/1743)\r\n\r\n  An example of a circuit using `kUpCCGSD` template is:\r\n\r\n  ```python\r\n  coordinates = np.array([0.0, 0.0, -0.6614, 0.0, 0.0, 0.6614])\r\n  H, qubits = qml.qchem.molecular_hamiltonian([\"H\", \"H\"], coordinates)\r\n  ref_state = qml.qchem.hf_state(electrons=2, orbitals=qubits)\r\n\r\n  dev = qml.device('default.qubit', wires=qubits)\r\n\r\n  @qml.qnode(dev)\r\n  def ansatz(weights):\r\n      qml.templates.kUpCCGSD(weights, wires=[0,1,2,3], k=0, delta_sz=0,\r\n                                  init_state=ref_state)\r\n      return qml.expval(H)\r\n  ```\r\n\r\n<h4>Improved utilities for quantum compilation and characterization</h4>\r\n\r\n* The new `qml.fourier.qnode_spectrum` function extends the former   `qml.fourier.spectrum` function   and takes classical processing of QNode arguments into account.   The frequencies are computed per (requested) QNode argument instead   of per gate `id`. The gate `id`s are ignored.   [(#1681)](https://github.com/PennyLaneAI/pennylane/pull/1681)   [(#1720)](https://github.com/PennyLaneAI/pennylane/pull/1720)\r\n\r\n  Consider the following example, which uses non-trainable inputs `x`, `y` and `z`   as well as trainable parameters `w` as arguments to the QNode.\r\n\r\n  ```python\r\n  import pennylane as qml\r\n  import numpy as np\r\n\r\n  n_qubits = 3\r\n  dev = qml.device(\"default.qubit\", wires=n_qubits)\r\n\r\n  @qml.qnode(dev)\r\n  def circuit(x, y, z, w):\r\n      for i in range(n_qubits):\r\n          qml.RX(0.5*x[i], wires=i)\r\n          qml.Rot(w[0,i,0], w[0,i,1], w[0,i,2], wires=i)\r\n          qml.RY(2.3*y[i], wires=i)\r\n          qml.Rot(w[1,i,0], w[1,i,1], w[1,i,2], wires=i)\r\n          qml.RX(z, wires=i)\r\n      return qml.expval(qml.PauliZ(wires=0))\r\n\r\n  x = np.array([1., 2., 3.])\r\n  y = np.array([0.1, 0.3, 0.5])\r\n  z = -1.8\r\n  w = np.random.random((2, n_qubits, 3))\r\n  ```\r\n\r\n  This circuit looks as follows:\r\n\r\n  ```pycon\r\n  >>> print(qml.draw(circuit)(x, y, z, w))\r\n  0: \u2500\u2500RX(0.5)\u2500\u2500Rot(0.598, 0.949, 0.346)\u2500\u2500\u2500RY(0.23)\u2500\u2500Rot(0.693, 0.0738, 0.246)\u2500\u2500RX(-1.8)\u2500\u2500\u2524 \u27e8Z\u27e9\r\n  1: \u2500\u2500RX(1)\u2500\u2500\u2500\u2500Rot(0.0711, 0.701, 0.445)\u2500\u2500RY(0.69)\u2500\u2500Rot(0.32, 0.0482, 0.437)\u2500\u2500\u2500RX(-1.8)\u2500\u2500\u2524\r\n  2: \u2500\u2500RX(1.5)\u2500\u2500Rot(0.401, 0.0795, 0.731)\u2500\u2500RY(1.15)\u2500\u2500Rot(0.756, 0.38, 0.38)\u2500\u2500\u2500\u2500\u2500RX(-1.8)\u2500\u2500\u2524\r\n  ```\r\n\r\n  Applying the `qml.fourier.qnode_spectrum` function to the circuit for the non-trainable   parameters, we obtain:\r\n\r\n  ```pycon\r\n  >>> spec = qml.fourier.qnode_spectrum(circuit, encoding_args={\"x\", \"y\", \"z\"})(x, y, z, w)\r\n  >>> for inp, freqs in spec.items():\r\n  ...     print(f\"{inp}: {freqs}\")\r\n  \"x\": {(0,): [-0.5, 0.0, 0.5], (1,): [-0.5, 0.0, 0.5], (2,): [-0.5, 0.0, 0.5]}\r\n  \"y\": {(0,): [-2.3, 0.0, 2.3], (1,): [-2.3, 0.0, 2.3], (2,): [-2.3, 0.0, 2.3]}\r\n  \"z\": {(): [-3.0, -2.0, -1.0, 0.0, 1.0, 2.0, 3.0]}\r\n  ```\r\n\r\n  We can see that all three parameters in the QNode arguments ``x`` and ``y``   contribute the spectrum of a Pauli rotation ``[-1.0, 0.0, 1.0]``, rescaled with the   prefactor of the respective parameter in the circuit.   The three ``RX`` rotations using the parameter ``z`` accumulate, yielding a more   complex frequency spectrum.\r\n\r\n  For details on how to control for which parameters the spectrum is computed,   a comparison to `qml.fourier.circuit_spectrum`, and other usage details, please see the   [fourier.qnode_spectrum docstring](https://pennylane.readthedocs.io/en/latest/code/api/pennylane.fourier.qnode_spectrum.html).\r\n\r\n* Two new methods were added to the Device API, allowing PennyLane devices   increased control over circuit decompositions.   [(#1651)](https://github.com/PennyLaneAI/pennylane/pull/1651)\r\n\r\n  - `Device.expand_fn(tape) -> tape`: expands a tape such that it is supported by the device. By     default, performs the standard device-specific gate set decomposition done in the default     QNode. Devices may overwrite this method in order to define their own decomposition logic.\r\n\r\n    Note that the numerical result after applying this method should remain unchanged; PennyLane     will assume that the expanded tape returns exactly the same value as the original tape when     executed.\r\n\r\n  - `Device.batch_transform(tape) -> (tapes, processing_fn)`: preprocesses the tape in the case     where the device needs to generate multiple circuits to execute from the input circuit. The     requirement of a post-processing function makes this distinct to the `expand_fn` method above.\r\n\r\n    By default, this method applies the transform\r\n\r\n    .. math:: \\left\\langle \\sum_i c_i h_i\\right\\rangle \u2192 \\sum_i c_i \\left\\langle h_i \\right\\rangle\r\n\r\n    if `expval(H)` is present on devices that do not natively support Hamiltonians with     non-commuting terms.\r\n\r\n* A new class has been added to store operator attributes, such as `self_inverses`,   and `composable_rotation`, as a list of operation names.   [(#1763)](https://github.com/PennyLaneAI/pennylane/pull/1763)\r\n\r\n  A number of such attributes, for the purpose of compilation transforms, can be found   in `ops/qubit/attributes.py`, but the class can also be used to create your own. For   example, we can create a new Attribute, `pauli_ops`, like so:\r\n\r\n  ```pycon\r\n  >>> from pennylane.ops.qubit.attributes import Attribute\r\n  >>> pauli_ops = Attribute([\"PauliX\", \"PauliY\", \"PauliZ\"])\r\n  ```\r\n\r\n  We can check either a string or an Operation for inclusion in this set:\r\n\r\n  ```pycon\r\n  >>> qml.PauliX(0) in pauli_ops\r\n  True\r\n  >>> \"Hadamard\" in pauli_ops\r\n  False\r\n  ```\r\n\r\n  We can also dynamically add operators to the sets at runtime. This is useful for adding custom operations to the attributes such as `composable_rotations`   and ``self_inverses`` that are used in compilation transforms. For example,   suppose you have created a new Operation, `MyGate`, which you know to be its   own inverse. Adding it to the set, like so\r\n\r\n  ```pycon\r\n  >>> from pennylane.ops.qubit.attributes import self_inverses\r\n  >>> self_inverses.add(\"MyGate\")\r\n  ```\r\n\r\n  will enable the gate to be considered by the `cancel_inverses` compilation   transform if two such gates are adjacent in a circuit.\r\n\r\n<h3>Improvements</h3>\r\n\r\n* The `qml.metric_tensor` transform has been improved with regards to   both function and performance.   [(#1638)](https://github.com/PennyLaneAI/pennylane/pull/1638)   [(#1721)](https://github.com/PennyLaneAI/pennylane/pull/1721)\r\n\r\n  - If the underlying device supports batch execution of circuits, the quantum circuits required to     compute the metric tensor elements will be automatically submitted as a batched job. This can     lead to significant performance improvements for devices with a non-trivial job submission     overhead.\r\n\r\n  - Previously, the transform would only return the metric tensor with respect to gate arguments,     and ignore any classical processing inside the QNode, even very trivial classical processing     such as parameter permutation. The metric tensor now takes into account classical processing,     and returns the metric tensor with respect to QNode arguments, not simply gate arguments:\r\n\r\n    ```pycon\r\n    >>> @qml.qnode(dev)\r\n    ... def circuit(x):\r\n    ...     qml.Hadamard(wires=1)\r\n    ...     qml.RX(x[0], wires=0)\r\n    ...     qml.CNOT(wires=[0, 1])\r\n    ...     qml.RY(x[1] ** 2, wires=1)\r\n    ...     qml.RY(x[1], wires=0)\r\n    ...     return qml.expval(qml.PauliZ(0))\r\n    >>> x = np.array([0.1, 0.2], requires_grad=True)\r\n    >>> qml.metric_tensor(circuit)(x)\r\n    array([[0.25      , 0.        ],\r\n           [0.        , 0.28750832]])\r\n    ```\r\n\r\n    To revert to the previous behaviour of returning the metric tensor with respect to gate     arguments, `qml.metric_tensor(qnode, hybrid=False)` can be passed.\r\n\r\n    ```pycon\r\n    >>> qml.metric_tensor(circuit, hybrid=False)(x)\r\n    array([[0.25      , 0.        , 0.        ],\r\n           [0.        , 0.25      , 0.        ],\r\n           [0.        , 0.        , 0.24750832]])\r\n    ```\r\n\r\n  - The metric tensor transform now works with a larger set of operations. In particular,     all operations that have a single variational parameter and define a generator are now\r\n    supported. In addition to a reduction in decomposition overhead, the change     also results in fewer circuit evaluations.\r\n\r\n* The expansion rule in the `qml.metric_tensor` transform has been changed.   [(#1721)](https://github.com/PennyLaneAI/pennylane/pull/1721)\r\n\r\n  If `hybrid=False`, the changed expansion rule might lead to a changed output.\r\n\r\n* The `ApproxTimeEvolution` template can now be used with Hamiltonians that have   trainable coefficients.   [(#1789)](https://github.com/PennyLaneAI/pennylane/pull/1789)\r\n\r\n  The resulting QNodes can be differentiated with respect to both the time parameter   *and* the Hamiltonian coefficients.\r\n\r\n  ```python\r\n  dev = qml.device('default.qubit', wires=2)\r\n  obs = [qml.PauliX(0) @ qml.PauliY(1), qml.PauliY(0) @ qml.PauliX(1)]\r\n\r\n  @qml.qnode(dev)\r\n  def circuit(coeffs, t):\r\n      H = qml.Hamiltonian(coeffs, obs)\r\n      qml.templates.ApproxTimeEvolution(H, t, 2)\r\n      return qml.expval(qml.PauliZ(0))\r\n  ```\r\n\r\n  ```pycon\r\n  >>> t = np.array(0.54, requires_grad=True)\r\n  >>> coeffs = np.array([-0.6, 2.0], requires_grad=True)\r\n  >>> qml.grad(circuit)(coeffs, t)\r\n  (array([-1.07813375, -1.07813375]), array(-2.79516158))\r\n  ```\r\n\r\n  All differentiation methods, including backpropagation and the parameter-shift   rule, are supported.\r\n\r\n* Quantum function transforms and batch transforms can now be applied to devices.   Once applied to a device, any quantum function executed on the   modified device will be transformed prior to execution.   [(#1809)](https://github.com/PennyLaneAI/pennylane/pull/1809)   [(#1810)](https://github.com/PennyLaneAI/pennylane/pull/1810)\r\n\r\n  ```python\r\n  dev = qml.device(\"default.mixed\", wires=1)\r\n  dev = qml.transforms.merge_rotations()(dev)\r\n\r\n  @qml.beta.qnode(dev)\r\n  def f(w, x, y, z):\r\n      qml.RX(w, wires=0)\r\n      qml.RX(x, wires=0)\r\n      qml.RX(y, wires=0)\r\n      qml.RX(z, wires=0)\r\n      return qml.expval(qml.PauliZ(0))\r\n  ```\r\n\r\n  ```pycon\r\n  >>> print(f(0.9, 0.4, 0.5, 0.6))\r\n   -0.7373937155412453\r\n  >>> print(qml.draw(f, expansion_strategy=\"device\")(0.9, 0.4, 0.5, 0.6))\r\n   0: \u2500\u2500RX(2.4)\u2500\u2500\u2524 \u27e8Z\u27e9\r\n  ```\r\n\r\n* It is now possible to draw QNodes that have been transformed by a 'batch transform'; that is,   a transform that maps a single QNode into multiple circuits under the hood. Examples of   batch transforms include `@qml.metric_tensor` and `@qml.gradients`.   [(#1762)](https://github.com/PennyLaneAI/pennylane/pull/1762)\r\n\r\n  For example, consider the parameter-shift rule, which generates two circuits per parameter;   one circuit that has the parameter shifted forward, and another that has the parameter shifted   backwards:\r\n\r\n  ```python\r\n  dev = qml.device(\"default.qubit\", wires=2)\r\n\r\n  @qml.gradients.param_shift\r\n  @qml.beta.qnode(dev)\r\n  def circuit(x):\r\n      qml.RX(x, wires=0)\r\n      qml.CNOT(wires=[0, 1])\r\n      return qml.expval(qml.PauliZ(wires=0))\r\n  ```\r\n\r\n  ```pycon\r\n  >>> print(qml.draw(circuit)(0.6))\r\n   0: \u2500\u2500RX(2.17)\u2500\u2500\u256dC\u2500\u2500\u2524 \u27e8Z\u27e9\r\n   1: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2570X\u2500\u2500\u2524\r\n\r\n   0: \u2500\u2500RX(-0.971)\u2500\u2500\u256dC\u2500\u2500\u2524 \u27e8Z\u27e9\r\n   1: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2570X\u2500\u2500\u2524\r\n  ```\r\n\r\n* Support for differentiable execution of batches of circuits has been   extended to the JAX interface for scalar functions, via the beta   `pennylane.interfaces.batch` module.   [(#1634)](https://github.com/PennyLaneAI/pennylane/pull/1634)   [(#1685)](https://github.com/PennyLaneAI/pennylane/pull/1685)\r\n\r\n  For example using the `execute` function from the `pennylane.interfaces.batch` module:\r\n\r\n  ```python\r\n  from pennylane.interfaces.batch import execute\r\n\r\n  def cost_fn(x):\r\n      with qml.tape.JacobianTape() as tape1:\r\n          qml.RX(x[0], wires=[0])\r\n          qml.RY(x[1], wires=[1])\r\n          qml.CNOT(wires=[0, 1])\r\n          qml.var(qml.PauliZ(0) @ qml.PauliX(1))\r\n\r\n      with qml.tape.JacobianTape() as tape2:\r\n          qml.RX(x[0], wires=0)\r\n          qml.RY(x[0], wires=1)\r\n          qml.CNOT(wires=[0, 1])\r\n          qml.probs(wires=1)\r\n\r\n      result = execute(\r\n        [tape1, tape2], dev,\r\n        gradient_fn=qml.gradients.param_shift,\r\n        interface=\"autograd\"\r\n      )\r\n      return (result[0] + result[1][0, 0])[0]\r\n\r\n  res = jax.grad(cost_fn)(params)\r\n  ```\r\n\r\n* All qubit operations have been re-written to use the `qml.math` framework   for internal classical processing and the generation of their matrix representations.   As a result these representations are now fully differentiable, and the   framework-specific device classes no longer need to maintain framework-specific   versions of these matrices.   [(#1749)](https://github.com/PennyLaneAI/pennylane/pull/1749)   [(#1802)](https://github.com/PennyLaneAI/pennylane/pull/1802)\r\n\r\n* The use of `expval(H)`, where `H` is a cost Hamiltonian generated by the `qaoa` module,   has been sped up. This was achieved by making PennyLane decompose a circuit with an `expval(H)`   measurement into subcircuits if the `Hamiltonian.grouping_indices` attribute is set, and setting   this attribute in the relevant `qaoa` module functions.   [(#1718)](https://github.com/PennyLaneAI/pennylane/pull/1718)\r\n\r\n* Operations can now have gradient recipes that depend on the state of the operation.   [(#1674)](https://github.com/PennyLaneAI/pennylane/pull/1674)\r\n\r\n  For example, this allows for gradient recipes that are parameter dependent:\r\n\r\n  ```python\r\n  class RX(qml.RX):\r\n\r\n      @property\r\n      def grad_recipe(self):\r\n          # The gradient is given by [f(2x) - f(0)] / (2 sin(x)), by subsituting\r\n          # shift = x into the two term parameter-shift rule.\r\n          x = self.data[0]\r\n          c = 0.5 / np.sin(x)\r\n          return ([[c, 0.0, 2 * x], [-c, 0.0, 0.0]],)\r\n  ```\r\n\r\n* Shots can now be passed as a runtime argument to transforms that execute circuits in batches, similarly to QNodes. [(#1707)](https://github.com/PennyLaneAI/pennylane/pull/1707)\r\n\r\n  An example of such a transform are the gradient transforms in the   `qml.gradients` module. As a result, we can now call gradient transforms   (such as `qml.gradients.param_shift`) and set the number of shots at runtime.\r\n\r\n  ```pycon\r\n  >>> dev = qml.device(\"default.qubit\", wires=1, shots=1000)\r\n  >>> @qml.beta.qnode(dev)\r\n  ... def circuit(x):\r\n  ...     qml.RX(x, wires=0)\r\n  ...     return qml.expval(qml.PauliZ(0))\r\n  >>> grad_fn = qml.gradients.param_shift(circuit)\r\n  >>> param = np.array(0.564, requires_grad=True)\r\n  >>> grad_fn(param, shots=[(1, 10)]).T\r\n  array([[-1., -1., -1., -1., -1.,  0., -1.,  0., -1.,  0.]])\r\n  >>> param2 = np.array(0.1233, requires_grad=True)\r\n  >>> grad_fn(param2, shots=None)\r\n  array([[-0.12298782]])\r\n  ```\r\n\r\n* Templates are now top level imported and can be used directly e.g. `qml.QFT(wires=0)`.   [(#1779)](https://github.com/PennyLaneAI/pennylane/pull/1779)\r\n\r\n* `qml.probs` now accepts an attribute `op` that allows to rotate the computational basis and get   the probabilities in the rotated basis.   [(#1692)](https://github.com/PennyLaneAI/pennylane/pull/1692)\r\n\r\n* Refactored the `expand_fn` functionality in the Device class to avoid any   edge cases leading to failures with plugins.   [(#1838)](https://github.com/PennyLaneAI/pennylane/pull/1838)\r\n\r\n* Updated the `qml.QNGOptimizer.step_and_cost` method to avoid the use of   deprecated functionality.   [(#1834)](https://github.com/PennyLaneAI/pennylane/pull/1834)\r\n\r\n* Added a custom `torch.to_numpy` implementation to   `pennylane/math/single_dispatch.py` to ensure compabilitity with   PyTorch 1.10.   [(#1824)](https://github.com/PennyLaneAI/pennylane/pull/1824)   [(#1825)](https://github.com/PennyLaneAI/pennylane/pull/1825)\r\n\r\n* The default for an `Operation`'s `control_wires` attribute is now an empty `Wires`   object instead of the attribute raising a `NonImplementedError`.   [(#1821)](https://github.com/PennyLaneAI/pennylane/pull/1821)\r\n\r\n* `qml.circuit_drawer.MPLDrawer` will now automatically rotate and resize text to fit inside   the rectangle created by the `box_gate` method.   [(#1764)](https://github.com/PennyLaneAI/pennylane/pull/1764)\r\n\r\n* Operators now have a `label` method to determine how they are drawn.  This will   eventually override the `RepresentationResolver` class.   [(#1678)](https://github.com/PennyLaneAI/pennylane/pull/1678)\r\n\r\n* The operation `label` method now supports string variables.   [(#1815)](https://github.com/PennyLaneAI/pennylane/pull/1815)\r\n\r\n* A new utility class `qml.BooleanFn` is introduced. It wraps a function that takes a single   argument and returns a Boolean.   [(#1734)](https://github.com/PennyLaneAI/pennylane/pull/1734)\r\n\r\n  After wrapping, `qml.BooleanFn` can be called like the wrapped function, and   multiple instances can be manipulated and combined with the bitwise operators   `&`, `|` and `~`.\r\n\r\n* There is a new utility function `qml.math.is_independent` that checks whether   a callable is independent of its arguments.   [(#1700)](https://github.com/PennyLaneAI/pennylane/pull/1700)\r\n\r\n  This function is experimental and might behave differently than expected.\r\n\r\n  Note that the test relies on both numerical and analytical checks, except   when using the PyTorch interface which only performs a numerical check.   It is known that there are edge cases on which this test will yield wrong   results, in particular non-smooth functions may be problematic.   For details, please refer to the   [is_indpendent docstring](https://pennylane.readthedocs.io/en/latest/code/api/pennylane.math.is_independent.html).\r\n\r\n* The `qml.beta.QNode` now supports the `qml.qnn` module.   [(#1748)](https://github.com/PennyLaneAI/pennylane/pull/1748)\r\n\r\n* `@qml.beta.QNode` now supports the `qml.specs` transform.   [(#1739)](https://github.com/PennyLaneAI/pennylane/pull/1739)\r\n\r\n* `qml.circuit_drawer.drawable_layers` and `qml.circuit_drawer.drawable_grid` process a list of   operations to layer positions for drawing.   [(#1639)](https://github.com/PennyLaneAI/pennylane/pull/1639)\r\n\r\n* `qml.transforms.batch_transform` now accepts `expand_fn`s that take additional arguments and   keyword arguments. In fact, `expand_fn` and `transform_fn` now **must** have the same signature.   [(#1721)](https://github.com/PennyLaneAI/pennylane/pull/1721)\r\n\r\n* The `qml.batch_transform` decorator is now ignored during Sphinx builds, allowing   the correct signature to display in the built documentation.   [(#1733)](https://github.com/PennyLaneAI/pennylane/pull/1733)\r\n\r\n* The tests for qubit operations are split into multiple files.   [(#1661)](https://github.com/PennyLaneAI/pennylane/pull/1661)\r\n\r\n* The transform for the Jacobian of the classical preprocessing within a QNode,   `qml.transforms.classical_jacobian`, now takes a keyword argument `argnum` to specify   the QNode argument indices with respect to which the Jacobian is computed.   [(#1645)](https://github.com/PennyLaneAI/pennylane/pull/1645)\r\n\r\n  An example for the usage of ``argnum`` is\r\n\r\n  ```python\r\n  @qml.qnode(dev)\r\n  def circuit(x, y, z):\r\n      qml.RX(qml.math.sin(x), wires=0)\r\n      qml.CNOT(wires=[0, 1])\r\n      qml.RY(y ** 2, wires=1)\r\n      qml.RZ(1 / z, wires=1)\r\n      return qml.expval(qml.PauliZ(0))\r\n\r\n  jac_fn = qml.transforms.classical_jacobian(circuit, argnum=[1, 2])\r\n  ```\r\n\r\n  The Jacobian can then be computed at specified parameters.\r\n\r\n  ```pycon\r\n  >>> x, y, z = np.array([0.1, -2.5, 0.71])\r\n  >>> jac_fn(x, y, z)\r\n  (array([-0., -5., -0.]), array([-0.        , -0.        , -1.98373339]))\r\n  ```\r\n\r\n  The returned arrays are the derivatives of the three parametrized gates in the circuit   with respect to `y` and `z` respectively.\r\n\r\n  There also are explicit tests for `classical_jacobian` now, which previously was tested   implicitly via its use in the `metric_tensor` transform.\r\n\r\n  For more usage details, please see the   [classical Jacobian docstring](https://pennylane.readthedocs.io/en/latest/code/api/pennylane.transforms.classical_jacobian.html).\r\n\r\n* A new utility function `qml.math.is_abstract(tensor)` has been added. This function   returns `True` if the tensor is *abstract*; that is, it has no value or shape.   This can occur if within a function that has been just-in-time compiled.   [(#1845)](https://github.com/PennyLaneAI/pennylane/pull/1845)\r\n\r\n* ``qml.circuit_drawer.CircuitDrawer`` can accept a string for the ``charset`` keyword, instead of   a ``CharSet`` object. [(#1640)](https://github.com/PennyLaneAI/pennylane/pull/1640)\r\n\r\n* ``qml.math.sort`` will now return only the sorted torch tensor and not the corresponding indices,   making sort consistent across interfaces.   [(#1691)](https://github.com/PennyLaneAI/pennylane/pull/1691)\r\n\r\n* Specific QNode execution options are now re-used by batch transforms   to execute transformed QNodes.   [(#1708)](https://github.com/PennyLaneAI/pennylane/pull/1708)\r\n\r\n* To standardize across all optimizers, `qml.optimize.AdamOptimizer` now also uses `accumulation`   (in form of `collections.namedtuple`) to keep track of running quantities. Before it used three   variables `fm`, `sm` and `t`. [(#1757)](https://github.com/PennyLaneAI/pennylane/pull/1757)\r\n\r\n<h3>Breaking changes</h3>\r\n\r\n* The operator attributes `has_unitary_generator`, `is_composable_rotation`,   `is_self_inverse`, `is_symmetric_over_all_wires`, and   `is_symmetric_over_control_wires` have been removed as attributes from the   base class. They have been replaced by the sets that store the names of   operations with similar properties in `ops/qubit/attributes.py`.   [(#1763)](https://github.com/PennyLaneAI/pennylane/pull/1763)\r\n\r\n* The `qml.inv` function has been removed, `qml.adjoint` should be used   instead.   [(#1778)](https://github.com/PennyLaneAI/pennylane/pull/1778)\r\n\r\n* The input signature of an `expand_fn` used in a `batch_transform`   now **must** have the same signature as the provided `transform_fn`,   and vice versa.   [(#1721)](https://github.com/PennyLaneAI/pennylane/pull/1721)\r\n\r\n* The `default.qubit.torch` device automatically determines if computations   should be run on a CPU or a GPU and doesn't take a `torch_device` argument   anymore.   [(#1705)](https://github.com/PennyLaneAI/pennylane/pull/1705)\r\n\r\n* The utility function `qml.math.requires_grad` now returns `True` when using Autograd   if and only if the `requires_grad=True` attribute is set on the NumPy array. Previously,   this function would return `True` for *all* NumPy arrays and Python floats, unless   `requires_grad=False` was explicitly set.   [(#1638)](https://github.com/PennyLaneAI/pennylane/pull/1638)\r\n\r\n* The operation `qml.Interferometer` has been renamed `qml.InterferometerUnitary` in order to   distinguish it from the template `qml.templates.Interferometer`.   [(#1714)](https://github.com/PennyLaneAI/pennylane/pull/1714)\r\n\r\n* The `qml.transforms.invisible` decorator has been replaced with `qml.tape.stop_recording`, which   may act as a context manager as well as a decorator to ensure that contained logic is   non-recordable or non-queueable within a QNode or quantum tape context.   [(#1754)](https://github.com/PennyLaneAI/pennylane/pull/1754)\r\n\r\n* Templates `SingleExcitationUnitary` and `DoubleExcitationUnitary` have been renamed   to `FermionicSingleExcitation` and `FermionicDoubleExcitation`, respectively.   [(#1822)](https://github.com/PennyLaneAI/pennylane/pull/1822)\r\n\r\n<h3>Deprecations</h3>\r\n\r\n* Allowing cost functions to be differentiated using `qml.grad` or   `qml.jacobian` without explicitly marking parameters as trainable is being   deprecated, and will be removed in an upcoming release.   Please specify the `requires_grad` attribute for every argument, or specify   `argnum` when using `qml.grad` or `qml.jacobian`.   [(#1773)](https://github.com/PennyLaneAI/pennylane/pull/1773)\r\n\r\n  The following raises a warning in v0.19.0 and will raise an error in   an upcoming release:\r\n\r\n  ```python\r\n   import pennylane as qml\r\n\r\n  dev = qml.device('default.qubit', wires=1)\r\n\r\n  @qml.qnode(dev)   def test(x):       qml.RY(x, wires=[0])\r\n      return qml.expval(qml.PauliZ(0))\r\n\r\n  par = 0.3\r\n  qml.grad(test)(par)\r\n  ```\r\n\r\n  Preferred approaches include specifying the `requires_grad` attribute:\r\n\r\n  ```python\r\n  import pennylane as qml\r\n  from pennylane import numpy as np\r\n\r\n  dev = qml.device('default.qubit', wires=1)\r\n\r\n  @qml.qnode(dev)\r\n  def test(x):\r\n      qml.RY(x, wires=[0])\r\n      return qml.expval(qml.PauliZ(0))\r\n\r\n  par = np.array(0.3, requires_grad=True)\r\n  qml.grad(test)(par)\r\n  ```\r\n\r\n  Or specifying the `argnum` argument when using `qml.grad` or `qml.jacobian`:\r\n\r\n  ```python\r\n  import pennylane as qml\r\n\r\n  dev = qml.device('default.qubit', wires=1)\r\n\r\n  @qml.qnode(dev)\r\n  def test(x):\r\n      qml.RY(x, wires=[0])\r\n      return qml.expval(qml.PauliZ(0))\r\n\r\n  par = 0.3\r\n  qml.grad(test, argnum=0)(par)\r\n  ```\r\n\r\n  <img src=\"https://pennylane.readthedocs.io/en/latest/_static/requires_grad.png\" style=\"width: 100%;\"/>\r\n\r\n* The `default.tensor` device from the beta folder is no longer maintained and has been deprecated. It will be removed in future releases. [(#1851)](https://github.com/PennyLaneAI/pennylane/pull/1851)\r\n\r\n* The `qml.metric_tensor` and `qml.QNGOptimizer` keyword argument `diag_approx`   is deprecated.   Approximations can be controlled with the more fine-grained `approx` keyword   argument, with `approx=\"block-diag\"` (the default) reproducing the old   behaviour.   [(#1721)](https://github.com/PennyLaneAI/pennylane/pull/1721)   [(#1834)](https://github.com/PennyLaneAI/pennylane/pull/1834)\r\n\r\n* The `template` decorator is now deprecated with a warning message and will be removed   in release `v0.20.0`. It has been removed from different PennyLane functions.   [(#1794)](https://github.com/PennyLaneAI/pennylane/pull/1794)   [(#1808)](https://github.com/PennyLaneAI/pennylane/pull/1808)\r\n\r\n* The `qml.fourier.spectrum` function has been renamed to   `qml.fourier.circuit_spectrum`, in order to clearly separate the new   `qnode_spectrum` function from this one.  `qml.fourier.spectrum` is now an   alias for `circuit_spectrum` but is flagged for deprecation and will be   removed soon.   [(#1681)](https://github.com/PennyLaneAI/pennylane/pull/1681)\r\n\r\n* The `init` module, which contains functions to generate random parameter   tensors for templates, is flagged for deprecation and will be removed in the   next release cycle.  Instead, the templates' `shape` method can be used to   get the desired shape of the tensor, which can then be generated manually.   [(#1689)](https://github.com/PennyLaneAI/pennylane/pull/1689)\r\n\r\n  To generate the parameter tensors, the `np.random.normal` and   `np.random.uniform` functions can be used (just like in the `init` module).   Considering the default arguments of these functions as of NumPy v1.21, some   non-default options were used by the `init` module:\r\n\r\n  * All functions generating normally distributed parameters used     `np.random.normal` by passing `scale=0.1`;\r\n\r\n  * Most functions generating uniformly distributed parameters (except for     certain CVQNN initializers) used `np.random.uniform` by passing     `high=2*math.pi`;\r\n\r\n  * The `cvqnn_layers_r_uniform`, `cvqnn_layers_a_uniform`,     `cvqnn_layers_kappa_uniform` functions used `np.random.uniform` by passing     `high=0.1`.\r\n\r\n* The `QNode.draw` method has been deprecated, and will be removed in an   upcoming release.  Please use the `qml.draw` transform instead.   [(#1746)](https://github.com/PennyLaneAI/pennylane/pull/1746)\r\n\r\n* The `QNode.metric_tensor` method has been deprecated, and will be removed in   an upcoming release.  Please use the `qml.metric_tensor` transform instead.   [(#1638)](https://github.com/PennyLaneAI/pennylane/pull/1638)\r\n\r\n* The `pad` parameter of the `qml.AmplitudeEmbedding` template has been removed.   It has instead been renamed to the `pad_with` parameter.   [(#1805)](https://github.com/PennyLaneAI/pennylane/pull/1805)\r\n\r\n<h3>Bug fixes</h3>\r\n\r\n* Fixes a bug where `qml.math.dot` failed to work with `@tf.function` autograph mode.   [(#1842)](https://github.com/PennyLaneAI/pennylane/pull/1842)\r\n\r\n* Fixes a bug where in rare instances the parameters of a tape are returned unsorted   by `Tape.get_parameters`.   [(#1836)](https://github.com/PennyLaneAI/pennylane/pull/1836)\r\n\r\n* Fixes a bug with the arrow width in the `measure` of `qml.circuit_drawer.MPLDrawer`.   [(#1823)](https://github.com/PennyLaneAI/pennylane/pull/1823)\r\n\r\n* The helper functions `qml.math.block_diag` and `qml.math.scatter_element_add`   now are entirely differentiable when using Autograd.  Previously only indexed   entries of the block diagonal could be differentiated, while the derivative   w.r.t to the second argument of `qml.math.scatter_element_add` dispatched to   NumPy instead of Autograd.   [(#1816)](https://github.com/PennyLaneAI/pennylane/pull/1816)   [(#1818)](https://github.com/PennyLaneAI/pennylane/pull/1818)\r\n\r\n* Fixes a bug such that the original shot vector information of a   device is preserved, so that outside the context manager the device   remains unchanged.   [(#1792)](https://github.com/PennyLaneAI/pennylane/pull/1792)\r\n\r\n* Modifies `qml.math.take` to be compatible with a breaking change   released in JAX 0.2.24 and ensure that PennyLane supports this JAX   version.   [(#1769)](https://github.com/PennyLaneAI/pennylane/pull/1769)\r\n\r\n* Fixes a bug where the GPU cannot be used with `qml.qnn.TorchLayer`.   [(#1705)](https://github.com/PennyLaneAI/pennylane/pull/1705)\r\n\r\n* Fix a bug where the devices cache the same result for different observables   return types.   [(#1719)](https://github.com/PennyLaneAI/pennylane/pull/1719)\r\n\r\n* Fixed a bug of the default circuit drawer where having more measurements   compared to the number of measurements on any wire raised a `KeyError`.   [(#1702)](https://github.com/PennyLaneAI/pennylane/pull/1702)\r\n\r\n* Fix a bug where it was not possible to use `jax.jit` on a `QNode` when using   `QubitStateVector`.   [(#1683)](https://github.com/PennyLaneAI/pennylane/pull/1683)\r\n\r\n* The device suite tests can now execute successfully if no shots configuration   variable is given.   [(#1641)](https://github.com/PennyLaneAI/pennylane/pull/1641)\r\n\r\n* Fixes a bug where the `qml.gradients.param_shift` transform would raise an   error while attempting to compute the variance of a QNode with ragged output.   [(#1646)](https://github.com/PennyLaneAI/pennylane/pull/1646)\r\n\r\n* Fixes a bug in `default.mixed`, to ensure that returned probabilities are   always non-negative.   [(#1680)](https://github.com/PennyLaneAI/pennylane/pull/1680)\r\n\r\n* Fixes a bug where gradient transforms would fail to apply to QNodes   containing classical processing.   [(#1699)](https://github.com/PennyLaneAI/pennylane/pull/1699)\r\n\r\n* Fixes a bug where the parameter-shift method was not correctly using the   fallback gradient function when *all* circuit parameters required the fallback.   [(#1782)](https://github.com/PennyLaneAI/pennylane/pull/1782)\r\n\r\n<h3>Documentation</h3>\r\n\r\n* Adds a link to https://pennylane.ai/qml/demonstrations.html in the navbar.   [(#1624)](https://github.com/PennyLaneAI/pennylane/pull/1624)\r\n\r\n* Corrects the docstring of `ExpvalCost` by adding `wires` to the signature of   the `ansatz` argument.   [(#1715)](https://github.com/PennyLaneAI/pennylane/pull/1715)\r\n\r\n* Updated docstring examples using the `qchem.molecular_hamiltonian` function.   [(#1724)](https://github.com/PennyLaneAI/pennylane/pull/1724)\r\n\r\n* Updates the 'Gradients and training' quickstart guide to provide information   on gradient transforms.   [(#1751)](https://github.com/PennyLaneAI/pennylane/pull/1751)\r\n\r\n* All instances of `qnode.draw()` have been updated to instead use the   transform `qml.draw(qnode)`.   [(#1750)](https://github.com/PennyLaneAI/pennylane/pull/1750)\r\n\r\n* Add the `jax` interface in QNode Documentation.   [(#1755)](https://github.com/PennyLaneAI/pennylane/pull/1755)\r\n\r\n* Reorganized all the templates related to quantum chemistry under a common   header `Quantum Chemistry templates`.   [(#1822)](https://github.com/PennyLaneAI/pennylane/pull/1822)\r\n\r\n<h3>Contributors</h3>\r\n\r\nThis release contains contributions from (in alphabetical order):\r\n\r\nCatalina Albornoz, Juan Miguel Arrazola, Utkarsh Azad, Akash Narayanan B, Sam Banning, Thomas Bromley, Jack Ceroni, Alain Delgado, Olivia Di Matteo, Andrew Gardhouse, Anthony Hayes, Theodor Isacsson, David Ittah, Josh Izaac, Soran Jahangiri, Nathan Killoran, Christina Lee, Guillermo Alonso-Linaje, Romain Moyard, Lee James O'Riordan, Carrie-Anne Rubidge, Maria Schuld, Rishabh Singh, Jay Soni, Ingrid Strandberg, Antal Sz\u00e1va, Teresa Tamayo-Mendoza, Rodrigo Vargas, Cody Wang, David Wierichs, Moritz Willmann.", "reactions": {"url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/52961724/reactions", "total_count": 3, "+1": 0, "-1": 0, "laugh": 0, "hooray": 3, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}}
{"url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/52426420", "assets_url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/52426420/assets", "upload_url": "https://uploads.github.com/repos/PennyLaneAI/pennylane/releases/52426420/assets{?name,label}", "html_url": "https://github.com/PennyLaneAI/pennylane/releases/tag/v0.18.0-post2", "id": 52426420, "author": {"login": "josh146", "id": 2959003, "node_id": "MDQ6VXNlcjI5NTkwMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/2959003?v=4", "gravatar_id": "", "url": "https://api.github.com/users/josh146", "html_url": "https://github.com/josh146", "followers_url": "https://api.github.com/users/josh146/followers", "following_url": "https://api.github.com/users/josh146/following{/other_user}", "gists_url": "https://api.github.com/users/josh146/gists{/gist_id}", "starred_url": "https://api.github.com/users/josh146/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/josh146/subscriptions", "organizations_url": "https://api.github.com/users/josh146/orgs", "repos_url": "https://api.github.com/users/josh146/repos", "events_url": "https://api.github.com/users/josh146/events{/privacy}", "received_events_url": "https://api.github.com/users/josh146/received_events", "type": "User", "site_admin": false}, "node_id": "RE_kwDOB76r6M4DH_a0", "tag_name": "v0.18.0-post2", "target_commitish": "v0.18.0-post2-branch", "name": "Release 0.18.0-post2", "draft": false, "prerelease": false, "created_at": "2021-11-01T06:00:01Z", "published_at": "2021-11-01T06:09:57Z", "assets": [], "tarball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/tarball/v0.18.0-post2", "zipball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/zipball/v0.18.0-post2", "body": "A minor post-release to update the PennyLane documentation navigation bar.", "reactions": {"url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/52426420/reactions", "total_count": 2, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 2, "eyes": 0}}
{"url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/50245951", "assets_url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/50245951/assets", "upload_url": "https://uploads.github.com/repos/PennyLaneAI/pennylane/releases/50245951/assets{?name,label}", "html_url": "https://github.com/PennyLaneAI/pennylane/releases/tag/v0.18.0-post1", "id": 50245951, "author": {"login": "josh146", "id": 2959003, "node_id": "MDQ6VXNlcjI5NTkwMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/2959003?v=4", "gravatar_id": "", "url": "https://api.github.com/users/josh146", "html_url": "https://github.com/josh146", "followers_url": "https://api.github.com/users/josh146/followers", "following_url": "https://api.github.com/users/josh146/following{/other_user}", "gists_url": "https://api.github.com/users/josh146/gists{/gist_id}", "starred_url": "https://api.github.com/users/josh146/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/josh146/subscriptions", "organizations_url": "https://api.github.com/users/josh146/orgs", "repos_url": "https://api.github.com/users/josh146/repos", "events_url": "https://api.github.com/users/josh146/events{/privacy}", "received_events_url": "https://api.github.com/users/josh146/received_events", "type": "User", "site_admin": false}, "node_id": "RE_kwDOB76r6M4C_rE_", "tag_name": "v0.18.0-post1", "target_commitish": "v0.18.0-post1", "name": "Release 0.18.0-post1", "draft": false, "prerelease": false, "created_at": "2021-09-25T07:25:46Z", "published_at": "2021-09-25T07:29:15Z", "assets": [], "tarball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/tarball/v0.18.0-post1", "zipball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/zipball/v0.18.0-post1", "body": "A minor post-release to update the PennyLane documentation navigation bar to include a link to the demonstrations.\r\n", "reactions": {"url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/50245951/reactions", "total_count": 3, "+1": 0, "-1": 0, "laugh": 0, "hooray": 3, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}}
{"url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/49963482", "assets_url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/49963482/assets", "upload_url": "https://uploads.github.com/repos/PennyLaneAI/pennylane/releases/49963482/assets{?name,label}", "html_url": "https://github.com/PennyLaneAI/pennylane/releases/tag/v0.18.0", "id": 49963482, "author": {"login": "antalszava", "id": 24476053, "node_id": "MDQ6VXNlcjI0NDc2MDUz", "avatar_url": "https://avatars.githubusercontent.com/u/24476053?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antalszava", "html_url": "https://github.com/antalszava", "followers_url": "https://api.github.com/users/antalszava/followers", "following_url": "https://api.github.com/users/antalszava/following{/other_user}", "gists_url": "https://api.github.com/users/antalszava/gists{/gist_id}", "starred_url": "https://api.github.com/users/antalszava/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antalszava/subscriptions", "organizations_url": "https://api.github.com/users/antalszava/orgs", "repos_url": "https://api.github.com/users/antalszava/repos", "events_url": "https://api.github.com/users/antalszava/events{/privacy}", "received_events_url": "https://api.github.com/users/antalszava/received_events", "type": "User", "site_admin": false}, "node_id": "RE_kwDOB76r6M4C-mHa", "tag_name": "v0.18.0", "target_commitish": "v0.18.0-rc0", "name": "Release 0.18.0", "draft": false, "prerelease": false, "created_at": "2021-09-21T07:57:40Z", "published_at": "2021-09-21T08:02:44Z", "assets": [], "tarball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/tarball/v0.18.0", "zipball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/zipball/v0.18.0", "body": "<h3>New features since last release</h3>\r\n\r\n<h4>PennyLane now comes packaged with <code>lightning.qubit</code></h4>\r\n\r\n* The C++-based [lightning.qubit](https://pennylane-lightning.readthedocs.io/en/stable/) device is now included with installations of PennyLane. [(#1663)](https://github.com/PennyLaneAI/pennylane/pull/1663)\r\n\r\n  The `lightning.qubit` device is a fast state-vector simulator equipped with the efficient [adjoint method](https://arxiv.org/abs/2009.02823) for differentiating quantum circuits, check out the plugin [release notes](https://github.com/PennyLaneAI/pennylane-lightning/blob/v0.18.0/.github/CHANGELOG.md#new-features-since-last-release) for more details! The device can be accessed in the following way:\r\n\r\n  ```python\r\n  import pennylane as qml\r\n\r\n  wires = 3\r\n  layers = 2\r\n  dev = qml.device(\"lightning.qubit\", wires=wires)\r\n\r\n  @qml.qnode(dev, diff_method=\"adjoint\")\r\n  def circuit(weights):\r\n      qml.templates.StronglyEntanglingLayers(weights, wires=range(wires))\r\n      return qml.expval(qml.PauliZ(0))\r\n\r\n  weights = qml.init.strong_ent_layers_normal(layers, wires, seed=1967)\r\n  ```\r\n\r\n  Evaluating circuits and their gradients on the device can be achieved using the standard approach:\r\n\r\n  ```pycon\r\n  >>> print(f\"Circuit evaluated: {circuit(weights)}\")\r\n  Circuit evaluated: 0.9801286266677633\r\n  >>> print(f\"Circuit gradient:\\n{qml.grad(circuit)(weights)}\")\r\n  Circuit gradient:\r\n  [[[-9.35301749e-17 -1.63051504e-01 -4.14810501e-04]\r\n    [-7.88816484e-17 -1.50136528e-04 -1.77922957e-04]\r\n    [-5.20670796e-17 -3.92874550e-02  8.14523075e-05]]\r\n\r\n   [[-1.14472273e-04  3.85963953e-02 -9.39190132e-18]\r\n    [-5.76791765e-05 -9.78478343e-02  0.00000000e+00]\r\n    [ 0.00000000e+00  0.00000000e+00  0.00000000e+00]]]\r\n  ```\r\n\r\n  The adjoint method operates after a forward pass by iteratively applying inverse gates to scan backwards through the circuit. The method is already available in PennyLane's `default.qubit` device, but the version provided by `lightning.qubit` integrates with the C++ backend and is more performant, as shown in the plot below:\r\n\r\n  <img src=\"https://raw.githubusercontent.com/PennyLaneAI/pennylane-lightning/master/doc/_static/lightning_adjoint.png\" width=70%/>\r\n\r\n<h4>Support for native backpropagation using PyTorch</h4>\r\n\r\n* The built-in PennyLane simulator `default.qubit` now supports backpropogation with PyTorch. [(#1360)](https://github.com/PennyLaneAI/pennylane/pull/1360) [(#1598)](https://github.com/PennyLaneAI/pennylane/pull/1598)\r\n\r\n  As a result, `default.qubit` can now use end-to-end classical backpropagation as a means to compute gradients. End-to-end backpropagation can be faster than the parameter-shift rule for computing quantum gradients when the number of parameters to be optimized is large. This is now the default differentiation method when using `default.qubit` with PyTorch.\r\n\r\n  Using this method, the created QNode is a 'white-box' that is tightly integrated with your PyTorch computation, including TorchScript and GPU support.\r\n\r\n  ```python\r\n  x = torch.tensor(0.43316321, dtype=torch.float64, requires_grad=True)\r\n  y = torch.tensor(0.2162158, dtype=torch.float64, requires_grad=True)\r\n  z = torch.tensor(0.75110998, dtype=torch.float64, requires_grad=True)\r\n\r\n  p = torch.tensor([x, y, z], requires_grad=True)\r\n  dev = qml.device(\"default.qubit\", wires=1)\r\n\r\n  @qml.qnode(dev, interface=\"torch\", diff_method=\"backprop\")\r\n  def circuit(x):\r\n      qml.Rot(x[0], x[1], x[2], wires=0)\r\n      return qml.expval(qml.PauliZ(0))\r\n\r\n  res = circuit(p)\r\n  res.backward()\r\n  ```\r\n  ```pycon\r\n  >>> res = circuit(p)\r\n  >>> res.backward()\r\n  >>> print(p.grad)\r\n  tensor([-9.1798e-17, -2.1454e-01, -1.0511e-16], dtype=torch.float64)\r\n  ```\r\n\r\n<h4>Improved quantum optimization methods</h4>\r\n\r\n* The `RotosolveOptimizer` now can tackle general parametrized circuits, and is no longer restricted to single-qubit Pauli rotations. [(#1489)](https://github.com/PennyLaneAI/pennylane/pull/1489)\r\n\r\n  This includes:\r\n\r\n  - layers of gates controlled by the same parameter,\r\n  - controlled variants of parametrized gates, and\r\n  - Hamiltonian time evolution.\r\n\r\n  Note that the eigenvalue spectrum of the gate generator needs to be known to use `RotosolveOptimizer` for a general gate, and it is required to produce equidistant frequencies. For details see [Vidal and Theis, 2018](https://arxiv.org/abs/1812.06323) and [Wierichs, Izaac, Wang, Lin 2021](https://arxiv.org/abs/2107.12390).\r\n\r\n  Consider a circuit with a mixture of Pauli rotation gates, controlled Pauli rotations, and single-parameter layers of Pauli rotations:\r\n\r\n  ```python\r\n  dev = qml.device('default.qubit', wires=3, shots=None)\r\n\r\n  @qml.qnode(dev)\r\n  def cost_function(rot_param, layer_par, crot_param):\r\n      for i, par in enumerate(rot_param):\r\n          qml.RX(par, wires=i)\r\n      for w in dev.wires:\r\n          qml.RX(layer_par, wires=w)\r\n      for i, par in enumerate(crot_param):\r\n          qml.CRY(par, wires=[i, (i+1) % 3])\r\n\r\n      return qml.expval(qml.PauliZ(0) @ qml.PauliZ(1) @ qml.PauliZ(2))\r\n  ```\r\n\r\n  This cost function has one frequency for each of the first `RX` rotation angles, three frequencies for the layer of `RX` gates that depend on `layer_par`, and two frequencies for each of the `CRY` gate parameters. Rotosolve can then be used to minimize the `cost_function`:\r\n\r\n  ```python\r\n  # Initial parameters\r\n  init_param = [\r\n      np.array([0.3, 0.2, 0.67], requires_grad=True),\r\n      np.array(1.1, requires_grad=True),\r\n      np.array([-0.2, 0.1, -2.5], requires_grad=True),\r\n  ]\r\n  # Numbers of frequencies per parameter\r\n  num_freqs = [[1, 1, 1], 3, [2, 2, 2]]\r\n\r\n  opt = qml.RotosolveOptimizer()\r\n  param = init_param.copy()\r\n  ```\r\n\r\n  In addition, the optimization technique for the Rotosolve substeps can be chosen via the `optimizer` and `optimizer_kwargs` keyword arguments and the minimized cost of the intermediate univariate reconstructions can be read out via `full_output`, including the cost _after_ the full Rotosolve step:\r\n\r\n  ```python\r\n  for step in range(3):\r\n      param, cost, sub_cost = opt.step_and_cost(\r\n          cost_function,\r\n          *param,\r\n          num_freqs=num_freqs,\r\n          full_output=True,\r\n          optimizer=\"brute\",\r\n      )\r\n      print(f\"Cost before step: {cost}\")\r\n      print(f\"Minimization substeps: {np.round(sub_cost, 6)}\")\r\n  ```\r\n  ``` pycon\r\n  Cost before step: 0.042008210392535605\r\n  Minimization substeps: [-0.230905 -0.863336 -0.980072 -0.980072 -1.       -1.       -1.      ]\r\n  Cost before step: -0.999999999068121\r\n  Minimization substeps: [-1. -1. -1. -1. -1. -1. -1.]\r\n  Cost before step: -1.0\r\n  Minimization substeps: [-1. -1. -1. -1. -1. -1. -1.]\r\n  ```\r\n\r\n  For usage details please consider the [docstring of the optimizer](https://pennylane.readthedocs.io/en/stable/code/api/pennylane.RotosolveOptimizer.html?highlight=rotosolveoptimizer#pennylane.RotosolveOptimizer).\r\n\r\n<h4>Faster, trainable, Hamiltonian simulations</h4>\r\n\r\n* Hamiltonians are now trainable with respect to their coefficients. [(#1483)](https://github.com/PennyLaneAI/pennylane/pull/1483)\r\n\r\n  ``` python\r\n  from pennylane import numpy as np\r\n\r\n  dev = qml.device(\"default.qubit\", wires=2)\r\n  @qml.qnode(dev)\r\n  def circuit(coeffs, param):\r\n      qml.RX(param, wires=0)\r\n      qml.RY(param, wires=0)\r\n      return qml.expval(\r\n          qml.Hamiltonian(coeffs, [qml.PauliX(0), qml.PauliZ(0)], simplify=True)\r\n      )\r\n\r\n  coeffs = np.array([-0.05, 0.17])\r\n  param = np.array(1.7)\r\n  grad_fn = qml.grad(circuit)\r\n  ```\r\n  ``` pycon\r\n  >>> grad_fn(coeffs, param)\r\n  (array([-0.12777055,  0.0166009 ]), array(0.0917819))\r\n  ```\r\n\r\n  Furthermore, a gradient recipe for Hamiltonian coefficients has been added. This makes it possible to compute parameter-shift gradients of these coefficients on devices that natively support Hamiltonians. [(#1551)](https://github.com/PennyLaneAI/pennylane/pull/1551)\r\n\r\n* Hamiltonians are now natively supported on the `default.qubit` device if `shots=None`. This makes VQE workflows a lot faster in some cases. [(#1551)](https://github.com/PennyLaneAI/pennylane/pull/1551) [(#1596)](https://github.com/PennyLaneAI/pennylane/pull/1596)\r\n\r\n  <img src=\"https://pennylane.readthedocs.io/en/latest/_static/hamiltonian_expval_h_plot.png\" width=45%/>\r\n\r\n* The Hamiltonian can now store grouping information, which can be accessed by a device to speed up computations of the expectation value of a Hamiltonian. [(#1515)](https://github.com/PennyLaneAI/pennylane/pull/1515)\r\n\r\n  ```python\r\n  obs = [qml.PauliX(0), qml.PauliX(1), qml.PauliZ(0)]\r\n  coeffs = np.array([1., 2., 3.])\r\n  H = qml.Hamiltonian(coeffs, obs, grouping_type='qwc')\r\n  ```\r\n\r\n  Initialization with a ``grouping_type`` other than ``None`` stores the indices\r\n  required to make groups of commuting observables and their coefficients.\r\n\r\n  ``` pycon\r\n  >>> H.grouping_indices\r\n  [[0, 1], [2]]\r\n  ```\r\n\r\n<h4>Create multi-circuit quantum transforms and custom gradient rules</h4>\r\n\r\n* Custom gradient transforms can now be created using the new `@qml.gradients.gradient_transform` decorator on a batch-tape transform. [(#1589)](https://github.com/PennyLaneAI/pennylane/pull/1589)\r\n\r\n  Quantum gradient transforms are a specific case of `qml.batch_transform`.\r\n\r\n  Supported gradient transforms must be of the following form:\r\n\r\n  ```python\r\n  @qml.gradients.gradient_transform\r\n  def my_custom_gradient(tape, argnum=None, **kwargs):\r\n      ...\r\n      return gradient_tapes, processing_fn\r\n  ```\r\n\r\n  Various built-in quantum gradient transforms are provided within the `qml.gradients` module, including `qml.gradients.param_shift`. Once defined, quantum gradient transforms can be applied directly to QNodes:\r\n\r\n  ```pycon\r\n  >>> @qml.qnode(dev)\r\n  ... def circuit(x):\r\n  ...     qml.RX(x, wires=0)\r\n  ...     qml.CNOT(wires=[0, 1])\r\n  ...     return qml.expval(qml.PauliZ(0))\r\n  >>> circuit(0.3)\r\n  tensor(0.95533649, requires_grad=True)\r\n  >>> qml.gradients.param_shift(circuit)(0.5)\r\n  array([[-0.47942554]])\r\n  ```\r\n\r\n  Quantum gradient transforms are fully differentiable, allowing higher order derivatives to be accessed:\r\n\r\n  ```pycon\r\n  >>> qml.grad(qml.gradients.param_shift(circuit))(0.5)\r\n  tensor(-0.87758256, requires_grad=True)\r\n  ```\r\n\r\n  Refer to the page of [quantum gradient transforms](https://pennylane.readthedocs.io/en/stable/code/qml_gradients.html) for more details.\r\n\r\n* The ability to define *batch* transforms has been added via the new `@qml.batch_transform` decorator. [(#1493)](https://github.com/PennyLaneAI/pennylane/pull/1493)\r\n\r\n  A batch transform is a transform that takes a single tape or QNode as input, and executes multiple tapes or QNodes independently. The results may then be post-processed before being returned.\r\n\r\n  For example, consider the following batch transform:\r\n\r\n  ```python\r\n  @qml.batch_transform\r\n  def my_transform(tape, a, b):\r\n      \"\"\"Generates two tapes, one with all RX replaced with RY,\r\n      and the other with all RX replaced with RZ.\"\"\"\r\n      tape1 = qml.tape.JacobianTape()\r\n      tape2 = qml.tape.JacobianTape()\r\n\r\n      # loop through all operations on the input tape\r\n      for op in tape.operations + tape.measurements:\r\n          if op.name == \"RX\":\r\n              with tape1:\r\n                  qml.RY(a * qml.math.abs(op.parameters[0]), wires=op.wires)\r\n              with tape2:\r\n                  qml.RZ(b * qml.math.abs(op.parameters[0]), wires=op.wires)\r\n          else:\r\n              for t in [tape1, tape2]:\r\n                  with t:\r\n                      qml.apply(op)\r\n\r\n      def processing_fn(results):\r\n          return qml.math.sum(qml.math.stack(results))\r\n\r\n      return [tape1, tape2], processing_fn\r\n  ```\r\n\r\n  We can transform a QNode directly using decorator syntax:\r\n\r\n  ```pycon\r\n  >>> @my_transform(0.65, 2.5)\r\n  ... @qml.qnode(dev)\r\n  ... def circuit(x):\r\n  ...     qml.Hadamard(wires=0)\r\n  ...     qml.RX(x, wires=0)\r\n  ...     return qml.expval(qml.PauliX(0))\r\n  >>> print(circuit(-0.5))\r\n  1.2629730888100839\r\n  ```\r\n\r\n  Batch tape transforms are fully differentiable:\r\n\r\n  ```pycon\r\n  >>> gradient = qml.grad(circuit)(-0.5)\r\n  >>> print(gradient)\r\n  2.5800122591960153\r\n  ```\r\n\r\n  Batch transforms can also be applied to existing QNodes,\r\n\r\n  ```pycon\r\n  >>> new_qnode = my_transform(existing_qnode, *transform_weights)\r\n  >>> new_qnode(weights)\r\n  ```\r\n\r\n  or to tapes (in which case, the processed tapes and classical post-processing functions are returned):\r\n\r\n  ```pycon\r\n  >>> tapes, fn = my_transform(tape, 0.65, 2.5)\r\n  >>> from pennylane.interfaces.batch import execute\r\n  >>> dev = qml.device(\"default.qubit\", wires=1)\r\n  >>> res = execute(tapes, dev, interface=\"autograd\", gradient_fn=qml.gradients.param_shift)\r\n  1.2629730888100839\r\n  ```\r\n\r\n* Vector-Jacobian product transforms have been added to the `qml.gradients` package. [(#1494)](https://github.com/PennyLaneAI/pennylane/pull/1494)\r\n\r\n  The new transforms include:\r\n\r\n  - `qml.gradients.vjp`\r\n  - `qml.gradients.batch_vjp`\r\n\r\n* Support for differentiable execution of batches of circuits has been added, via the beta `pennylane.interfaces.batch` module. [(#1501)](https://github.com/PennyLaneAI/pennylane/pull/1501) [(#1508)](https://github.com/PennyLaneAI/pennylane/pull/1508) [(#1542)](https://github.com/PennyLaneAI/pennylane/pull/1542) [(#1549)](https://github.com/PennyLaneAI/pennylane/pull/1549) [(#1608)](https://github.com/PennyLaneAI/pennylane/pull/1608) [(#1618)](https://github.com/PennyLaneAI/pennylane/pull/1618) [(#1637)](https://github.com/PennyLaneAI/pennylane/pull/1637)\r\n\r\n  For now, this is a low-level feature, and will be integrated into the QNode in a future release. For example:\r\n\r\n  ```python\r\n  from pennylane.interfaces.batch import execute\r\n\r\n  def cost_fn(x):\r\n      with qml.tape.JacobianTape() as tape1:\r\n          qml.RX(x[0], wires=[0])\r\n          qml.RY(x[1], wires=[1])\r\n          qml.CNOT(wires=[0, 1])\r\n          qml.var(qml.PauliZ(0) @ qml.PauliX(1))\r\n\r\n      with qml.tape.JacobianTape() as tape2:\r\n          qml.RX(x[0], wires=0)\r\n          qml.RY(x[0], wires=1)\r\n          qml.CNOT(wires=[0, 1])\r\n          qml.probs(wires=1)\r\n\r\n      result = execute(\r\n          [tape1, tape2], dev,\r\n          gradient_fn=qml.gradients.param_shift,\r\n          interface=\"autograd\"\r\n      )\r\n      return result[0] + result[1][0, 0]\r\n\r\n  res = qml.grad(cost_fn)(params)\r\n  ```\r\n\r\n<h3>Improvements</h3>\r\n\r\n* A new operation `qml.SISWAP` has been added, the square-root of the `qml.ISWAP` operation. [(#1563)](https://github.com/PennyLaneAI/pennylane/pull/1563)\r\n\r\n* The `frobenius_inner_product` function has been moved to the `qml.math` module, and is now differentiable using all autodiff frameworks. [(#1388)](https://github.com/PennyLaneAI/pennylane/pull/1388)\r\n\r\n* A warning is raised to inform the user that specifying a list of shots is only supported for `QubitDevice` based devices. [(#1659)](https://github.com/PennyLaneAI/pennylane/pull/1659)\r\n\r\n* The `qml.circuit_drawer.MPLDrawer` class provides manual circuit drawing functionality using Matplotlib. While not yet integrated with automatic circuit drawing, this class provides customization and control. [(#1484)](https://github.com/PennyLaneAI/pennylane/pull/1484)\r\n\r\n  ```python\r\n  from pennylane.circuit_drawer import MPLDrawer\r\n\r\n  drawer = MPLDrawer(n_wires=3, n_layers=3)\r\n\r\n  drawer.label([r\"$|\\Psi\\rangle$\", r\"$|\\theta\\rangle$\", \"aux\"])\r\n\r\n  drawer.box_gate(layer=0, wires=[0, 1, 2], text=\"Entangling Layers\", text_options={'rotation': 'vertical'})\r\n  drawer.box_gate(layer=1, wires=[0, 1], text=\"U(\u03b8)\")\r\n\r\n  drawer.CNOT(layer=2, wires=[1, 2])\r\n  drawer.measure(layer=3, wires=2)\r\n\r\n  drawer.fig.suptitle('My Circuit', fontsize='xx-large')\r\n  ```\r\n\r\n  <img src=\"https://pennylane.readthedocs.io/en/latest/_static/drawer/example_release_notes.png\" width=70%/>\r\n\r\n* The slowest tests, more than 1.5 seconds, now have the pytest mark `slow`, and can be selected or deselected during local execution of tests. [(#1633)](https://github.com/PennyLaneAI/pennylane/pull/1633)\r\n\r\n* The device test suite has been expanded to cover more qubit operations and observables. [(#1510)](https://github.com/PennyLaneAI/pennylane/pull/1510)\r\n\r\n* The `MultiControlledX` class now inherits from `Operation` instead of `ControlledQubitUnitary` which makes the `MultiControlledX` gate a non-parameterized gate. [(#1557)](https://github.com/PennyLaneAI/pennylane/pull/1557)\r\n\r\n* The `utils.sparse_hamiltonian` function can now deal with non-integer wire labels, and it throws an error for the edge case of observables that are created from multi-qubit operations. [(#1550)](https://github.com/PennyLaneAI/pennylane/pull/1550)\r\n\r\n* Added the matrix attribute to `qml.templates.subroutines.GroverOperator` [(#1553)](https://github.com/PennyLaneAI/pennylane/pull/1553)\r\n\r\n* The `tape.to_openqasm()` method now has a `measure_all` argument that specifies whether the serialized OpenQASM script includes computational basis measurements on all of the qubits or just those specified by the tape. [(#1559)](https://github.com/PennyLaneAI/pennylane/pull/1559)\r\n\r\n* An error is now raised when no arguments are passed to an observable, to inform that wires have not been supplied. [(#1547)](https://github.com/PennyLaneAI/pennylane/pull/1547)\r\n\r\n* The `group_observables` transform is now differentiable. [(#1483)](https://github.com/PennyLaneAI/pennylane/pull/1483)\r\n\r\n  For example:\r\n\r\n  ``` python\r\n  import jax\r\n  from jax import numpy as jnp\r\n\r\n  coeffs = jnp.array([1., 2., 3.])\r\n  obs = [PauliX(wires=0), PauliX(wires=1), PauliZ(wires=1)]\r\n\r\n  def group(coeffs, select=None):\r\n    _, grouped_coeffs = qml.grouping.group_observables(obs, coeffs)\r\n    # in this example, grouped_coeffs is a list of two jax tensors\r\n    # [DeviceArray([1., 2.], dtype=float32), DeviceArray([3.], dtype=float32)]\r\n    return grouped_coeffs[select]\r\n\r\n  jac_fn = jax.jacobian(group)\r\n  ```\r\n  ```pycon\r\n  >>> jac_fn(coeffs, select=0)\r\n  [[1. 0. 0.]\r\n  [0. 1. 0.]]\r\n\r\n  >>> jac_fn(coeffs, select=1)\r\n  [[0., 0., 1.]]\r\n  ```\r\n\r\n* The tape does not verify any more that all Observables have owners in the annotated queue. [(#1505)](https://github.com/PennyLaneAI/pennylane/pull/1505)\r\n\r\n  This allows manipulation of Observables inside a tape context. An example is `expval(Tensor(qml.PauliX(0), qml.Identity(1)).prune())` which makes the expval an owner of the pruned tensor and its constituent observables, but leaves the original tensor in the queue without an owner.\r\n\r\n* The `qml.ResetError` is now supported for `default.mixed` device. [(#1541)](https://github.com/PennyLaneAI/pennylane/pull/1541)\r\n\r\n* `QNode.diff_method` will now reflect which method was selected from `diff_method=\"best\"`. [(#1568)](https://github.com/PennyLaneAI/pennylane/pull/1568)\r\n\r\n* QNodes now support `diff_method=None`. This works the same as `interface=None`. Such QNodes accept floats, ints, lists and NumPy arrays and return NumPy output but can not be differentiated. [(#1585)](https://github.com/PennyLaneAI/pennylane/pull/1585)\r\n\r\n* QNodes now include validation to warn users if a supplied keyword argument is not one of the recognized arguments. [(#1591)](https://github.com/PennyLaneAI/pennylane/pull/1591)\r\n\r\n<h3>Breaking changes</h3>\r\n\r\n* The `QFT` operation has been moved, and is now accessible via `pennylane.templates.QFT`. [(#1548)](https://github.com/PennyLaneAI/pennylane/pull/1548)\r\n\r\n* Specifying `shots=None` with `qml.sample` was previously deprecated. From this release onwards, setting `shots=None` when sampling will raise an error also for `default.qubit.jax`. [(#1629)](https://github.com/PennyLaneAI/pennylane/pull/1629)\r\n\r\n* An error is raised during QNode creation when a user requests backpropagation on a device with finite-shots. [(#1588)](https://github.com/PennyLaneAI/pennylane/pull/1588)\r\n\r\n* The class `qml.Interferometer` is deprecated and will be renamed `qml.InterferometerUnitary` after one release cycle. [(#1546)](https://github.com/PennyLaneAI/pennylane/pull/1546)\r\n\r\n*  All optimizers except for Rotosolve and Rotoselect now have a public attribute `stepsize`. Temporary backward compatibility has been added to support the use of `_stepsize` for one release cycle. `update_stepsize` method is deprecated. [(#1625)](https://github.com/PennyLaneAI/pennylane/pull/1625)\r\n\r\n\r\n<h3>Bug fixes</h3>\r\n\r\n* Fixed a bug with shot vectors and `Device` base class. [(#1666)](https://github.com/PennyLaneAI/pennylane/pull/1666)\r\n\r\n* Fixed a bug where `@jax.jit` would fail on a QNode that used `qml.QubitStateVector`. [(#1649)](https://github.com/PennyLaneAI/pennylane/pull/1649)\r\n\r\n* Fixed a bug related to an edge case of single-qubit `zyz_decomposition` when only off-diagonal elements are present. [(#1643)](https://github.com/PennyLaneAI/pennylane/pull/1643)\r\n\r\n* `MottonenStatepreparation` can now be run with a single wire label not in a list. [(#1620)](https://github.com/PennyLaneAI/pennylane/pull/1620)\r\n\r\n* Fixed the circuit representation of CY gates to align with CNOT and CZ gates when calling the circuit drawer. [(#1504)](https://github.com/PennyLaneAI/pennylane/issues/1504)\r\n\r\n* Dask and CVXPY dependent tests are skipped if those packages are not installed. [(#1617)](https://github.com/PennyLaneAI/pennylane/pull/1617)\r\n\r\n* The `qml.layer` template now works with tensorflow variables. [(#1615)](https://github.com/PennyLaneAI/pennylane/pull/1615)\r\n\r\n* Remove `QFT` from possible operations in `default.qubit` and `default.mixed`. [(#1600)](https://github.com/PennyLaneAI/pennylane/pull/1600)\r\n\r\n* Fixed a bug when computing expectations of Hamiltonians using TensorFlow. [(#1586)](https://github.com/PennyLaneAI/pennylane/pull/1586)\r\n\r\n* Fixed a bug when computing the specs of a circuit with a Hamiltonian\r\n  observable. [(#1533)](https://github.com/PennyLaneAI/pennylane/pull/1533)\r\n\r\n<h3>Documentation</h3>\r\n\r\n* The `qml.Identity` operation is placed under the sections Qubit observables and CV observables. [(#1576)](https://github.com/PennyLaneAI/pennylane/pull/1576)\r\n\r\n* Updated the documentation of `qml.grouping`, `qml.kernels` and `qml.qaoa` modules to present the list of functions first followed by the technical details of the module. [(#1581)](https://github.com/PennyLaneAI/pennylane/pull/1581)\r\n\r\n* Recategorized Qubit operations into new and existing categories so that code for each operation is easier to locate. [(#1566)](https://github.com/PennyLaneAI/pennylane/pull/1583)\r\n\r\n<h3>Contributors</h3>\r\n\r\nThis release contains contributions from (in alphabetical order):\r\n\r\nVishnu Ajith, Akash Narayanan B, Thomas Bromley, Olivia Di Matteo, Sahaj Dhamija, Tanya Garg, Anthony Hayes, Theodor Isacsson, Josh Izaac, Prateek Jain, Ankit Khandelwal, Nathan Killoran, Christina Lee, Ian McLean, Johannes Jakob Meyer, Romain Moyard, Lee James O'Riordan, Esteban Payares, Pratul Saini, Maria Schuld, Arshpreet Singh, Jay Soni, Ingrid Strandberg, Antal Sz\u00e1va, Slimane Thabet, David Wierichs, Vincent Wong."}
{"url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/47945343", "assets_url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/47945343/assets", "upload_url": "https://uploads.github.com/repos/PennyLaneAI/pennylane/releases/47945343/assets{?name,label}", "html_url": "https://github.com/PennyLaneAI/pennylane/releases/tag/v0.17.0", "id": 47945343, "author": {"login": "antalszava", "id": 24476053, "node_id": "MDQ6VXNlcjI0NDc2MDUz", "avatar_url": "https://avatars.githubusercontent.com/u/24476053?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antalszava", "html_url": "https://github.com/antalszava", "followers_url": "https://api.github.com/users/antalszava/followers", "following_url": "https://api.github.com/users/antalszava/following{/other_user}", "gists_url": "https://api.github.com/users/antalszava/gists{/gist_id}", "starred_url": "https://api.github.com/users/antalszava/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antalszava/subscriptions", "organizations_url": "https://api.github.com/users/antalszava/orgs", "repos_url": "https://api.github.com/users/antalszava/repos", "events_url": "https://api.github.com/users/antalszava/events{/privacy}", "received_events_url": "https://api.github.com/users/antalszava/received_events", "type": "User", "site_admin": false}, "node_id": "MDc6UmVsZWFzZTQ3OTQ1MzQz", "tag_name": "v0.17.0", "target_commitish": "v0.17.0-rc0", "name": "Release 0.17.0", "draft": false, "prerelease": false, "created_at": "2021-08-17T02:13:33Z", "published_at": "2021-08-17T02:19:33Z", "assets": [], "tarball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/tarball/v0.17.0", "zipball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/zipball/v0.17.0", "body": "<h3>New features since the last release</h3>\r\n\r\n<h4>Circuit optimization</h4>\r\n\r\n* PennyLane can now perform quantum circuit optimization using the top-level transform `qml.compile`. The `compile` transform allows you to chain together sequences of tape and quantum function transforms into custom circuit optimization pipelines. [(#1475)](https://github.com/PennyLaneAI/pennylane/pull/1475)\r\n\r\n  For example, take the following decorated quantum function:\r\n\r\n  ```python\r\n  dev = qml.device('default.qubit', wires=[0, 1, 2])\r\n\r\n  @qml.qnode(dev)\r\n  @qml.compile()\r\n  def qfunc(x, y, z):\r\n      qml.Hadamard(wires=0)\r\n      qml.Hadamard(wires=1)\r\n      qml.Hadamard(wires=2)\r\n      qml.RZ(z, wires=2)\r\n      qml.CNOT(wires=[2, 1])\r\n      qml.RX(z, wires=0)\r\n      qml.CNOT(wires=[1, 0])\r\n      qml.RX(x, wires=0)\r\n      qml.CNOT(wires=[1, 0])\r\n      qml.RZ(-z, wires=2)\r\n      qml.RX(y, wires=2)\r\n      qml.PauliY(wires=2)\r\n      qml.CZ(wires=[1, 2])\r\n      return qml.expval(qml.PauliZ(wires=0))\r\n  ```\r\n\r\n  The default behaviour of `qml.compile` is to apply a sequence of three transforms: `commute_controlled`, `cancel_inverses`, and then `merge_rotations`.\r\n\r\n  ```pycon\r\n  >>> print(qml.draw(qfunc)(0.2, 0.3, 0.4))\r\n   0: \u2500\u2500H\u2500\u2500\u2500RX(0.6)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u27e8Z\u27e9\r\n   1: \u2500\u2500H\u2500\u2500\u256dX\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256dC\u2500\u2500\u2524\r\n   2: \u2500\u2500H\u2500\u2500\u2570C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500RX(0.3)\u2500\u2500Y\u2500\u2500\u2570Z\u2500\u2500\u2524\r\n  ```\r\n\r\n  The `qml.compile` transform is flexible and accepts a custom pipeline of tape and quantum function transforms (you can even write your own!). For example, if we wanted to only push single-qubit gates through controlled gates and cancel adjacent inverses, we could do:\r\n\r\n  ```python\r\n  from pennylane.transforms import commute_controlled, cancel_inverses\r\n  pipeline = [commute_controlled, cancel_inverses]\r\n\r\n  @qml.qnode(dev)\r\n  @qml.compile(pipeline=pipeline)\r\n  def qfunc(x, y, z):\r\n      qml.Hadamard(wires=0)\r\n      qml.Hadamard(wires=1)\r\n      qml.Hadamard(wires=2)\r\n      qml.RZ(z, wires=2)\r\n      qml.CNOT(wires=[2, 1])\r\n      qml.RX(z, wires=0)\r\n      qml.CNOT(wires=[1, 0])\r\n      qml.RX(x, wires=0)\r\n      qml.CNOT(wires=[1, 0])\r\n      qml.RZ(-z, wires=2)\r\n      qml.RX(y, wires=2)\r\n      qml.PauliY(wires=2)\r\n      qml.CZ(wires=[1, 2])\r\n      return qml.expval(qml.PauliZ(wires=0))\r\n  ```\r\n\r\n  ```pycon\r\n  >>> print(qml.draw(qfunc)(0.2, 0.3, 0.4))\r\n   0: \u2500\u2500H\u2500\u2500\u2500RX(0.4)\u2500\u2500RX(0.2)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u27e8Z\u27e9\r\n   1: \u2500\u2500H\u2500\u2500\u256dX\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256dC\u2500\u2500\u2524\r\n   2: \u2500\u2500H\u2500\u2500\u2570C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500RZ(0.4)\u2500\u2500RZ(-0.4)\u2500\u2500RX(0.3)\u2500\u2500Y\u2500\u2500\u2570Z\u2500\u2500\u2524\r\n  ```\r\n\r\n  The following compilation transforms have been added and are also available to use, either independently, or within a `qml.compile` pipeline:\r\n\r\n  * `commute_controlled`: push commuting single-qubit gates through controlled operations. [(#1464)](https://github.com/PennyLaneAI/pennylane/pull/1464)\r\n\r\n  * `cancel_inverses`: removes adjacent pairs of operations that cancel out. [(#1455)](https://github.com/PennyLaneAI/pennylane/pull/1455)\r\n\r\n  * `merge_rotations`: combines adjacent rotation gates of    the same type into a single gate, including controlled rotations.    [(#1455)](https://github.com/PennyLaneAI/pennylane/pull/1455)\r\n\r\n  * `single_qubit_fusion`: acts on all sequences of    single-qubit operations in a quantum function, and converts each    sequence to a single `Rot` gate.    [(#1458)](https://github.com/PennyLaneAI/pennylane/pull/1458)\r\n\r\n  For more details on `qml.compile` and the available compilation transforms, see  [the compilation documentation](https://pennylane.readthedocs.io/en/stable/code/qml_transforms.html#transforms-for-circuit-compilation).\r\n<h4>QNodes are even more powerful</h4>\r\n\r\n  * Computational basis samples directly from the underlying device can  now be returned directly from QNodes via `qml.sample()`. [(#1441)](https://github.com/PennyLaneAI/pennylane/pull/1441)\r\n\r\n  ```python\r\n  dev = qml.device(\"default.qubit\", wires=3, shots=5)\r\n\r\n  @qml.qnode(dev)\r\n  def circuit_1():\r\n      qml.Hadamard(wires=0)\r\n      qml.Hadamard(wires=1)\r\n      return qml.sample()\r\n\r\n  @qml.qnode(dev)\r\n  def circuit_2():\r\n      qml.Hadamard(wires=0)\r\n      qml.Hadamard(wires=1)\r\n      return qml.sample(wires=[0,2])    # no observable provided and wires specified\r\n  ```\r\n\r\n  ```pycon\r\n  >>> print(circuit_1())\r\n  [[1, 0, 0],\r\n   [1, 1, 0],\r\n   [1, 0, 0],\r\n   [0, 0, 0],\r\n   [0, 1, 0]]\r\n\r\n  >>> print(circuit_2())\r\n  [[1, 0],\r\n   [1, 0],\r\n   [1, 0],\r\n   [0, 0],\r\n   [0, 0]]\r\n\r\n  >>> print(qml.draw(circuit_2)())\r\n   0: \u2500\u2500H\u2500\u2500\u256d\u2524 Sample[basis]\r\n   1: \u2500\u2500H\u2500\u2500\u2502\u2524\r\n   2: \u2500\u2500\u2500\u2500\u2500\u2570\u2524 Sample[basis]\r\n  ```\r\n\r\n* The new `qml.apply` function can be used to add operations that might have already been instantiated elsewhere to the QNode and other queuing contexts: [(#1433)](https://github.com/PennyLaneAI/pennylane/pull/1433)\r\n\r\n  ```python\r\n  op = qml.RX(0.4, wires=0)\r\n  dev = qml.device(\"default.qubit\", wires=2)\r\n\r\n  @qml.qnode(dev)\r\n  def circuit(x):\r\n      qml.RY(x, wires=0)\r\n      qml.apply(op)\r\n      return qml.expval(qml.PauliZ(0))\r\n  ```\r\n\r\n  ```pycon\r\n  >>> print(qml.draw(circuit)(0.6))\r\n  0: \u2500\u2500RY(0.6)\u2500\u2500RX(0.4)\u2500\u2500\u2524 \u27e8Z\u27e9\r\n  ```\r\n\r\n  Previously instantiated measurements can also be applied to QNodes.\r\n\r\n<h4>Device Resource Tracker</h4>\r\n\r\n* The new Device Tracker capabilities allows for flexible and versatile tracking of executions, even inside parameter-shift gradients. This functionality will improve the ease of monitoring large batches and remote jobs. [(#1355)](https://github.com/PennyLaneAI/pennylane/pull/1355)\r\n\r\n  ```python\r\n  dev = qml.device('default.qubit', wires=1, shots=100)\r\n\r\n  @qml.qnode(dev, diff_method=\"parameter-shift\")\r\n  def circuit(x):\r\n      qml.RX(x, wires=0)\r\n      return qml.expval(qml.PauliZ(0))\r\n\r\n  x = np.array(0.1)\r\n\r\n  with qml.Tracker(circuit.device) as tracker:\r\n      qml.grad(circuit)(x)\r\n  ```\r\n\r\n  ```pycon\r\n  >>> tracker.totals\r\n  {'executions': 3, 'shots': 300, 'batches': 1, 'batch_len': 2}\r\n  >>> tracker.history\r\n  {'executions': [1, 1, 1],\r\n   'shots': [100, 100, 100],\r\n   'batches': [1],\r\n   'batch_len': [2]}\r\n  >>> tracker.latest\r\n  {'batches': 1, 'batch_len': 2}\r\n  ```\r\n\r\n  Users can also provide a custom function to the `callback` keyword that gets called each time the information is updated. This functionality allows users to monitor remote jobs or large  parameter-shift batches.\r\n\r\n  ```pycon\r\n  >>> def shots_info(totals, history, latest):\r\n  ...     print(\"Total shots: \", totals['shots'])\r\n  >>> with qml.Tracker(circuit.device, callback=shots_info) as tracker:\r\n  ...     qml.grad(circuit)(0.1)\r\n  Total shots:  100\r\n  Total shots:  200\r\n  Total shots:  300\r\n  Total shots:  300\r\n  ```\r\n\r\n<h4>Containerization support</h4>\r\n\r\n* Docker support for building PennyLane with support for all interfaces (TensorFlow, Torch, and Jax), as well as device plugins and QChem, for GPUs and CPUs, has been added. [(#1391)](https://github.com/PennyLaneAI/pennylane/pull/1391)\r\n\r\n  The build process using Docker and `make` requires that the repository source code is cloned or downloaded from GitHub. Visit the the detailed description for an [extended list of  options](https://pennylane.readthedocs.io/en/stable/development/guide/installation.html#installation).\r\n\r\n<h4>Improved Hamiltonian simulations</h4>\r\n\r\n* Added a sparse Hamiltonian observable and the functionality to support computing its expectation value with `default.qubit`. [(#1398)](https://github.com/PennyLaneAI/pennylane/pull/1398)\r\n\r\n  For example, the following QNode returns the expectation value of a sparse Hamiltonian:\r\n\r\n  ```python\r\n  dev = qml.device(\"default.qubit\", wires=2)\r\n\r\n  @qml.qnode(dev, diff_method=\"parameter-shift\")\r\n  def circuit(param, H):\r\n      qml.PauliX(0)\r\n      qml.SingleExcitation(param, wires=[0, 1])\r\n      return qml.expval(qml.SparseHamiltonian(H, [0, 1]))\r\n  ```\r\n\r\n  We can execute this QNode, passing in a sparse identity matrix:\r\n\r\n  ```pycon\r\n  >>> print(circuit([0.5], scipy.sparse.eye(4).tocoo()))\r\n  0.9999999999999999\r\n  ```\r\n\r\n  The expectation value of the sparse Hamiltonian is computed directly, which leads to executions that are faster by orders of magnitude. Note that \"parameter-shift\" is the only differentiation method that is currently supported when the observable is a sparse Hamiltonian.\r\n\r\n* VQE problems can now be intuitively set up by passing the Hamiltonian as an observable. [(#1474)](https://github.com/PennyLaneAI/pennylane/pull/1474)\r\n\r\n  ``` python\r\n  dev = qml.device(\"default.qubit\", wires=2)\r\n  H = qml.Hamiltonian([1., 2., 3.],  [qml.PauliZ(0), qml.PauliY(0), qml.PauliZ(1)])\r\n  w = qml.init.strong_ent_layers_uniform(1, 2, seed=1967)\r\n\r\n  @qml.qnode(dev)\r\n  def circuit(w):\r\n      qml.templates.StronglyEntanglingLayers(w, wires=range(2))\r\n      return qml.expval(H)\r\n  ```\r\n\r\n  ```pycon\r\n  >>> print(circuit(w))\r\n  -1.5133943637878295\r\n  >>> print(qml.grad(circuit)(w))\r\n  [[[-8.32667268e-17  1.39122955e+00 -9.12462052e-02]\r\n  [ 1.02348685e-16 -7.77143238e-01 -1.74708049e-01]]]\r\n  ```\r\n\r\n  Note that other measurement types like `var(H)` or `sample(H)`, as well as multiple expectations like `expval(H1), expval(H2)` are not supported.\r\n\r\n* Added functionality to compute the sparse matrix representation of a `qml.Hamiltonian` object. [(#1394)](https://github.com/PennyLaneAI/pennylane/pull/1394)\r\n\r\n<h4>New gradients module</h4>\r\n\r\n* A new gradients module `qml.gradients` has been added, which provides differentiable quantum gradient transforms. [(#1476)](https://github.com/PennyLaneAI/pennylane/pull/1476) [(#1479)](https://github.com/PennyLaneAI/pennylane/pull/1479) [(#1486)](https://github.com/PennyLaneAI/pennylane/pull/1486)\r\n\r\n  Available quantum gradient transforms include:\r\n\r\n  - `qml.gradients.finite_diff`\r\n  - `qml.gradients.param_shift`\r\n  - `qml.gradients.param_shift_cv`\r\n\r\n  For example,\r\n\r\n  ```pycon\r\n  >>> params = np.array([0.3,0.4,0.5], requires_grad=True)\r\n  >>> with qml.tape.JacobianTape() as tape:\r\n  ...     qml.RX(params[0], wires=0)\r\n  ...     qml.RY(params[1], wires=0)\r\n  ...     qml.RX(params[2], wires=0)\r\n  ...     qml.expval(qml.PauliZ(0))\r\n  ...     qml.var(qml.PauliZ(0))\r\n  >>> tape.trainable_params = {0, 1, 2}\r\n  >>> gradient_tapes, fn = qml.gradients.finite_diff(tape)\r\n  >>> res = dev.batch_execute(gradient_tapes)\r\n  >>> fn(res)\r\n  array([[-0.69688381, -0.32648317, -0.68120105],\r\n         [ 0.8788057 ,  0.41171179,  0.85902895]])\r\n  ```\r\n\r\n<h4>Even more new operations and templates</h4>\r\n\r\n* Grover Diffusion Operator template added. [(#1442)](https://github.com/PennyLaneAI/pennylane/pull/1442)\r\n\r\n  For example, if we have an oracle that marks the \"all ones\" state with a negative sign:\r\n\r\n  ```python\r\n  n_wires = 3\r\n  wires = list(range(n_wires))\r\n\r\n  def oracle():\r\n      qml.Hadamard(wires[-1])\r\n      qml.Toffoli(wires=wires)\r\n      qml.Hadamard(wires[-1])\r\n  ```\r\n\r\n  We can perform [Grover's Search Algorithm](https://en.wikipedia.org/wiki/Grover%27s_algorithm):\r\n\r\n  ```python\r\n  dev = qml.device('default.qubit', wires=wires)\r\n\r\n  @qml.qnode(dev)\r\n  def GroverSearch(num_iterations=1):\r\n      for wire in wires:\r\n          qml.Hadamard(wire)\r\n\r\n      for _ in range(num_iterations):\r\n          oracle()\r\n          qml.templates.GroverOperator(wires=wires)\r\n\r\n      return qml.probs(wires)\r\n  ```\r\n\r\n  We can see this circuit yields the marked state with high probability:\r\n\r\n  ```pycon\r\n  >>> GroverSearch(num_iterations=1)\r\n  tensor([0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125,\r\n          0.78125], requires_grad=True)\r\n  >>> GroverSearch(num_iterations=2)\r\n  tensor([0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125,\r\n      0.0078125, 0.9453125], requires_grad=True)\r\n  ```\r\n\r\n* A decomposition has been added to `QubitUnitary` that makes the single-qubit case fully differentiable in all interfaces. Furthermore, a quantum function transform, `unitary_to_rot()`, has been added to decompose all single-qubit instances of `QubitUnitary` in a quantum circuit. [(#1427)](https://github.com/PennyLaneAI/pennylane/pull/1427)\r\n\r\n  Instances of `QubitUnitary` may now be decomposed directly to `Rot` operations, or `RZ` operations if the input matrix is diagonal. For example, let\r\n\r\n  ```python\r\n  >>> U = np.array([\r\n      [-0.28829348-0.78829734j,  0.30364367+0.45085995j],\r\n      [ 0.53396245-0.10177564j,  0.76279558-0.35024096j]\r\n  ])\r\n  ```\r\n\r\n  Then, we can compute the decomposition as:\r\n\r\n  ```pycon\r\n  >>> qml.QubitUnitary.decomposition(U, wires=0)\r\n  [Rot(-0.24209530281458358, 1.1493817777199102, 1.733058145303424, wires=[0])]\r\n  ```\r\n\r\n  We can also apply the transform directly to a quantum function, and compute the gradients of parameters used to construct the unitary matrices.\r\n\r\n  ```python\r\n  def qfunc_with_qubit_unitary(angles):\r\n      z, x = angles[0], angles[1]\r\n\r\n      Z_mat = np.array([[np.exp(-1j * z / 2), 0.0], [0.0, np.exp(1j * z / 2)]])\r\n\r\n      c = np.cos(x / 2)\r\n      s = np.sin(x / 2) * 1j\r\n      X_mat = np.array([[c, -s], [-s, c]])\r\n\r\n      qml.Hadamard(wires=\"a\")\r\n      qml.QubitUnitary(Z_mat, wires=\"a\")\r\n      qml.QubitUnitary(X_mat, wires=\"b\")\r\n      qml.CNOT(wires=[\"b\", \"a\"])\r\n      return qml.expval(qml.PauliX(wires=\"a\"))\r\n  ```\r\n\r\n  ```pycon\r\n  >>> dev = qml.device(\"default.qubit\", wires=[\"a\", \"b\"])\r\n  >>> transformed_qfunc = qml.transforms.unitary_to_rot(qfunc_with_qubit_unitary)\r\n  >>> transformed_qnode = qml.QNode(transformed_qfunc, dev)\r\n  >>> input = np.array([0.3, 0.4], requires_grad=True)\r\n  >>> transformed_qnode(input)\r\n  tensor(0.95533649, requires_grad=True)\r\n  >>> qml.grad(transformed_qnode)(input)\r\n  array([-0.29552021,  0.        ])\r\n  ```\r\n\r\n* Ising YY gate functionality added. [(#1358)](https://github.com/PennyLaneAI/pennylane/pull/1358)\r\n\r\n\r\n<h3>Improvements</h3>\r\n\r\n* The `step` and `step_and_cost` methods of `QNGOptimizer` now accept a custom `grad_fn` keyword argument to use for gradient computations. [(#1487)](https://github.com/PennyLaneAI/pennylane/pull/1487)\r\n\r\n* The precision used by `default.qubit.jax` now matches the float precision indicated by\r\n\r\n  ```python\r\n  from jax.config import config\r\n  config.read('jax_enable_x64')\r\n  ```\r\n  where `True` means `float64`/`complex128` and `False` means `float32`/`complex64`. [(#1485)](https://github.com/PennyLaneAI/pennylane/pull/1485)\r\n\r\n* The `./pennylane/ops/qubit.py` file is broken up into a folder of six separate files. [(#1467)](https://github.com/PennyLaneAI/pennylane/pull/1467)\r\n\r\n* Changed to using commas as the separator of wires in the string representation of `qml.Hamiltonian` objects for multi-qubit terms. [(#1465)](https://github.com/PennyLaneAI/pennylane/pull/1465)\r\n\r\n* Changed to using `np.object_` instead of `np.object` as per the NumPy deprecations starting version 1.20. [(#1466)](https://github.com/PennyLaneAI/pennylane/pull/1466)\r\n\r\n* Change the order of the covariance matrix and the vector of means internally in `default.gaussian`. [(#1331)](https://github.com/PennyLaneAI/pennylane/pull/1331)\r\n\r\n* Added the `id` attribute to templates. [(#1438)](https://github.com/PennyLaneAI/pennylane/pull/1438)\r\n\r\n* The `qml.math` module, for framework-agnostic tensor manipulation, has two new functions available: [(#1490)](https://github.com/PennyLaneAI/pennylane/pull/1490)\r\n\r\n  - `qml.math.get_trainable_indices(sequence_of_tensors)`: returns the indices corresponding to trainable tensors in the input sequence.\r\n\r\n  - `qml.math.unwrap(sequence_of_tensors)`: unwraps a sequence of tensor-like objects to NumPy arrays.\r\n\r\n  In addition, the behaviour of `qml.math.requires_grad` has been improved in order to correctly determine trainability during Autograd and JAX backwards passes.\r\n\r\n* A new tape method, `tape.unwrap()` is added. This method is a context manager; inside the context, the tape's parameters are unwrapped to NumPy arrays and floats, and the trainable parameter indices are set. [(#1491)](https://github.com/PennyLaneAI/pennylane/pull/1491)\r\n\r\n  These changes are temporary, and reverted on exiting the context.\r\n\r\n  ```pycon\r\n  >>> with tf.GradientTape():\r\n  ...     with qml.tape.QuantumTape() as tape:\r\n  ...         qml.RX(tf.Variable(0.1), wires=0)\r\n  ...         qml.RY(tf.constant(0.2), wires=0)\r\n  ...         qml.RZ(tf.Variable(0.3), wires=0)\r\n  ...     with tape.unwrap():\r\n  ...         print(\"Trainable params:\", tape.trainable_params)\r\n  ...         print(\"Unwrapped params:\", tape.get_parameters())\r\n  Trainable params: {0, 2}\r\n  Unwrapped params: [0.1, 0.3]\r\n  >>> print(\"Original parameters:\", tape.get_parameters())\r\n  Original parameters: [<tf.Variable 'Variable:0' shape=() dtype=float32, numpy=0.1>,\r\n    <tf.Variable 'Variable:0' shape=() dtype=float32, numpy=0.3>]\r\n  ```\r\n\r\n  In addition, `qml.tape.Unwrap` is a context manager that unwraps multiple tapes:\r\n\r\n  ```pycon\r\n  >>> with qml.tape.Unwrap(tape1, tape2):\r\n  ```\r\n\r\n<h3>Breaking changes</h3>\r\n\r\n* Removed the deprecated tape methods `get_resources` and `get_depth` as they are superseded by the `specs` tape attribute. [(#1522)](https://github.com/PennyLaneAI/pennylane/pull/1522)\r\n\r\n* Specifying `shots=None` with `qml.sample` was previously deprecated. From this release onwards, setting `shots=None` when sampling will raise an error. [(#1522)](https://github.com/PennyLaneAI/pennylane/pull/1522)\r\n\r\n* The existing `pennylane.collections.apply` function is no longer accessible via `qml.apply`, and needs to be imported directly from the `collections` package. [(#1358)](https://github.com/PennyLaneAI/pennylane/pull/1358)\r\n\r\n<h3>Bug fixes</h3>\r\n\r\n* Fixes a bug in `qml.adjoint` and `qml.ctrl` where the adjoint of operations outside of a `QNode` or a `QuantumTape` could not be obtained. [(#1532)](https://github.com/PennyLaneAI/pennylane/pull/1532)\r\n\r\n* Fixes a bug in `GradientDescentOptimizer` and `NesterovMomentumOptimizer` where a cost function with one trainable parameter and non-trainable parameters raised an error. [(#1495)](https://github.com/PennyLaneAI/pennylane/pull/1495)\r\n\r\n* Fixed an example in the documentation's [introduction to numpy gradients](https://pennylane.readthedocs.io/en/stable/introduction/interfaces/numpy.html), where the wires were a non-differentiable argument to the QNode. [(#1499)](https://github.com/PennyLaneAI/pennylane/pull/1499)\r\n\r\n* Fixed a bug where the adjoint of `qml.QFT` when using the `qml.adjoint` function was not correctly computed. [(#1451)](https://github.com/PennyLaneAI/pennylane/pull/1451)\r\n\r\n* Fixed the differentiability of the operation`IsingYY` for Autograd, Jax and Tensorflow. [(#1425)](https://github.com/PennyLaneAI/pennylane/pull/1425)\r\n\r\n* Fixed a bug in the `torch` interface that prevented gradients from being computed on a GPU. [(#1426)](https://github.com/PennyLaneAI/pennylane/pull/1426)\r\n\r\n* Quantum function transforms now preserve the format of the measurement results, so that a single measurement returns a single value rather than an array with a single element. [(#1434)](https://github.com/PennyLaneAI/pennylane/pull/1434)\r\n\r\n* Fixed a bug in the parameter-shift Hessian implementation, which resulted in the incorrect Hessian being returned for a cost function that performed post-processing on a vector-valued QNode. [(#1436)](https://github.com/PennyLaneAI/pennylane/pull/1436)\r\n\r\n* Fixed a bug in the initialization of `QubitUnitary` where the size of the matrix was not checked against the number of wires. [(#1439)](https://github.com/PennyLaneAI/pennylane/pull/1439)\r\n\r\n<h3>Documentation</h3>\r\n\r\n* Improved Contribution Guide and Pull Requests Guide. [(#1461)](https://github.com/PennyLaneAI/pennylane/pull/1461)\r\n\r\n* Examples have been added to clarify use of the continuous-variable `FockStateVector` operation in the multi-mode case. [(#1472)](https://github.com/PennyLaneAI/pennylane/pull/1472)\r\n\r\n<h3>Contributors</h3>\r\n\r\nThis release contains contributions from (in alphabetical order):\r\n\r\nJuan Miguel Arrazola, Olivia Di Matteo, Anthony Hayes, Theodor Isacsson, Josh Izaac, Soran Jahangiri, Nathan Killoran, Arshpreet Singh Khangura, Leonhard Kunczik, Christina Lee, Romain Moyard, Lee James O'Riordan, Ashish Panigrahi, Nahum S\u00e1, Maria Schuld, Jay Soni, Antal Sz\u00e1va, David Wierichs."}
{"url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/44997246", "assets_url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/44997246/assets", "upload_url": "https://uploads.github.com/repos/PennyLaneAI/pennylane/releases/44997246/assets{?name,label}", "html_url": "https://github.com/PennyLaneAI/pennylane/releases/tag/v0.16.0", "id": 44997246, "author": {"login": "antalszava", "id": 24476053, "node_id": "MDQ6VXNlcjI0NDc2MDUz", "avatar_url": "https://avatars.githubusercontent.com/u/24476053?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antalszava", "html_url": "https://github.com/antalszava", "followers_url": "https://api.github.com/users/antalszava/followers", "following_url": "https://api.github.com/users/antalszava/following{/other_user}", "gists_url": "https://api.github.com/users/antalszava/gists{/gist_id}", "starred_url": "https://api.github.com/users/antalszava/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antalszava/subscriptions", "organizations_url": "https://api.github.com/users/antalszava/orgs", "repos_url": "https://api.github.com/users/antalszava/repos", "events_url": "https://api.github.com/users/antalszava/events{/privacy}", "received_events_url": "https://api.github.com/users/antalszava/received_events", "type": "User", "site_admin": false}, "node_id": "MDc6UmVsZWFzZTQ0OTk3MjQ2", "tag_name": "v0.16.0", "target_commitish": "v0.16.0-rc0", "name": "Release 0.16.0", "draft": false, "prerelease": false, "created_at": "2021-06-22T01:19:56Z", "published_at": "2021-06-22T01:40:15Z", "assets": [], "tarball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/tarball/v0.16.0", "zipball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/zipball/v0.16.0", "body": "<h3>New features since last release</h3>\r\n\r\n<h4>First class support for quantum kernels</h4>\r\n\r\n* The new `qml.kernels` module provides basic functionalities for [working with quantum kernels](https://pennylane.readthedocs.io/en/stable/code/qml_kernels.html) as well as post-processing methods to mitigate sampling errors and device noise: [(#1102)](https://github.com/PennyLaneAI/pennylane/pull/1102)\r\n\r\n  ```python\r\n\r\n  num_wires = 6\r\n  wires = range(num_wires)\r\n  dev = qml.device('default.qubit', wires=wires)\r\n\r\n  @qml.qnode(dev)\r\n  def kernel_circuit(x1, x2):\r\n      qml.templates.AngleEmbedding(x1, wires=wires)\r\n      qml.adjoint(qml.templates.AngleEmbedding)(x2, wires=wires)\r\n      return qml.probs(wires)\r\n\r\n  kernel = lambda x1, x2: kernel_circuit(x1, x2)[0]\r\n  X_train = np.random.random((10, 6))\r\n  X_test = np.random.random((5, 6))\r\n\r\n  # Create symmetric square kernel matrix (for training)\r\n  K = qml.kernels.square_kernel_matrix(X_train, kernel)\r\n\r\n  # Compute kernel between test and training data.\r\n  K_test = qml.kernels.kernel_matrix(X_train, X_test, kernel)\r\n  K1 = qml.kernels.mitigate_depolarizing_noise(K, num_wires, method='single')\r\n  ```\r\n\r\n<h4>Extract the fourier representation of quantum circuits</h4>\r\n\r\n* PennyLane now has a `fourier` module, which hosts a [growing library of methods](https://pennylane.readthedocs.io/en/stable/code/qml_fourier.html) that help with investigating the Fourier representation of functions implemented by quantum circuits. The Fourier representation can be used to examine and characterize the expressivity of the quantum circuit. [(#1160)](https://github.com/PennyLaneAI/pennylane/pull/1160) [(#1378)](https://github.com/PennyLaneAI/pennylane/pull/1378)\r\n\r\n  For example, one can plot distributions over Fourier series coefficients like this one:\r\n\r\n  <img src=\"https://pennylane.readthedocs.io/en/latest/_static/fourier.png\" width=70%/>\r\n\r\n<h4>Seamless support for working with the Pauli group</h4>\r\n\r\n* Added functionality for constructing and manipulating the Pauli group [(#1181)](https://github.com/PennyLaneAI/pennylane/pull/1181).\r\n\r\n  The function `qml.grouping.pauli_group` provides a generator to easily loop over the group, or construct and store it in its entirety. For example, we can construct the single-qubit Pauli group like so:\r\n\r\n  ```pycon\r\n  >>> from pennylane.grouping import pauli_group\r\n  >>> pauli_group_1_qubit = list(pauli_group(1))\r\n  >>> pauli_group_1_qubit\r\n  [Identity(wires=[0]), PauliZ(wires=[0]), PauliX(wires=[0]), PauliY(wires=[0])]\r\n  ```\r\n\r\n  We can multiply together its members at the level of Pauli words using the `pauli_mult` and `pauli_multi_with_phase` functions. This can be done on arbitrarily-labeled wires as well, by defining a wire map.\r\n\r\n  ```pycon\r\n  >>> from pennylane.grouping import pauli_group, pauli_mult\r\n  >>> wire_map = {'a' : 0, 'b' : 1, 'c' : 2}\r\n  >>> pg = list(pauli_group(3, wire_map=wire_map))\r\n  >>> pg[3]\r\n  PauliZ(wires=['b']) @ PauliZ(wires=['c'])\r\n  >>> pg[55]\r\n  PauliY(wires=['a']) @ PauliY(wires=['b']) @ PauliZ(wires=['c'])\r\n  >>> pauli_mult(pg[3], pg[55], wire_map=wire_map)\r\n  PauliY(wires=['a']) @ PauliX(wires=['b'])\r\n  ```\r\n\r\n  Functions for conversion of Pauli observables to strings (and back) are included.\r\n\r\n  ```pycon\r\n  >>> from pennylane.grouping import pauli_word_to_string, string_to_pauli_word\r\n  >>> pauli_word_to_string(pg[55], wire_map=wire_map)\r\n  'YYZ'\r\n  >>> string_to_pauli_word('ZXY', wire_map=wire_map)\r\n  PauliZ(wires=['a']) @ PauliX(wires=['b']) @ PauliY(wires=['c'])\r\n  ```\r\n\r\n  Calculation of the matrix representation for arbitrary Paulis and wire maps is now also supported.\r\n\r\n  ```pycon\r\n  >>> from pennylane.grouping import pauli_word_to_matrix\r\n  >>> wire_map = {'a' : 0, 'b' : 1}\r\n  >>> pauli_word = qml.PauliZ('b')  # corresponds to Pauli 'IZ'\r\n  >>> pauli_word_to_matrix(pauli_word, wire_map=wire_map)\r\n  array([[ 1.,  0.,  0.,  0.],\r\n         [ 0., -1.,  0., -0.],\r\n         [ 0.,  0.,  1.,  0.],\r\n         [ 0., -0.,  0., -1.]])\r\n  ```\r\n\r\n<h4>New transforms</h4>\r\n\r\n* The `qml.specs` QNode transform creates a function that returns specifications or details about the QNode, including depth, number of gates, and number of gradient executions required. [(#1245)](https://github.com/PennyLaneAI/pennylane/pull/1245)\r\n\r\n  For example:\r\n\r\n  ```python\r\n  dev = qml.device('default.qubit', wires=4)\r\n\r\n  @qml.qnode(dev, diff_method='parameter-shift')\r\n  def circuit(x, y):\r\n      qml.RX(x[0], wires=0)\r\n      qml.Toffoli(wires=(0, 1, 2))\r\n      qml.CRY(x[1], wires=(0, 1))\r\n      qml.Rot(x[2], x[3], y, wires=0)\r\n      return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliX(1))\r\n  ```\r\n\r\n  We can now use the `qml.specs` transform to generate a function that returns details and resource information:\r\n\r\n  ```pycon\r\n  >>> x = np.array([0.05, 0.1, 0.2, 0.3], requires_grad=True)\r\n  >>> y = np.array(0.4, requires_grad=False)\r\n  >>> specs_func = qml.specs(circuit)\r\n  >>> specs_func(x, y)\r\n  {'gate_sizes': defaultdict(int, {1: 2, 3: 1, 2: 1}),\r\n   'gate_types': defaultdict(int, {'RX': 1, 'Toffoli': 1, 'CRY': 1, 'Rot': 1}),\r\n   'num_operations': 4,\r\n   'num_observables': 2,\r\n   'num_diagonalizing_gates': 1,\r\n   'num_used_wires': 3,\r\n   'depth': 4,\r\n   'num_trainable_params': 4,\r\n   'num_parameter_shift_executions': 11,\r\n   'num_device_wires': 4,\r\n   'device_name': 'default.qubit',\r\n   'diff_method': 'parameter-shift'}\r\n  ```\r\n\r\n  The tape methods `get_resources` and `get_depth` are superseded by `specs` and will be deprecated after one release cycle.\r\n\r\n* Adds a decorator `@qml.qfunc_transform` to easily create a transformation that modifies the behaviour of a quantum function.\r\n  [(#1315)](https://github.com/PennyLaneAI/pennylane/pull/1315)\r\n\r\n  For example, consider the following transform, which scales the parameter of all `RX` gates by :math:`x \\rightarrow \\sin(a) \\sqrt{x}`, and the parameters of all `RY` gates by :math:`y \\rightarrow \\cos(a * b) y`:\r\n\r\n  ```python\r\n  @qml.qfunc_transform\r\n  def my_transform(tape, a, b):\r\n      for op in tape.operations + tape.measurements:\r\n          if op.name == \"RX\":\r\n              x = op.parameters[0]\r\n              qml.RX(qml.math.sin(a) * qml.math.sqrt(x), wires=op.wires)\r\n          elif op.name == \"RY\":\r\n              y = op.parameters[0]\r\n              qml.RX(qml.math.cos(a * b) * y, wires=op.wires)\r\n          else:\r\n              op.queue()\r\n  ```\r\n\r\n  We can now apply this transform to any quantum function:\r\n\r\n  ```python\r\n  dev = qml.device(\"default.qubit\", wires=2)\r\n\r\n  def ansatz(x):\r\n      qml.Hadamard(wires=0)\r\n      qml.RX(x[0], wires=0)\r\n      qml.RY(x[1], wires=1)\r\n      qml.CNOT(wires=[0, 1])\r\n\r\n  @qml.qnode(dev)\r\n  def circuit(params, transform_weights):\r\n      qml.RX(0.1, wires=0)\r\n\r\n      # apply the transform to the ansatz\r\n      my_transform(*transform_weights)(ansatz)(params)\r\n\r\n      return qml.expval(qml.PauliZ(1))\r\n  ```\r\n\r\n  We can print this QNode to show that the qfunc transform is taking place:\r\n\r\n  ```pycon\r\n  >>> x = np.array([0.5, 0.3], requires_grad=True)\r\n  >>> transform_weights = np.array([0.1, 0.6], requires_grad=True)\r\n  >>> print(qml.draw(circuit)(x, transform_weights))\r\n   0: \u2500\u2500RX(0.1)\u2500\u2500\u2500\u2500H\u2500\u2500RX(0.0706)\u2500\u2500\u256dC\u2500\u2500\u2524\r\n   1: \u2500\u2500RX(0.299)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2570X\u2500\u2500\u2524 \u27e8Z\u27e9\r\n  ```\r\n\r\n  Evaluating the QNode, as well as the derivative, with respect to the gate parameter *and* the transform weights:\r\n\r\n  ```pycon\r\n  >>> circuit(x, transform_weights)\r\n  tensor(0.00672829, requires_grad=True)\r\n  >>> qml.grad(circuit)(x, transform_weights)\r\n  (array([ 0.00671711, -0.00207359]), array([6.69695008e-02, 3.73694364e-06]))\r\n  ```\r\n\r\n* Adds a `hamiltonian_expand` tape transform. This takes a tape ending in `qml.expval(H)`, where `H` is a Hamiltonian, and maps it to a collection of tapes which can be executed and passed into a post-processing function yielding the expectation value. [(#1142)](https://github.com/PennyLaneAI/pennylane/pull/1142)\r\n\r\n  Example use:\r\n\r\n  ```python\r\n  H = qml.PauliZ(0) + 3 * qml.PauliZ(0) @ qml.PauliX(1)\r\n\r\n  with qml.tape.QuantumTape() as tape:\r\n      qml.Hadamard(wires=1)\r\n      qml.expval(H)\r\n\r\n  tapes, fn = qml.transforms.hamiltonian_expand(tape)\r\n  ```\r\n\r\n  We can now evaluate the transformed tapes, and apply the post-processing function:\r\n\r\n  ```pycon\r\n  >>> dev = qml.device(\"default.qubit\", wires=3)\r\n  >>> res = dev.batch_execute(tapes)\r\n  >>> fn(res)\r\n  3.999999999999999\r\n  ```\r\n\r\n* The `quantum_monte_carlo` transform has been added, allowing an input circuit to be transformed into the full quantum Monte Carlo algorithm. [(#1316)](https://github.com/PennyLaneAI/pennylane/pull/1316)\r\n\r\n  Suppose we want to measure the expectation value of the sine squared function according to a standard normal distribution. We can calculate the expectation value analytically as `0.432332`, but we can also estimate using the quantum Monte Carlo algorithm. The first step is to discretize the problem:\r\n\r\n  ```python\r\n  from scipy.stats import norm\r\n\r\n  m = 5\r\n  M = 2 ** m\r\n\r\n  xmax = np.pi  # bound to region [-pi, pi]\r\n  xs = np.linspace(-xmax, xmax, M)\r\n\r\n  probs = np.array([norm().pdf(x) for x in xs])\r\n  probs /= np.sum(probs)\r\n\r\n  func = lambda i: np.sin(xs[i]) ** 2\r\n  r_rotations = np.array([2 * np.arcsin(np.sqrt(func(i))) for i in range(M)])\r\n  ```\r\n\r\n  The `quantum_monte_carlo` transform can then be used:\r\n\r\n  ```python\r\n  from pennylane.templates.state_preparations.mottonen import (\r\n      _uniform_rotation_dagger as r_unitary,\r\n  )\r\n\r\n  n = 6\r\n  N = 2 ** n\r\n\r\n  a_wires = range(m)\r\n  wires = range(m + 1)\r\n  target_wire = m\r\n  estimation_wires = range(m + 1, n + m + 1)\r\n\r\n  dev = qml.device(\"default.qubit\", wires=(n + m + 1))\r\n\r\n  def fn():\r\n      qml.templates.MottonenStatePreparation(np.sqrt(probs), wires=a_wires)\r\n      r_unitary(qml.RY, r_rotations, control_wires=a_wires[::-1], target_wire=target_wire)\r\n\r\n  @qml.qnode(dev)\r\n  def qmc():\r\n      qml.quantum_monte_carlo(fn, wires, target_wire, estimation_wires)()\r\n      return qml.probs(estimation_wires)\r\n\r\n  phase_estimated = np.argmax(qmc()[:int(N / 2)]) / N\r\n  ```\r\n\r\n  The estimated value can be retrieved using:\r\n\r\n  ```pycon\r\n  >>> (1 - np.cos(np.pi * phase_estimated)) / 2\r\n  0.42663476277231915\r\n  ```\r\n\r\n  The resources required to perform the quantum Monte Carlo algorithm can also be inspected using the `specs` transform.\r\n\r\n<h4>Extended QAOA module</h4>\r\n\r\n* Functionality to support solving the maximum-weighted cycle problem has been added to the `qaoa`\r\n  module. [(#1207)](https://github.com/PennyLaneAI/pennylane/pull/1207) [(#1209)](https://github.com/PennyLaneAI/pennylane/pull/1209) [(#1251)](https://github.com/PennyLaneAI/pennylane/pull/1251) [(#1213)](https://github.com/PennyLaneAI/pennylane/pull/1213) [(#1220)](https://github.com/PennyLaneAI/pennylane/pull/1220) [(#1214)](https://github.com/PennyLaneAI/pennylane/pull/1214) [(#1283)](https://github.com/PennyLaneAI/pennylane/pull/1283) [(#1297)](https://github.com/PennyLaneAI/pennylane/pull/1297) [(#1396)](https://github.com/PennyLaneAI/pennylane/pull/1396) [(#1403)](https://github.com/PennyLaneAI/pennylane/pull/1403)\r\n\r\n  The `max_weight_cycle` function returns the appropriate cost and mixer Hamiltonians:\r\n\r\n  ```pycon\r\n  >>> a = np.random.random((3, 3))\r\n  >>> np.fill_diagonal(a, 0)\r\n  >>> g = nx.DiGraph(a)  # create a random directed graph\r\n  >>> cost, mixer, mapping = qml.qaoa.max_weight_cycle(g)\r\n  >>> print(cost)\r\n    (-0.9775906842165344) [Z2]\r\n  + (-0.9027248603361988) [Z3]\r\n  + (-0.8722207409852838) [Z0]\r\n  + (-0.6426184210832898) [Z5]\r\n  + (-0.2832594164291379) [Z1]\r\n  + (-0.0778133996933755) [Z4]\r\n  >>> print(mapping)\r\n  {0: (0, 1), 1: (0, 2), 2: (1, 0), 3: (1, 2), 4: (2, 0), 5: (2, 1)}\r\n  ```\r\n  Additional functionality can be found in the [qml.qaoa.cycle](https://pennylane.readthedocs.io/en/latest/code/api/pennylane.qaoa.cycle.html) module.\r\n\r\n\r\n<h4>Extended operations and templates</h4>\r\n\r\n* Added functionality to compute the sparse matrix representation of a `qml.Hamiltonian` object. [(#1394)](https://github.com/PennyLaneAI/pennylane/pull/1394)\r\n\r\n  ```python\r\n  coeffs = [1, -0.45]\r\n  obs = [qml.PauliZ(0) @ qml.PauliZ(1), qml.PauliY(0) @ qml.PauliZ(1)]\r\n  H = qml.Hamiltonian(coeffs, obs)\r\n  H_sparse = qml.utils.sparse_hamiltonian(H)\r\n  ```\r\n\r\n  The resulting matrix is a sparse matrix in scipy coordinate list (COO) format:\r\n\r\n  ```python\r\n  >>> H_sparse\r\n  <4x4 sparse matrix of type '<class 'numpy.complex128'>'\r\n      with 8 stored elements in COOrdinate format>\r\n  ```\r\n\r\n  The sparse matrix can be converted to an array as:\r\n\r\n  ```python\r\n  >>> H_sparse.toarray()\r\n  array([[ 1.+0.j  ,  0.+0.j  ,  0.+0.45j,  0.+0.j  ],\r\n         [ 0.+0.j  , -1.+0.j  ,  0.+0.j  ,  0.-0.45j],\r\n         [ 0.-0.45j,  0.+0.j  , -1.+0.j  ,  0.+0.j  ],\r\n         [ 0.+0.j  ,  0.+0.45j,  0.+0.j  ,  1.+0.j  ]])\r\n  ```\r\n\r\n* Adds the new template `AllSinglesDoubles` to prepare quantum states of molecules using the `SingleExcitation` and `DoubleExcitation` operations. The new template reduces significantly the number of operations and the depth of the quantum circuit with respect to the traditional UCCSD unitary. [(#1383)](https://github.com/PennyLaneAI/pennylane/pull/1383)\r\n\r\n  For example, consider the case of two particles and four qubits. First, we define the Hartree-Fock initial state and generate all possible single and double excitations.\r\n\r\n  ```python\r\n  import pennylane as qml\r\n  from pennylane import numpy as np\r\n\r\n  electrons = 2\r\n  qubits = 4\r\n\r\n  hf_state = qml.qchem.hf_state(electrons, qubits)\r\n  singles, doubles = qml.qchem.excitations(electrons, qubits)\r\n  ```\r\n\r\n  Now we can use the template ``AllSinglesDoubles`` to define the quantum circuit,\r\n\r\n  ```python\r\n  from pennylane.templates import AllSinglesDoubles\r\n\r\n  wires = range(qubits)\r\n\r\n  dev = qml.device('default.qubit', wires=wires)\r\n\r\n  @qml.qnode(dev)\r\n  def circuit(weights, hf_state, singles, doubles):\r\n      AllSinglesDoubles(weights, wires, hf_state, singles, doubles)\r\n      return qml.expval(qml.PauliZ(0))\r\n\r\n  params = np.random.normal(0, np.pi, len(singles) + len(doubles))\r\n  ```\r\n  and execute it:\r\n  ```pycon\r\n  >>> circuit(params, hf_state, singles=singles, doubles=doubles)\r\n  tensor(-0.73772194, requires_grad=True)\r\n  ```\r\n\r\n* Adds `QubitCarry` and `QubitSum` operations for basic arithmetic. [(#1169)](https://github.com/PennyLaneAI/pennylane/pull/1169)\r\n\r\n  The following example adds two 1-bit numbers, returning a 2-bit answer:\r\n\r\n  ```python\r\n  dev = qml.device('default.qubit', wires = 4)\r\n  a = 0\r\n  b = 1\r\n\r\n  @qml.qnode(dev)\r\n  def circuit():\r\n      qml.BasisState(np.array([a, b]), wires=[1, 2])\r\n      qml.QubitCarry(wires=[0, 1, 2, 3])\r\n      qml.CNOT(wires=[1, 2])\r\n      qml.QubitSum(wires=[0, 1, 2])\r\n      return qml.probs(wires=[3, 2])\r\n\r\n  probs = circuit()\r\n  bitstrings = tuple(itertools.product([0, 1], repeat = 2))\r\n  indx = np.argwhere(probs == 1).flatten()[0]\r\n  output = bitstrings[indx]\r\n  ```\r\n\r\n  ```pycon\r\n  >>> print(output)\r\n  (0, 1)\r\n  ```\r\n\r\n* Added the `qml.Projector` observable, which is available on all devices inheriting from the `QubitDevice` class. [(#1356)](https://github.com/PennyLaneAI/pennylane/pull/1356) [(#1368)](https://github.com/PennyLaneAI/pennylane/pull/1368)\r\n\r\n  Using `qml.Projector`, we can define the basis state projectors to use when computing expectation values. Let us take for example a circuit that prepares Bell states:\r\n\r\n  ```python\r\n  dev = qml.device(\"default.qubit\", wires=2)\r\n\r\n  @qml.qnode(dev)\r\n  def circuit(basis_state):\r\n      qml.Hadamard(wires=[0])\r\n      qml.CNOT(wires=[0, 1])\r\n      return qml.expval(qml.Projector(basis_state, wires=[0, 1]))\r\n  ```\r\n\r\n  We can then specify the `|00>` basis state to construct the `|00><00|` projector and compute the expectation value:\r\n\r\n  ```pycon\r\n  >>> basis_state = [0, 0]\r\n  >>> circuit(basis_state)\r\n  tensor(0.5, requires_grad=True)\r\n  ```\r\n\r\n  As expected, we get similar results when specifying the `|11>` basis state:\r\n\r\n  ```pycon\r\n  >>> basis_state = [1, 1]\r\n  >>> circuit(basis_state)\r\n  tensor(0.5, requires_grad=True)\r\n  ```\r\n\r\n* The following new operations have been added:\r\n\r\n  - The IsingXX gate `qml.IsingXX` [(#1194)](https://github.com/PennyLaneAI/pennylane/pull/1194)\r\n  - The IsingZZ gate `qml.IsingZZ` [(#1199)](https://github.com/PennyLaneAI/pennylane/pull/1199)\r\n  - The ISWAP gate `qml.ISWAP` [(#1298)](https://github.com/PennyLaneAI/pennylane/pull/1298)\r\n  - The reset error noise channel `qml.ResetError` [(#1321)](https://github.com/PennyLaneAI/pennylane/pull/1321)\r\n\r\n\r\n<h3>Improvements</h3>\r\n\r\n* The ``argnum`` keyword argument can now be specified for a QNode to define a subset of trainable parameters used to estimate the Jacobian. [(#1371)](https://github.com/PennyLaneAI/pennylane/pull/1371)\r\n\r\n  For example, consider two trainable parameters and a quantum function:\r\n\r\n  ```python\r\n  dev = qml.device(\"default.qubit\", wires=2)\r\n\r\n  x = np.array(0.543, requires_grad=True)\r\n  y = np.array(-0.654, requires_grad=True)\r\n\r\n  def circuit(x,y):\r\n      qml.RX(x, wires=[0])\r\n      qml.RY(y, wires=[1])\r\n      qml.CNOT(wires=[0, 1])\r\n      return qml.expval(qml.PauliZ(0) @ qml.PauliX(1))\r\n  ```\r\n\r\n  When computing the gradient of the QNode, we can specify the trainable parameters to consider by passing the ``argnum`` keyword argument:\r\n\r\n  ```pycon\r\n  >>> qnode1 = qml.QNode(circuit, dev, diff_method=\"parameter-shift\", argnum=[0,1])\r\n  >>> print(qml.grad(qnode1)(x,y))\r\n  (array(0.31434679), array(0.67949903))\r\n  ```\r\n\r\n  Specifying a proper subset of the trainable parameters will estimate the Jacobian:\r\n\r\n  ```pycon\r\n  >>> qnode2 = qml.QNode(circuit, dev, diff_method=\"parameter-shift\", argnum=[0])\r\n  >>> print(qml.grad(qnode2)(x,y))\r\n  (array(0.31434679), array(0.))\r\n  ```\r\n\r\n* Allows creating differentiable observables that return custom objects such that the observable is supported by devices. [(1291)](https://github.com/PennyLaneAI/pennylane/pull/1291)\r\n\r\n  As an example, first we define `NewObservable` class:\r\n\r\n  ```python\r\n  from pennylane.devices import DefaultQubit\r\n\r\n  class NewObservable(qml.operation.Observable):\r\n      \"\"\"NewObservable\"\"\"\r\n\r\n      num_wires = qml.operation.AnyWires\r\n      num_params = 0\r\n      par_domain = None\r\n\r\n      def diagonalizing_gates(self):\r\n          \"\"\"Diagonalizing gates\"\"\"\r\n          return []\r\n  ```\r\n\r\n  Once we have this new observable class, we define a `SpecialObject` class that can be used to encode data in an observable and a new device that supports our new observable and returns a `SpecialObject` as the expectation value (the code is shortened for brevity, the extended example can be found as a test in the previously referenced pull request):\r\n\r\n  ```python\r\n  class SpecialObject:\r\n\r\n      def __init__(self, val):\r\n          self.val = val\r\n\r\n      def __mul__(self, other):\r\n          new = SpecialObject(self.val)\r\n          new *= other\r\n          return new\r\n\r\n      ...\r\n\r\n  class DeviceSupportingNewObservable(DefaultQubit):\r\n      name = \"Device supporting NewObservable\"\r\n      short_name = \"default.qubit.newobservable\"\r\n      observables = DefaultQubit.observables.union({\"NewObservable\"})\r\n\r\n      def expval(self, observable, **kwargs):\r\n          if self.shots is None and isinstance(observable, NewObservable):\r\n              val = super().expval(qml.PauliZ(wires=0), **kwargs)\r\n              return SpecialObject(val)\r\n\r\n          return super().expval(observable, **kwargs)\r\n  ```\r\n\r\n  At this point, we can create a device that will support the differentiation of a `NewObservable` object:\r\n\r\n  ```python\r\n  dev = DeviceSupportingNewObservable(wires=1, shots=None)\r\n\r\n  @qml.qnode(dev, diff_method=\"parameter-shift\")\r\n  def qnode(x):\r\n      qml.RY(x, wires=0)\r\n      return qml.expval(NewObservable(wires=0))\r\n  ```\r\n\r\n  We can then compute the jacobian of this object:\r\n\r\n  ```pycon\r\n  >>> result = qml.jacobian(qnode)(0.2)\r\n  >>> print(result)\r\n  <__main__.SpecialObject object at 0x7fd2c54721f0>\r\n  >>> print(result.item().val)\r\n  -0.19866933079506116\r\n  ```\r\n\r\n* PennyLane NumPy now includes the [random module's](https://numpy.org/doc/stable/reference/random/index.html#module-numpy.random) `Generator` objects, the recommended way of random number generation. This allows for random number generation using a local, rather than global seed. [(#1267)](https://github.com/PennyLaneAI/pennylane/pull/1267)\r\n\r\n  ```python\r\n  from pennylane import numpy as np\r\n\r\n  rng = np.random.default_rng()\r\n  random_mat1 = rng.random((3,2))\r\n  random_mat2 = rng.standard_normal(3, requires_grad=False)\r\n  ```\r\n\r\n* The performance of adjoint jacobian differentiation was significantly improved as the method now reuses the state computed on the forward pass. This can be turned off to save memory with the Torch and TensorFlow interfaces by passing `adjoint_cache=False` during QNode creation. [(#1341)](https://github.com/PennyLaneAI/pennylane/pull/1341)\r\n\r\n* The `Operator` (and by inheritance, the `Operation` and `Observable` class and their children) now have an `id` attribute, which can mark an operator in a circuit, for example to identify it on the tape by a tape transform. [(#1377)](https://github.com/PennyLaneAI/pennylane/pull/1377)\r\n\r\n* The `benchmark` module was deleted, since it was outdated and is superseded by the new separate [benchmark repository](https://github.com/PennyLaneAI/benchmark). [(#1343)](https://github.com/PennyLaneAI/pennylane/pull/1343)\r\n\r\n* Decompositions in terms of elementary gates has been added for:\r\n\r\n  - `qml.CSWAP` [(#1306)](https://github.com/PennyLaneAI/pennylane/issues/1306)\r\n  - `qml.SWAP` [(#1329)](https://github.com/PennyLaneAI/pennylane/pull/1329)\r\n  - `qml.SingleExcitation` [(#1303)](https://github.com/PennyLaneAI/pennylane/pull/1303)\r\n  - `qml.SingleExcitationPlus` and `qml.SingleExcitationMinus` [(#1278)](https://github.com/PennyLaneAI/pennylane/pull/1278)\r\n  - `qml.DoubleExcitation` [(#1303)](https://github.com/PennyLaneAI/pennylane/pull/1303)\r\n  - `qml.Toffoli` [(#1320)](https://github.com/PennyLaneAI/pennylane/pull/1320)\r\n  - `qml.MultiControlledX`. [(#1287)](https://github.com/PennyLaneAI/pennylane/pull/1287)\r\n\r\n    When controlling on three or more wires, an ancilla register of worker wires is required to support the decomposition.\r\n\r\n    ```python\r\n    ctrl_wires = [f\"c{i}\" for i in range(5)]\r\n    work_wires = [f\"w{i}\" for i in range(3)]\r\n    target_wires = [\"t0\"]\r\n    all_wires = ctrl_wires + work_wires + target_wires\r\n\r\n    dev = qml.device(\"default.qubit\", wires=all_wires)\r\n\r\n    with qml.tape.QuantumTape() as tape:\r\n        qml.MultiControlledX(control_wires=ctrl_wires, wires=target_wires, work_wires=work_wires)\r\n    ```\r\n\r\n    ```pycon\r\n    >>> tape = tape.expand(depth=1)\r\n    >>> print(tape.draw(wire_order=qml.wires.Wires(all_wires)))\r\n\r\n     c0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256dC\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256dC\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n     c1: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u251cC\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u251cC\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n     c2: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256dC\u2500\u2500\u2502\u2500\u2500\u2500\u256dC\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256dC\u2500\u2500\u2502\u2500\u2500\u2500\u256dC\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n     c3: \u2500\u2500\u2500\u2500\u2500\u2500\u256dC\u2500\u2500\u2502\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u256dC\u2500\u2500\u2500\u2500\u2500\u2500\u256dC\u2500\u2500\u2502\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u256dC\u2500\u2500\u2524\r\n     c4: \u2500\u2500\u256dC\u2500\u2500\u2502\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u256dC\u2500\u2500\u2502\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2524\r\n     w0: \u2500\u2500\u2502\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u251cC\u2500\u2500\u2570X\u2500\u2500\u251cC\u2500\u2500\u2502\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u251cC\u2500\u2500\u2570X\u2500\u2500\u251cC\u2500\u2500\u2502\u2500\u2500\u2500\u2524\r\n     w1: \u2500\u2500\u2502\u2500\u2500\u2500\u251cC\u2500\u2500\u2570X\u2500\u2500\u2500\u2500\u2500\u2500\u2570X\u2500\u2500\u251cC\u2500\u2500\u2502\u2500\u2500\u2500\u251cC\u2500\u2500\u2570X\u2500\u2500\u2500\u2500\u2500\u2500\u2570X\u2500\u2500\u251cC\u2500\u2500\u2524\r\n     w2: \u2500\u2500\u251cC\u2500\u2500\u2570X\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2570X\u2500\u2500\u251cC\u2500\u2500\u2570X\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2570X\u2500\u2500\u2524\r\n     t0: \u2500\u2500\u2570X\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2570X\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n    ```\r\n\r\n* Added `qml.CPhase` as an alias for the existing `qml.ControlledPhaseShift` operation. [(#1319)](https://github.com/PennyLaneAI/pennylane/pull/1319).\r\n\r\n* The `Device` class now uses caching when mapping wires. [(#1270)](https://github.com/PennyLaneAI/pennylane/pull/1270)\r\n\r\n* The `Wires` class now uses caching for computing its `hash`. [(#1270)](https://github.com/PennyLaneAI/pennylane/pull/1270)\r\n\r\n* Added custom gate application for Toffoli in `default.qubit`. [(#1249)](https://github.com/PennyLaneAI/pennylane/pull/1249)\r\n\r\n* Added validation for noise channel parameters. Invalid noise parameters now\r\n  raise a `ValueError`. [(#1357)](https://github.com/PennyLaneAI/pennylane/pull/1357)\r\n\r\n* The device test suite now provides test cases for checking gates by comparing\r\n  expectation values. [(#1212)](https://github.com/PennyLaneAI/pennylane/pull/1212)\r\n\r\n* PennyLane's test suite is now code-formatted using `black -l 100`. [(#1222)](https://github.com/PennyLaneAI/pennylane/pull/1222)\r\n\r\n* PennyLane's `qchem` package and tests are now code-formatted using `black -l 100`. [(#1311)](https://github.com/PennyLaneAI/pennylane/pull/1311)\r\n\r\n<h3>Breaking changes</h3>\r\n\r\n* The `qml.inv()` function is now deprecated with a warning to use the more general `qml.adjoint()`. [(#1325)](https://github.com/PennyLaneAI/pennylane/pull/1325)\r\n\r\n* Removes support for Python 3.6 and adds support for Python 3.9. [(#1228)](https://github.com/XanaduAI/pennylane/pull/1228)\r\n\r\n* The tape methods `get_resources` and `get_depth` are superseded by `specs` and will be\r\n  deprecated after one release cycle. [(#1245)](https://github.com/PennyLaneAI/pennylane/pull/1245)\r\n\r\n* Using the `qml.sample()` measurement on devices with `shots=None` continue to\r\n  raise a warning with this functionality being fully deprecated and raising an\r\n  error after one release cycle. [(#1079)](https://github.com/PennyLaneAI/pennylane/pull/1079) [(#1196)](https://github.com/PennyLaneAI/pennylane/pull/1196)\r\n\r\n<h3>Bug fixes</h3>\r\n\r\n* QNodes now display readable information when in interactive environments or when printed.  [(#1359)](https://github.com/PennyLaneAI/pennylane/pull/1359).\r\n\r\n* Fixes a bug with `qml.math.cast` where the `MottonenStatePreparation` operation expected\r\n  a float type instead of double. [(#1400)](https://github.com/XanaduAI/pennylane/pull/1400)\r\n\r\n* Fixes a bug where a copy of `qml.ControlledQubitUnitary` was non-functional as it did not have all the necessary information. [(#1411)](https://github.com/PennyLaneAI/pennylane/pull/1411)\r\n\r\n* Warns when adjoint or reversible differentiation specified or called on a device with finite shots. [(#1406)](https://github.com/PennyLaneAI/pennylane/pull/1406)\r\n\r\n* Fixes the differentiability of the operations `IsingXX` and `IsingZZ` for Autograd, Jax and Tensorflow. [(#1390)](https://github.com/PennyLaneAI/pennylane/pull/1390)\r\n\r\n* Fixes a bug where multiple identical Hamiltonian terms will produce a different result with ``optimize=True`` using ``ExpvalCost``. [(#1405)](https://github.com/XanaduAI/pennylane/pull/1405)\r\n\r\n* Fixes bug where `shots=None` was not reset when changing shots temporarily in a QNode call like `circuit(0.1, shots=3)`. [(#1392)](https://github.com/XanaduAI/pennylane/pull/1392)\r\n\r\n* Fixes floating point errors with `diff_method=\"finite-diff\"` and `order=1` when parameters are `float32`. [(#1381)](https://github.com/PennyLaneAI/pennylane/pull/1381)\r\n\r\n* Fixes a bug where `qml.ctrl` would fail to transform gates that had no control defined and no decomposition defined. [(#1376)](https://github.com/PennyLaneAI/pennylane/pull/1376)\r\n\r\n* Copying the `JacobianTape` now correctly also copies the `jacobian_options` attribute. This fixes a bug allowing the JAX interface to support adjoint differentiation. [(#1349)](https://github.com/PennyLaneAI/pennylane/pull/1349)\r\n\r\n* Fixes drawing QNodes that contain multiple measurements on a single wire. [(#1353)](https://github.com/PennyLaneAI/pennylane/pull/1353)\r\n\r\n* Fixes drawing QNodes with no operations. [(#1354)](https://github.com/PennyLaneAI/pennylane/pull/1354)\r\n\r\n* Fixes incorrect wires in the decomposition of the `ControlledPhaseShift` operation. [(#1338)](https://github.com/PennyLaneAI/pennylane/pull/1338)\r\n\r\n* Fixed tests for the `Permute` operation that used a QNode and hence expanded tapes twice instead of once due to QNode tape expansion and an explicit tape expansion call. [(#1318)](https://github.com/PennyLaneAI/pennylane/pull/1318).\r\n\r\n* Prevent Hamiltonians that share wires from being multiplied together. [(#1273)](https://github.com/PennyLaneAI/pennylane/pull/1273)\r\n\r\n* Fixed a bug where the custom range sequences could not be passed to the `StronglyEntanglingLayers` template. [(#1332)](https://github.com/PennyLaneAI/pennylane/pull/1332)\r\n\r\n* Fixed a bug where `qml.sum()` and `qml.dot()` do not support the JAX interface. [(#1380)](https://github.com/PennyLaneAI/pennylane/pull/1380)\r\n\r\n<h3>Documentation</h3>\r\n\r\n* Math present in the `QubitParamShiftTape` class docstring now renders correctly. [(#1402)](https://github.com/PennyLaneAI/pennylane/pull/1402)\r\n\r\n* Fix typo in the documentation of `qml.StronglyEntanglingLayers`. [(#1367)](https://github.com/PennyLaneAI/pennylane/pull/1367)\r\n\r\n* Fixed typo in TensorFlow interface documentation [(#1312)](https://github.com/PennyLaneAI/pennylane/pull/1312)\r\n\r\n* Fixed typos in the mathematical expressions in documentation of `qml.DoubleExcitation`. [(#1278)](https://github.com/PennyLaneAI/pennylane/pull/1278)\r\n\r\n* Remove unsupported `None` option from the `qml.QNode` docstrings. [(#1271)](https://github.com/PennyLaneAI/pennylane/pull/1271)\r\n\r\n* Updated the docstring of `qml.PolyXP` to reference the new location of internal usage. [(#1262)](https://github.com/PennyLaneAI/pennylane/pull/1262)\r\n\r\n* Removes occurrences of the deprecated device argument ``analytic`` from the documentation. [(#1261)](https://github.com/PennyLaneAI/pennylane/pull/1261)\r\n\r\n* Updated PyTorch and TensorFlow interface introductions. [(#1333)](https://github.com/PennyLaneAI/pennylane/pull/1333)\r\n\r\n* Updates the quantum chemistry quickstart to reflect recent changes to the `qchem` module. [(#1227)](https://github.com/PennyLaneAI/pennylane/pull/1227)\r\n\r\n<h3>Contributors</h3>\r\n\r\nThis release contains contributions from (in alphabetical order):\r\n\r\nMarius Aglitoiu, Vishnu Ajith, Juan Miguel Arrazola, Thomas Bromley, Jack Ceroni, Alaric Cheng, Miruna Daian, Olivia Di Matteo, Tanya Garg, Christian Gogolin, Alain Delgado Gran, Diego Guala, Anthony Hayes, Ryan Hill, Theodor Isacsson, Josh Izaac, Soran Jahangiri, Pavan Jayasinha, Nathan Killoran, Christina Lee, Ryan Levy, Alberto Maldonado, Johannes Jakob Meyer, Romain Moyard, Ashish Panigrahi, Nahum S\u00e1, Maria Schuld, Brian Shi, Antal Sz\u00e1va, David Wierichs, Vincent Wong.", "reactions": {"url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/44997246/reactions", "total_count": 1, "+1": 0, "-1": 0, "laugh": 0, "hooray": 1, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}}
{"url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/42347474", "assets_url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/42347474/assets", "upload_url": "https://uploads.github.com/repos/PennyLaneAI/pennylane/releases/42347474/assets{?name,label}", "html_url": "https://github.com/PennyLaneAI/pennylane/releases/tag/v0.15.1", "id": 42347474, "author": {"login": "josh146", "id": 2959003, "node_id": "MDQ6VXNlcjI5NTkwMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/2959003?v=4", "gravatar_id": "", "url": "https://api.github.com/users/josh146", "html_url": "https://github.com/josh146", "followers_url": "https://api.github.com/users/josh146/followers", "following_url": "https://api.github.com/users/josh146/following{/other_user}", "gists_url": "https://api.github.com/users/josh146/gists{/gist_id}", "starred_url": "https://api.github.com/users/josh146/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/josh146/subscriptions", "organizations_url": "https://api.github.com/users/josh146/orgs", "repos_url": "https://api.github.com/users/josh146/repos", "events_url": "https://api.github.com/users/josh146/events{/privacy}", "received_events_url": "https://api.github.com/users/josh146/received_events", "type": "User", "site_admin": false}, "node_id": "MDc6UmVsZWFzZTQyMzQ3NDc0", "tag_name": "v0.15.1", "target_commitish": "v0.15.1", "name": "Release 0.15.1", "draft": false, "prerelease": false, "created_at": "2021-05-03T08:26:30Z", "published_at": "2021-05-03T08:34:16Z", "assets": [], "tarball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/tarball/v0.15.1", "zipball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/zipball/v0.15.1", "body": "<h3>Bug fixes</h3>\r\n\r\n* Fixes two bugs in the parameter-shift Hessian. [(#1260)](https://github.com/PennyLaneAI/pennylane/pull/1260)\r\n\r\n  - Fixes a bug where having an unused parameter in the Autograd interface would result in an indexing error during backpropagation.\r\n\r\n  - The parameter-shift Hessian only supports the two-term parameter-shift rule currently, so raises an error if asked to differentiate any unsupported gates (such as the controlled rotation gates).\r\n\r\n* A bug which resulted in `qml.adjoint()` and `qml.inv()` failing to work with templates has been fixed. [(#1243)](https://github.com/PennyLaneAI/pennylane/pull/1243)\r\n\r\n* Deprecation warning instances in PennyLane have been changed to `UserWarning`, to account for recent changes to how Python warnings are filtered in [PEP565](https://www.python.org/dev/peps/pep-0565/). [(#1211)](https://github.com/PennyLaneAI/pennylane/pull/1211)\r\n\r\n* The version requirement for PySCF has been modified to allow for `pyscf>=1.7.2`. [(#1254)](https://github.com/PennyLaneAI/pennylane/pull/1254)\r\n\r\n<h3>Documentation</h3>\r\n\r\n* Updated the order of the parameters to the `GaussianState` operation to match the way that the PennyLane-SF plugin uses them. [(#1255)](https://github.com/PennyLaneAI/pennylane/pull/1255)\r\n\r\n<h3>Contributors</h3>\r\n\r\nThis release contains contributions from (in alphabetical order):\r\n\r\nJosh Izaac, Maria Schuld, Antal Sz\u00e1va."}
{"url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/41688894", "assets_url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/41688894/assets", "upload_url": "https://uploads.github.com/repos/PennyLaneAI/pennylane/releases/41688894/assets{?name,label}", "html_url": "https://github.com/PennyLaneAI/pennylane/releases/tag/v0.15.0", "id": 41688894, "author": {"login": "josh146", "id": 2959003, "node_id": "MDQ6VXNlcjI5NTkwMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/2959003?v=4", "gravatar_id": "", "url": "https://api.github.com/users/josh146", "html_url": "https://github.com/josh146", "followers_url": "https://api.github.com/users/josh146/followers", "following_url": "https://api.github.com/users/josh146/following{/other_user}", "gists_url": "https://api.github.com/users/josh146/gists{/gist_id}", "starred_url": "https://api.github.com/users/josh146/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/josh146/subscriptions", "organizations_url": "https://api.github.com/users/josh146/orgs", "repos_url": "https://api.github.com/users/josh146/repos", "events_url": "https://api.github.com/users/josh146/events{/privacy}", "received_events_url": "https://api.github.com/users/josh146/received_events", "type": "User", "site_admin": false}, "node_id": "MDc6UmVsZWFzZTQxNjg4ODk0", "tag_name": "v0.15.0", "target_commitish": "master", "name": "Release 0.15.0", "draft": false, "prerelease": false, "created_at": "2021-04-20T06:03:15Z", "published_at": "2021-04-20T07:06:17Z", "assets": [], "tarball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/tarball/v0.15.0", "zipball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/zipball/v0.15.0", "body": "<h3>New features since last release</h3>\r\n\r\n<h4>Better and more flexible shot control</h4>\r\n\r\n* Adds a new optimizer `qml.ShotAdaptiveOptimizer`, a gradient-descent optimizer where the shot rate is adaptively calculated using the variances of the parameter-shift gradient. [(#1139)](https://github.com/PennyLaneAI/pennylane/pull/1139)\r\n\r\n  By keeping a running average of the parameter-shift gradient and the *variance* of the parameter-shift gradient, this optimizer frugally distributes a shot budget across the partial derivatives of each parameter.\r\n\r\n  In addition, if computing the expectation value of a Hamiltonian, weighted random sampling can be used to further distribute the shot budget across the local terms from which the Hamiltonian is constructed.\r\n\r\n  This optimizer is based on both the [iCANS1](https://quantum-journal.org/papers/q-2020-05-11-263) and [Rosalin](https://arxiv.org/abs/2004.06252) shot-adaptive optimizers.\r\n\r\n  Once constructed, the cost function can be passed directly to the optimizer's `step` method.  The attribute `opt.total_shots_used` can be used to track the number of shots per iteration.\r\n\r\n  ```pycon\r\n  >>> coeffs = [2, 4, -1, 5, 2]\r\n  >>> obs = [\r\n  ...   qml.PauliX(1),\r\n  ...   qml.PauliZ(1),\r\n  ...   qml.PauliX(0) @ qml.PauliX(1),\r\n  ...   qml.PauliY(0) @ qml.PauliY(1),\r\n  ...   qml.PauliZ(0) @ qml.PauliZ(1)\r\n  ... ]\r\n  >>> H = qml.Hamiltonian(coeffs, obs)\r\n  >>> dev = qml.device(\"default.qubit\", wires=2, shots=100)\r\n  >>> cost = qml.ExpvalCost(qml.templates.StronglyEntanglingLayers, H, dev)\r\n  >>> params = qml.init.strong_ent_layers_uniform(n_layers=2, n_wires=2)\r\n  >>> opt = qml.ShotAdaptiveOptimizer(min_shots=10)\r\n  >>> for i in range(5):\r\n  ...    params = opt.step(cost, params)\r\n  ...    print(f\"Step {i}: cost = {cost(params):.2f}, shots_used = {opt.total_shots_used}\")\r\n  Step 0: cost = -5.68, shots_used = 240\r\n  Step 1: cost = -2.98, shots_used = 336\r\n  Step 2: cost = -4.97, shots_used = 624\r\n  Step 3: cost = -5.53, shots_used = 1054\r\n  Step 4: cost = -6.50, shots_used = 1798\r\n  ```\r\n\r\n* Batches of shots can now be specified as a list, allowing measurement statistics to be course-grained with a single QNode evaluation. [(#1103)](https://github.com/PennyLaneAI/pennylane/pull/1103)\r\n\r\n  ```pycon\r\n  >>> shots_list = [5, 10, 1000]\r\n  >>> dev = qml.device(\"default.qubit\", wires=2, shots=shots_list)\r\n  ```\r\n\r\n  When QNodes are executed on this device, a single execution of 1015 shots will be submitted. However, three sets of measurement statistics will be returned; using the first 5 shots, second set of 10 shots, and final 1000 shots, separately.\r\n\r\n  For example, executing a circuit with two outputs will lead to a result of shape `(3, 2)`:\r\n\r\n  ```pycon\r\n  >>> @qml.qnode(dev)\r\n  ... def circuit(x):\r\n  ...     qml.RX(x, wires=0)\r\n  ...     qml.CNOT(wires=[0, 1])\r\n  ...     return qml.expval(qml.PauliZ(0) @ qml.PauliX(1)), qml.expval(qml.PauliZ(0))\r\n  >>> circuit(0.5)\r\n  [[0.33333333 1.        ]\r\n   [0.2        1.        ]\r\n   [0.012      0.868     ]]\r\n  ```\r\n\r\n  This output remains fully differentiable.\r\n\r\n- The number of shots can now be specified on a per-call basis when evaluating a QNode. [(#1075)](https://github.com/PennyLaneAI/pennylane/pull/1075).\r\n\r\n  For this, the qnode should be called with an additional `shots` keyword argument:\r\n\r\n  ```pycon\r\n  >>> dev = qml.device('default.qubit', wires=1, shots=10) # default is 10\r\n  >>> @qml.qnode(dev)\r\n  ... def circuit(a):\r\n  ...     qml.RX(a, wires=0)\r\n  ...     return qml.sample(qml.PauliZ(wires=0))\r\n  >>> circuit(0.8)\r\n  [ 1  1  1 -1 -1  1  1  1  1  1]\r\n  >>> circuit(0.8, shots=3)\r\n  [ 1  1  1]\r\n  >>> circuit(0.8)\r\n  [ 1  1  1 -1 -1  1  1  1  1  1]\r\n  ```\r\n\r\n<h4>New differentiable quantum transforms</h4>\r\n\r\nA new module is available, [qml.transforms](https://pennylane.rtfd.io/en/stable/code/qml_transforms.html), which contains *differentiable quantum transforms*. These are functions that act on QNodes, quantum functions, devices, and tapes, transforming them while remaining fully differentiable.\r\n\r\n* A new adjoint transform has been added.  [(#1111)](https://github.com/PennyLaneAI/pennylane/pull/1111) [(#1135)](https://github.com/PennyLaneAI/pennylane/pull/1135)\r\n\r\n  This new method allows users to apply the adjoint of an arbitrary sequence of operations.\r\n\r\n  ```python\r\n  def subroutine(wire):\r\n      qml.RX(0.123, wires=wire)\r\n      qml.RY(0.456, wires=wire)\r\n\r\n  dev = qml.device('default.qubit', wires=1)\r\n  @qml.qnode(dev)\r\n  def circuit():\r\n      subroutine(0)\r\n      qml.adjoint(subroutine)(0)\r\n      return qml.expval(qml.PauliZ(0))\r\n  ```\r\n\r\n  This creates the following circuit:\r\n\r\n  ```pycon\r\n  >>> print(qml.draw(circuit)())\r\n  0: --RX(0.123)--RY(0.456)--RY(-0.456)--RX(-0.123)--| <Z>\r\n  ```\r\n\r\n  Directly applying to a gate also works as expected.\r\n\r\n  ```python\r\n  qml.adjoint(qml.RX)(0.123, wires=0) # applies RX(-0.123)\r\n  ```\r\n\r\n* A new transform `qml.ctrl` is now available that adds control wires to subroutines. [(#1157)](https://github.com/PennyLaneAI/pennylane/pull/1157)\r\n\r\n  ```python\r\n  def my_ansatz(params):\r\n     qml.RX(params[0], wires=0)\r\n     qml.RZ(params[1], wires=1)\r\n\r\n  # Create a new operation that applies `my_ansatz`\r\n  # controlled by the \"2\" wire.\r\n  my_ansatz2 = qml.ctrl(my_ansatz, control=2)\r\n\r\n  @qml.qnode(dev)\r\n  def circuit(params):\r\n      my_ansatz2(params)\r\n      return qml.state()\r\n  ```\r\n\r\n  This is equivalent to:\r\n\r\n  ```python\r\n  @qml.qnode(...)\r\n  def circuit(params):\r\n      qml.CRX(params[0], wires=[2, 0])\r\n      qml.CRZ(params[1], wires=[2, 1])\r\n      return qml.state()\r\n  ```\r\n\r\n* The `qml.transforms.classical_jacobian` transform has been added. [(#1186)](https://github.com/PennyLaneAI/pennylane/pull/1186)\r\n\r\n  This transform returns a function to extract the Jacobian matrix of the classical part of a QNode, allowing the classical dependence between the QNode arguments and the quantum gate arguments to be extracted.\r\n\r\n  For example, given the following QNode:\r\n\r\n  ```pycon\r\n  >>> @qml.qnode(dev)\r\n  ... def circuit(weights):\r\n  ...     qml.RX(weights[0], wires=0)\r\n  ...     qml.RY(weights[0], wires=1)\r\n  ...     qml.RZ(weights[2] ** 2, wires=1)\r\n  ...     return qml.expval(qml.PauliZ(0))\r\n  ```\r\n\r\n  We can use this transform to extract the relationship :math:`f: \\mathbb{R}^n \\rightarrow\\mathbb{R}^m` between the input QNode arguments :math:`w` and the gate arguments :math:`g`, for a given value of the QNode arguments:\r\n\r\n  ```pycon\r\n  >>> cjac_fn = qml.transforms.classical_jacobian(circuit)\r\n  >>> weights = np.array([1., 1., 1.], requires_grad=True)\r\n  >>> cjac = cjac_fn(weights)\r\n  >>> print(cjac)\r\n  [[1. 0. 0.]\r\n   [1. 0. 0.]\r\n   [0. 0. 2.]]\r\n  ```\r\n\r\n  The returned Jacobian has rows corresponding to gate arguments, and columns corresponding to QNode arguments; that is, :math:`J_{ij} = \\frac{\\partial}{\\partial g_i} f(w_j)`.\r\n\r\n<h4>More operations and templates</h4>\r\n\r\n* Added the `SingleExcitation` two-qubit operation, which is useful for quantum  chemistry applications. [(#1121)](https://github.com/PennyLaneAI/pennylane/pull/1121)\r\n\r\n  It can be used to perform an SO(2) rotation in the subspace  spanned by the states :math:`|01\\rangle` and :math:`|10\\rangle`.  For example, the following circuit performs the transformation :math:`|10\\rangle \\rightarrow \\cos(\\phi/2)|10\\rangle - \\sin(\\phi/2)|01\\rangle`:    \r\n  \r\n  ```python\r\n  dev = qml.device('default.qubit', wires=2)\r\n\r\n  @qml.qnode(dev)\r\n  def circuit(phi):\r\n      qml.PauliX(wires=0)\r\n      qml.SingleExcitation(phi, wires=[0, 1])\r\n  ```\r\n\r\n  The `SingleExcitation` operation supports analytic gradients on hardware using only four expectation value calculations, following results from [Kottmann et al.](https://arxiv.org/abs/2011.05938) \r\n\r\n* Added the `DoubleExcitation` four-qubit operation, which is useful for quantum chemistry applications. [(#1123)](https://github.com/PennyLaneAI/pennylane/pull/1123)\r\n\r\n  It can be used to perform an SO(2) rotation in the subspace  spanned by the states :math:`|1100\\rangle` and :math:`|0011\\rangle`.  For example, the following circuit performs the transformation :math:`|1100\\rangle\\rightarrow \\cos(\\phi/2)|1100\\rangle - \\sin(\\phi/2)|0011\\rangle`:   \r\n\r\n  ```python\r\n  dev = qml.device('default.qubit', wires=2)\r\n\r\n  @qml.qnode(dev)\r\n  def circuit(phi):\r\n      qml.PauliX(wires=0)\r\n      qml.PauliX(wires=1)\r\n      qml.DoubleExcitation(phi, wires=[0, 1, 2, 3])\r\n  ```\r\n  \r\n  The `DoubleExcitation` operation supports analytic gradients on hardware using only four expectation value calculations, following results from [Kottmann et al.](https://arxiv.org/abs/2011.05938).\r\n\r\n* Added the `QuantumMonteCarlo` template for performing quantum Monte Carlo estimation of an expectation value on simulator. [(#1130)](https://github.com/PennyLaneAI/pennylane/pull/1130)\r\n\r\n  The following example shows how the expectation value of sine squared over a standard normal distribution can be approximated:\r\n  \r\n  ```python\r\n  from scipy.stats import norm\r\n\r\n  m = 5\r\n  M = 2 ** m\r\n  n = 10\r\n  N = 2 ** n\r\n  target_wires = range(m + 1)\r\n  estimation_wires = range(m + 1, n + m + 1)\r\n\r\n  xmax = np.pi  # bound to region [-pi, pi]\r\n  xs = np.linspace(-xmax, xmax, M)\r\n\r\n  probs = np.array([norm().pdf(x) for x in xs])\r\n  probs /= np.sum(probs)\r\n\r\n  func = lambda i: np.sin(xs[i]) ** 2\r\n\r\n  dev = qml.device(\"default.qubit\", wires=(n + m + 1))\r\n\r\n  @qml.qnode(dev)\r\n  def circuit():\r\n      qml.templates.QuantumMonteCarlo(\r\n          probs,\r\n          func,\r\n          target_wires=target_wires,\r\n          estimation_wires=estimation_wires,\r\n      )\r\n      return qml.probs(estimation_wires)\r\n\r\n  phase_estimated = np.argmax(circuit()[:int(N / 2)]) / N\r\n  expectation_estimated = (1 - np.cos(np.pi * phase_estimated)) / 2\r\n  ```\r\n\r\n* Added the `QuantumPhaseEstimation` template for performing quantum phase estimation for an input unitary matrix. [(#1095)](https://github.com/PennyLaneAI/pennylane/pull/1095)\r\n\r\n  Consider the matrix corresponding to a rotation from an `RX` gate:\r\n\r\n  ```pycon\r\n  >>> phase = 5\r\n  >>> target_wires = [0]\r\n  >>> unitary = qml.RX(phase, wires=0).matrix\r\n  ```\r\n\r\n  The ``phase`` parameter can be estimated using ``QuantumPhaseEstimation``. For example, using five phase-estimation qubits:\r\n\r\n  ```python\r\n  n_estimation_wires = 5\r\n  estimation_wires = range(1, n_estimation_wires + 1)\r\n\r\n  dev = qml.device(\"default.qubit\", wires=n_estimation_wires + 1)\r\n\r\n  @qml.qnode(dev)\r\n  def circuit():\r\n      # Start in the |+> eigenstate of the unitary\r\n      qml.Hadamard(wires=target_wires)\r\n\r\n      QuantumPhaseEstimation(\r\n          unitary,\r\n          target_wires=target_wires,\r\n          estimation_wires=estimation_wires,\r\n      )\r\n\r\n      return qml.probs(estimation_wires)\r\n\r\n  phase_estimated = np.argmax(circuit()) / 2 ** n_estimation_wires\r\n\r\n  # Need to rescale phase due to convention of RX gate\r\n  phase_estimated = 4 * np.pi * (1 - phase)\r\n  ```\r\n\r\n- Added the `ControlledPhaseShift` gate as well as the `QFT` operation for applying quantum Fourier transforms. [(#1064)](https://github.com/PennyLaneAI/pennylane/pull/1064)\r\n\r\n  ```python\r\n  @qml.qnode(dev)\r\n  def circuit_qft(basis_state):\r\n      qml.BasisState(basis_state, wires=range(3))\r\n      qml.QFT(wires=range(3))\r\n      return qml.state()\r\n  ```\r\n\r\n- Added the `ControlledQubitUnitary` operation. This enables implementation of multi-qubit gates with a variable number of control qubits. It is also possible to specify a different state for the control qubits using the `control_values` argument (also known as a mixed-polarity multi-controlled operation). [(#1069)](https://github.com/PennyLaneAI/pennylane/pull/1069) [(#1104)](https://github.com/PennyLaneAI/pennylane/pull/1104)\r\n\r\n  For example, we can  create a multi-controlled T gate using:\r\n\r\n  ```python\r\n  T = qml.T._matrix()\r\n  qml.ControlledQubitUnitary(T, control_wires=[0, 1, 3], wires=2, control_values=\"110\")\r\n  ```\r\n\r\n  Here, the T gate will be applied to wire `2` if control wires `0` and `1` are in state `1`, and control wire `3` is in state `0`. If no value is passed to `control_values`, the gate will be applied if all control wires are in the `1` state.\r\n\r\n- Added `MultiControlledX` for multi-controlled `NOT` gates.\r\n  This is a special case of `ControlledQubitUnitary` that applies a\r\n  Pauli X gate conditioned on the state of an arbitrary number of\r\n  control qubits.\r\n  [(#1104)](https://github.com/PennyLaneAI/pennylane/pull/1104)\r\n\r\n<h4>Support for higher-order derivatives on hardware</h4> \r\n\r\n* Computing second derivatives and Hessians of QNodes is now supported with the parameter-shift differentiation method, on all machine learning interfaces. [(#1130)](https://github.com/PennyLaneAI/pennylane/pull/1130) [(#1129)](https://github.com/PennyLaneAI/pennylane/pull/1129) [(#1110)](https://github.com/PennyLaneAI/pennylane/pull/1110) \r\n\r\n  Hessians are computed using the parameter-shift rule, and can be evaluated on both hardware and simulator devices.\r\n\r\n  ```python\r\n  dev = qml.device('default.qubit', wires=1)\r\n\r\n  @qml.qnode(dev, diff_method=\"parameter-shift\")\r\n  def circuit(p):\r\n      qml.RY(p[0], wires=0)\r\n      qml.RX(p[1], wires=0)\r\n      return qml.expval(qml.PauliZ(0))\r\n\r\n  x = np.array([1.0, 2.0], requires_grad=True)\r\n  ```\r\n\r\n  ```python\r\n  >>> hessian_fn = qml.jacobian(qml.grad(circuit))\r\n  >>> hessian_fn(x)\r\n  [[0.2248451 0.7651474]\r\n   [0.7651474 0.2248451]]\r\n  ```\r\n\r\n* Added the function `finite_diff()` to compute finite-difference approximations to the gradient and the second-order derivatives of arbitrary callable functions. [(#1090)](https://github.com/PennyLaneAI/pennylane/pull/1090)\r\n\r\n  This is useful to compute the derivative of parametrized `pennylane.Hamiltonian` observables with respect to their parameters.\r\n\r\n  For example, in quantum chemistry simulations it can be used to evaluate the derivatives of the electronic Hamiltonian with respect to the nuclear coordinates:\r\n\r\n  ```pycon\r\n  >>> def H(x):\r\n  ...    return qml.qchem.molecular_hamiltonian(['H', 'H'], x)[0]\r\n  >>> x = np.array([0., 0., -0.66140414, 0., 0., 0.66140414])\r\n  >>> grad_fn = qml.finite_diff(H, N=1)\r\n  >>> grad = grad_fn(x)\r\n  >>> deriv2_fn = qml.finite_diff(H, N=2, idx=[0, 1])\r\n  >>> deriv2_fn(x)\r\n  ```\r\n\r\n* The JAX interface now supports all devices, including hardware devices, via the parameter-shift differentiation method. [(#1076)](https://github.com/PennyLaneAI/pennylane/pull/1076)\r\n\r\n  For example, using the JAX interface with Cirq:\r\n\r\n  ```python\r\n  dev = qml.device('cirq.simulator', wires=1)\r\n  @qml.qnode(dev, interface=\"jax\", diff_method=\"parameter-shift\")\r\n  def circuit(x):\r\n      qml.RX(x[1], wires=0)\r\n      qml.Rot(x[0], x[1], x[2], wires=0)\r\n      return qml.expval(qml.PauliZ(0))\r\n  weights = jnp.array([0.2, 0.5, 0.1])\r\n  print(circuit(weights))\r\n  ```\r\n\r\n  Currently, when used with the parameter-shift differentiation method, only a single returned expectation value or variance is supported. Multiple expectations/variances, as well as probability and state returns, are not currently allowed.\r\n\r\n<h3>Improvements</h3>\r\n\r\n* The ``MottonenStatePreparation`` template has improved performance on states with only real amplitudes by reducing the number of redundant CNOT gates at the end of a circuit.\r\n\r\n  ```python\r\n  dev = qml.device(\"default.qubit\", wires=2)\r\n  \r\n  inputstate = [np.sqrt(0.2), np.sqrt(0.3), np.sqrt(0.4), np.sqrt(0.1)]\r\n  \r\n  @qml.qnode(dev)\r\n  def circuit():\r\n      mottonen.MottonenStatePreparation(inputstate,wires=[0, 1])\r\n      return qml.expval(qml.PauliZ(0))\r\n  ```\r\n\r\n  Previously returned:\r\n\r\n  ```pycon\r\n  >>> print(qml.draw(circuit)())\r\n  0: \u2500\u2500RY(1.57)\u2500\u2500\u256dC\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256dC\u2500\u2500\u256dC\u2500\u2500\u256dC\u2500\u2500\u2524 \u27e8Z\u27e9 \r\n  1: \u2500\u2500RY(1.35)\u2500\u2500\u2570X\u2500\u2500RY(0.422)\u2500\u2500\u2570X\u2500\u2500\u2570X\u2500\u2500\u2570X\u2500\u2500\u2524   \r\n  ```\r\n\r\n  In this release, it now returns:\r\n\r\n  ```pycon\r\n  >>> print(qml.draw(circuit)())\r\n  0: \u2500\u2500RY(1.57)\u2500\u2500\u256dC\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256dC\u2500\u2500\u2524 \u27e8Z\u27e9 \r\n  1: \u2500\u2500RY(1.35)\u2500\u2500\u2570X\u2500\u2500RY(0.422)\u2500\u2500\u2570X\u2500\u2500\u2524   \r\n  ```\r\n\r\n- The templates are now classes inheriting from `Operation`, and define the ansatz in their `expand()` method. This  change does not affect the user interface.  [(#1138)](https://github.com/PennyLaneAI/pennylane/pull/1138) [(#1156)](https://github.com/PennyLaneAI/pennylane/pull/1156) [(#1163)](https://github.com/PennyLaneAI/pennylane/pull/1163) [(#1192)](https://github.com/PennyLaneAI/pennylane/pull/1192)\r\n\r\n  For convenience, some templates have a new method that returns the expected shape of the trainable parameter tensor, which can be used to create  random tensors.\r\n  \r\n  ```python\r\n  shape = qml.templates.BasicEntanglerLayers.shape(n_layers=2, n_wires=4)\r\n  weights = np.random.random(shape)\r\n  qml.templates.BasicEntanglerLayers(weights, wires=range(4))\r\n  ```\r\n\r\n- `QubitUnitary` now validates to ensure the input matrix is two dimensional. [(#1128)](https://github.com/PennyLaneAI/pennylane/pull/1128)\r\n\r\n* Most layers in Pytorch or Keras accept arbitrary dimension inputs, where each dimension barring the last (in the case where the actual weight function of the layer operates on one-dimensional vectors) is broadcast over. This is now also supported by KerasLayer and TorchLayer. [(#1062)](https://github.com/PennyLaneAI/pennylane/pull/1062).\r\n\r\n  Example use:\r\n\r\n  ```python\r\n  dev = qml.device(\"default.qubit\", wires=4)\r\n  x = tf.ones((5, 4, 4))\r\n\r\n  @qml.qnode(dev)\r\n  def layer(weights, inputs):\r\n      qml.templates.AngleEmbedding(inputs, wires=range(4))\r\n      qml.templates.StronglyEntanglingLayers(weights, wires=range(4))\r\n      return [qml.expval(qml.PauliZ(i)) for i in range(4)]\r\n\r\n  qlayer = qml.qnn.KerasLayer(layer, {\"weights\": (4, 4, 3)}, output_dim=4)\r\n  out = qlayer(x)\r\n  ```\r\n\r\n  The output tensor has the following shape:\r\n  ```pycon\r\n  >>> out.shape\r\n  (5, 4, 4)\r\n  ```\r\n\r\n* If only one argument to the function `qml.grad` has the `requires_grad` attribute set to True, then the returned gradient will be a NumPy array, rather than a tuple of length 1. [(#1067)](https://github.com/PennyLaneAI/pennylane/pull/1067) [(#1081)](https://github.com/PennyLaneAI/pennylane/pull/1081)\r\n\r\n* An improvement has been made to how `QubitDevice` generates and post-processess samples, allowing QNode measurement statistics to work on devices with more than 32 qubits. [(#1088)](https://github.com/PennyLaneAI/pennylane/pull/1088)\r\n\r\n* Due to the addition of `density_matrix()` as a return type from a QNode, tuples are now supported by the `output_dim` parameter in `qnn.KerasLayer`. [(#1070)](https://github.com/PennyLaneAI/pennylane/pull/1070)\r\n\r\n* Two new utility methods are provided for working with quantum tapes. [(#1175)](https://github.com/PennyLaneAI/pennylane/pull/1175)\r\n\r\n  - `qml.tape.get_active_tape()` gets the currently recording tape.\r\n\r\n  - `tape.stop_recording()` is a context manager that temporarily stops the currently recording tape from recording additional   tapes or quantum operations.\r\n\r\n  For example:\r\n\r\n  ```pycon\r\n  >>> with qml.tape.QuantumTape():\r\n  ...     qml.RX(0, wires=0)\r\n  ...     current_tape = qml.tape.get_active_tape()\r\n  ...     with current_tape.stop_recording():\r\n  ...         qml.RY(1.0, wires=1)\r\n  ...     qml.RZ(2, wires=1)\r\n  >>> current_tape.operations\r\n  [RX(0, wires=[0]), RZ(2, wires=[1])]\r\n  ```\r\n\r\n* When printing `qml.Hamiltonian` objects, the terms are sorted by number of wires followed by coefficients. [(#981)](https://github.com/PennyLaneAI/pennylane/pull/981)\r\n\r\n* Adds `qml.math.conj` to the PennyLane math module. [(#1143)](https://github.com/PennyLaneAI/pennylane/pull/1143)\r\n\r\n  This new method will do elementwise conjugation to the given tensor-like object, correctly dispatching to the required tensor-manipulation framework to preserve differentiability.\r\n\r\n  ```python\r\n  >>> a = np.array([1.0 + 2.0j])\r\n  >>> qml.math.conj(a)\r\n  array([1.0 - 2.0j])\r\n  ```\r\n\r\n* The four-term parameter-shift rule, as used by the controlled rotation operations, has been updated to use coefficients that minimize the variance as per https://arxiv.org/abs/2104.05695. [(#1206)](https://github.com/PennyLaneAI/pennylane/pull/1206)\r\n\r\n* A new transform `qml.transforms.invisible` has been added, to make it easier to transform QNodes. [(#1175)](https://github.com/PennyLaneAI/pennylane/pull/1175)\r\n\r\n<h3>Breaking changes</h3>\r\n\r\n* Devices do not have an `analytic` argument or attribute anymore.  Instead, `shots` is the source of truth for whether a simulator  estimates return values from a finite number of shots, or whether  it returns analytic results (`shots=None`). [(#1079)](https://github.com/PennyLaneAI/pennylane/pull/1079) [(#1196)](https://github.com/PennyLaneAI/pennylane/pull/1196)\r\n  \r\n  ```python  \r\n  dev_analytic = qml.device('default.qubit', wires=1, shots=None)\r\n  dev_finite_shots = qml.device('default.qubit', wires=1, shots=1000)\r\n  \r\n  def circuit():\r\n      qml.Hadamard(wires=0)\r\n      return qml.expval(qml.PauliZ(wires=0))\r\n  \r\n  circuit_analytic = qml.QNode(circuit, dev_analytic)\r\n  circuit_finite_shots = qml.QNode(circuit, dev_finite_shots)\r\n  ```\r\n  \r\n  Devices with `shots=None` return deterministic, exact results:\r\n  \r\n  ```pycon\r\n  >>> circuit_analytic()\r\n  0.0\r\n  >>> circuit_analytic()\r\n  0.0\r\n  ```\r\n  Devices with `shots > 0` return stochastic results estimated from \r\n  samples in each run:\r\n\r\n  ```pycon\r\n  >>> circuit_finite_shots()\r\n  -0.062\r\n  >>> circuit_finite_shots()\r\n  0.034\r\n  ```\r\n  \r\n  The `qml.sample()` measurement can only be used on devices on which the number  of shots is set explicitly. \r\n\r\n* If creating a QNode from a quantum function with an argument named `shots`, a `DeprecationWarning` is raised, warning the user that this is a reserved argument to change the number of shots on a per-call basis. [(#1075)](https://github.com/PennyLaneAI/pennylane/pull/1075)\r\n\r\n* For devices inheriting from `QubitDevice`, the methods `expval`, `var`, `sample` accept two new keyword arguments --- `shot_range` and `bin_size`. [(#1103)](https://github.com/PennyLaneAI/pennylane/pull/1103)\r\n\r\n  These new arguments allow for the statistics to be performed on only a subset of device samples. This finer level of control is accessible from the main UI by instantiating a device with a batch of shots.\r\n\r\n  For example, consider the following device:\r\n\r\n  ```pycon\r\n  >>> dev = qml.device(\"my_device\", shots=[5, (10, 3), 100])\r\n  ```\r\n\r\n  This device will execute QNodes using 135 shots, however measurement statistics will be **course grained** across these 135 shots:\r\n\r\n  * All measurement statistics will first be computed using the   first 5 shots --- that is, `shots_range=[0, 5]`, `bin_size=5`.\r\n\r\n  * Next, the tuple `(10, 3)` indicates 10 shots, repeated 3 times. This will use   `shot_range=[5, 35]`, performing the expectation value in bins of size 10   (`bin_size=10`).\r\n\r\n  * Finally, we repeat the measurement statistics for the final 100 shots,   `shot_range=[35, 135]`, `bin_size=100`.\r\n\r\n\r\n* The old PennyLane core has been removed, including the following modules: [(#1100)](https://github.com/PennyLaneAI/pennylane/pull/1100)\r\n\r\n  - `pennylane.variables`\r\n  - `pennylane.qnodes`\r\n\r\n  As part of this change, the location of the new core within the Python\r\n  module has been moved:\r\n\r\n  - Moves `pennylane.tape.interfaces` \u2192 `pennylane.interfaces`\r\n  - Merges `pennylane.CircuitGraph` and `pennylane.TapeCircuitGraph`  \u2192 `pennylane.CircuitGraph`\r\n  - Merges `pennylane.OperationRecorder` and `pennylane.TapeOperationRecorder`  \u2192\r\n  - `pennylane.tape.operation_recorder`\r\n  - Merges `pennylane.measure` and `pennylane.tape.measure` \u2192 `pennylane.measure`\r\n  - Merges `pennylane.operation` and `pennylane.tape.operation` \u2192 `pennylane.operation`\r\n  - Merges `pennylane._queuing` and `pennylane.tape.queuing` \u2192 `pennylane.queuing`\r\n\r\n  This has no affect on import location.\r\n\r\n  In addition,\r\n\r\n  - All tape-mode functions have been removed (`qml.enable_tape()`, `qml.tape_mode_active()`),\r\n  - All tape fixtures have been deleted,\r\n  - Tests specifically for non-tape mode have been deleted.\r\n\r\n* The device test suite no longer accepts the `analytic` keyword. [(#1216)](https://github.com/PennyLaneAI/pennylane/pull/1216)\r\n\r\n<h3>Bug fixes</h3>\r\n\r\n* Fixes a bug where using the circuit drawer with a `ControlledQubitUnitary` operation raised an error. [(#1174)](https://github.com/PennyLaneAI/pennylane/pull/1174)\r\n\r\n* Fixes a bug and a test where the ``QuantumTape.is_sampled`` attribute was not being updated. [(#1126)](https://github.com/PennyLaneAI/pennylane/pull/1126)\r\n\r\n* Fixes a bug where `BasisEmbedding` would not accept inputs whose bits are all ones  or all zeros.  [(#1114)](https://github.com/PennyLaneAI/pennylane/pull/1114)\r\n\r\n* The `ExpvalCost` class raises an error if instantiated with non-expectation measurement statistics. [(#1106)](https://github.com/PennyLaneAI/pennylane/pull/1106)\r\n\r\n* Fixes a bug where decompositions would reset the differentiation method of a QNode. [(#1117)](https://github.com/PennyLaneAI/pennylane/pull/1117)\r\n\r\n* Fixes a bug where the second-order CV parameter-shift rule would error if attempting to compute the gradient of a QNode with more than one second-order observable. [(#1197)](https://github.com/PennyLaneAI/pennylane/pull/1197)\r\n\r\n* Fixes a bug where repeated Torch interface applications after expansion caused an error. [(#1223)](https://github.com/PennyLaneAI/pennylane/pull/1223)\r\n\r\n* Sampling works correctly with batches of shots specified as a list. [(#1232)](https://github.com/PennyLaneAI/pennylane/pull/1232)\r\n\r\n<h3>Documentation</h3>\r\n\r\n- Updated the diagram used in the Architectural overview page of the Development guide such that it doesn't mention Variables. [(#1235)](https://github.com/PennyLaneAI/pennylane/pull/1235)\r\n\r\n- Typos addressed in templates documentation. [(#1094)](https://github.com/PennyLaneAI/pennylane/pull/1094)\r\n\r\n- Upgraded the documentation to use Sphinx 3.5.3 and the new m2r2 package. [(#1186)](https://github.com/PennyLaneAI/pennylane/pull/1186)\r\n\r\n- Added `flaky` as dependency for running tests in the documentation. [(#1113)](https://github.com/PennyLaneAI/pennylane/pull/1113)\r\n\r\n<h3>Contributors</h3>\r\n\r\nThis release contains contributions from (in alphabetical order):\r\n\r\nShahnawaz Ahmed, Juan Miguel Arrazola, Thomas Bromley, Olivia Di Matteo, Alain Delgado Gran, Kyle Godbey, Diego Guala, Theodor Isacsson, Josh Izaac, Soran Jahangiri, Nathan Killoran, Christina Lee, Daniel Polatajko, Chase Roberts, Sankalp Sanand, Pritish Sehzpaul, Maria Schuld, Antal Sz\u00e1va, David Wierichs."}
{"url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/37981242", "assets_url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/37981242/assets", "upload_url": "https://uploads.github.com/repos/PennyLaneAI/pennylane/releases/37981242/assets{?name,label}", "html_url": "https://github.com/PennyLaneAI/pennylane/releases/tag/v0.14.1", "id": 37981242, "author": {"login": "thisac", "id": 6934626, "node_id": "MDQ6VXNlcjY5MzQ2MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/6934626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thisac", "html_url": "https://github.com/thisac", "followers_url": "https://api.github.com/users/thisac/followers", "following_url": "https://api.github.com/users/thisac/following{/other_user}", "gists_url": "https://api.github.com/users/thisac/gists{/gist_id}", "starred_url": "https://api.github.com/users/thisac/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thisac/subscriptions", "organizations_url": "https://api.github.com/users/thisac/orgs", "repos_url": "https://api.github.com/users/thisac/repos", "events_url": "https://api.github.com/users/thisac/events{/privacy}", "received_events_url": "https://api.github.com/users/thisac/received_events", "type": "User", "site_admin": false}, "node_id": "MDc6UmVsZWFzZTM3OTgxMjQy", "tag_name": "v0.14.1", "target_commitish": "v0.14.1-bugfix", "name": "Release 0.14.1", "draft": false, "prerelease": false, "created_at": "2021-02-12T13:58:47Z", "published_at": "2021-02-12T15:50:08Z", "assets": [], "tarball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/tarball/v0.14.1", "zipball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/zipball/v0.14.1", "body": "<h3>Bug fixes</h3>\r\n\r\n* Fixes a bug where inverse operations could not be differentiated using backpropagation on `default.qubit`. [(#1072)](https://github.com/PennyLaneAI/pennylane/pull/1072)\r\n\r\n* The QNode has a new keyword argument, `max_expansion`, that determines the maximum number of times the internal circuit should be expanded when executed on a device. In addition, the default number of max expansions has been increased from 2 to 10, allowing devices that require more than two operator decompositions to be supported.  [(#1074)](https://github.com/PennyLaneAI/pennylane/pull/1074)\r\n\r\n* Fixes a bug where `Hamiltonian` objects created with non-list arguments raised an error for arithmetic operations. [(#1082)](https://github.com/PennyLaneAI/pennylane/pull/1082)\r\n\r\n* Fixes a bug where `Hamiltonian` objects with no coefficients or operations would return a faulty result when used with `ExpvalCost`. [(#1082)](https://github.com/PennyLaneAI/pennylane/pull/1082)\r\n\r\n* Fixes a testing bug where tests that required JAX would fail if JAX was not installed. The tests will now instead be skipped if JAX cannot be imported. [(#1066)](https://github.com/PennyLaneAI/pennylane/pull/1066)\r\n\r\n<h3>Documentation</h3>\r\n\r\n* Updates mentions of `generate_hamiltonian` to `molecular_hamiltonian` in the docstrings of the `ExpvalCost` and `Hamiltonian` classes. [(#1077)](https://github.com/PennyLaneAI/pennylane/pull/1077)\r\n\r\n<h3>Contributors</h3>\r\n\r\nThis release contains contributions from (in alphabetical order):\r\n\r\nThomas Bromley, Josh Izaac, Antal Sz\u00e1va.\r\n"}
{"url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/37220215", "assets_url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/37220215/assets", "upload_url": "https://uploads.github.com/repos/PennyLaneAI/pennylane/releases/37220215/assets{?name,label}", "html_url": "https://github.com/PennyLaneAI/pennylane/releases/tag/v0.14.0", "id": 37220215, "author": {"login": "josh146", "id": 2959003, "node_id": "MDQ6VXNlcjI5NTkwMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/2959003?v=4", "gravatar_id": "", "url": "https://api.github.com/users/josh146", "html_url": "https://github.com/josh146", "followers_url": "https://api.github.com/users/josh146/followers", "following_url": "https://api.github.com/users/josh146/following{/other_user}", "gists_url": "https://api.github.com/users/josh146/gists{/gist_id}", "starred_url": "https://api.github.com/users/josh146/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/josh146/subscriptions", "organizations_url": "https://api.github.com/users/josh146/orgs", "repos_url": "https://api.github.com/users/josh146/repos", "events_url": "https://api.github.com/users/josh146/events{/privacy}", "received_events_url": "https://api.github.com/users/josh146/received_events", "type": "User", "site_admin": false}, "node_id": "MDc6UmVsZWFzZTM3MjIwMjE1", "tag_name": "v0.14.0", "target_commitish": "master", "name": "Release 0.14.0", "draft": false, "prerelease": false, "created_at": "2021-02-02T08:05:59Z", "published_at": "2021-02-02T08:13:45Z", "assets": [], "tarball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/tarball/v0.14.0", "zipball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/zipball/v0.14.0", "body": "\r\n<h3>New features since last release</h3>\r\n\r\n<h4>Perform quantum machine learning with JAX</h4>\r\n\r\n* QNodes created with `default.qubit` now support a JAX interface, allowing JAX to be used to create, differentiate, and optimize hybrid quantum-classical models. [(#947)](https://github.com/PennyLaneAI/pennylane/pull/947)\r\n\r\n  This is supported internally via a new `default.qubit.jax` device. This device runs end to end in JAX, meaning that it supports all of the awesome JAX transformations (`jax.vmap`, `jax.jit`, `jax.hessian`, etc).\r\n\r\n  Here is an example of how to use the new JAX interface:\r\n\r\n  ```python\r\n  dev = qml.device(\"default.qubit\", wires=1)\r\n  @qml.qnode(dev, interface=\"jax\", diff_method=\"backprop\")\r\n  def circuit(x):\r\n      qml.RX(x[1], wires=0)\r\n      qml.Rot(x[0], x[1], x[2], wires=0)\r\n      return qml.expval(qml.PauliZ(0))\r\n\r\n  weights = jnp.array([0.2, 0.5, 0.1])\r\n  grad_fn = jax.grad(circuit)\r\n  print(grad_fn(weights))\r\n  ```\r\n\r\n  Currently, only `diff_method=\"backprop\"` is supported, with plans to support more in the future.\r\n\r\n<h4>New, faster, quantum gradient methods</h4>\r\n\r\n* A new differentiation method has been added for use with simulators. The `\"adjoint\"` method operates after a forward pass by iteratively applying inverse gates to scan backwards through the circuit. [(#1032)](https://github.com/PennyLaneAI/pennylane/pull/1032)\r\n\r\n  This method is similar to the reversible method, but has a lower time overhead and a similar memory overhead. It follows the approach provided by [Jones and Gacon](https://arxiv.org/abs/2009.02823). This method is only compatible with certain statevector-based devices such as `default.qubit`.\r\n\r\n  Example use:\r\n\r\n  ```python\r\n  import pennylane as qml\r\n\r\n  wires = 1\r\n  device = qml.device(\"default.qubit\", wires=wires)\r\n\r\n  @qml.qnode(device, diff_method=\"adjoint\")\r\n  def f(params):\r\n      qml.RX(0.1, wires=0)\r\n      qml.Rot(*params, wires=0)\r\n      qml.RX(-0.3, wires=0)\r\n      return qml.expval(qml.PauliZ(0))\r\n\r\n  params = [0.1, 0.2, 0.3]\r\n  qml.grad(f)(params)\r\n  ```\r\n\r\n* The default logic for choosing the 'best' differentiation method has been altered to improve performance. [(#1008)](https://github.com/PennyLaneAI/pennylane/pull/1008)\r\n\r\n  - If the quantum device provides its own gradient, this is now the preferred differentiation method.\r\n\r\n  - If the quantum device natively supports classical backpropagation, this is now preferred over the parameter-shift rule.\r\n\r\n    This will lead to marked speed improvement during optimization when using `default.qubit`, with a sight penalty on the forward-pass evaluation.\r\n\r\n  More details are available below in the 'Improvements' section for plugin developers.\r\n\r\n* PennyLane now supports analytical quantum gradients for noisy channels, in addition to its existing support for unitary operations. The noisy channels `BitFlip`, `PhaseFlip`, and `DepolarizingChannel` all support analytic gradients out of the box. [(#968)](https://github.com/PennyLaneAI/pennylane/pull/968)\r\n\r\n* A method has been added for calculating the Hessian of quantum circuits using the second-order parameter shift formula. [(#961)](https://github.com/PennyLaneAI/pennylane/pull/961)\r\n\r\n  The following example shows the calculation of the Hessian:\r\n\r\n  ```python\r\n  n_wires = 5\r\n  weights = [2.73943676, 0.16289932, 3.4536312, 2.73521126, 2.6412488]\r\n\r\n  dev = qml.device(\"default.qubit\", wires=n_wires)\r\n\r\n  with qml.tape.QubitParamShiftTape() as tape:\r\n      for i in range(n_wires):\r\n          qml.RX(weights[i], wires=i)\r\n\r\n      qml.CNOT(wires=[0, 1])\r\n      qml.CNOT(wires=[2, 1])\r\n      qml.CNOT(wires=[3, 1])\r\n      qml.CNOT(wires=[4, 3])\r\n\r\n      qml.expval(qml.PauliZ(1))\r\n\r\n  print(tape.hessian(dev))\r\n  ```\r\n\r\n  The Hessian is not yet supported via classical machine learning interfaces, but will be added in a future release.\r\n\r\n<h4>More operations and templates</h4>\r\n\r\n* Two new error channels, `BitFlip` and `PhaseFlip` have been added. [(#954)](https://github.com/PennyLaneAI/pennylane/pull/954)\r\n\r\n  They can be used in the same manner as existing error channels:\r\n\r\n  ```python\r\n  dev = qml.device(\"default.mixed\", wires=2)\r\n\r\n  @qml.qnode(dev)\r\n  def circuit():\r\n      qml.RX(0.3, wires=0)\r\n      qml.RY(0.5, wires=1)\r\n      qml.BitFlip(0.01, wires=0)\r\n      qml.PhaseFlip(0.01, wires=1)\r\n      return qml.expval(qml.PauliZ(0))\r\n  ```\r\n\r\n* Apply permutations to wires using the `Permute` subroutine. [(#952)](https://github.com/PennyLaneAI/pennylane/pull/952)\r\n\r\n  ```python\r\n  import pennylane as qml\r\n  dev = qml.device('default.qubit', wires=5)\r\n\r\n  @qml.qnode(dev)\r\n  def apply_perm():\r\n      # Send contents of wire 4 to wire 0, of wire 2 to wire 1, etc.\r\n      qml.templates.Permute([4, 2, 0, 1, 3], wires=dev.wires)\r\n      return qml.expval(qml.PauliZ(0))\r\n  ```\r\n\r\n<h4>QNode transformations</h4>\r\n\r\n* The `qml.metric_tensor` function transforms a QNode to produce the Fubini-Study metric tensor with full autodifferentiation support---even on hardware. [(#1014)](https://github.com/PennyLaneAI/pennylane/pull/1014)\r\n\r\n  Consider the following QNode:\r\n\r\n  ```python\r\n  dev = qml.device(\"default.qubit\", wires=3)\r\n\r\n  @qml.qnode(dev, interface=\"autograd\")\r\n  def circuit(weights):\r\n      # layer 1\r\n      qml.RX(weights[0, 0], wires=0)\r\n      qml.RX(weights[0, 1], wires=1)\r\n\r\n      qml.CNOT(wires=[0, 1])\r\n      qml.CNOT(wires=[1, 2])\r\n\r\n      # layer 2\r\n      qml.RZ(weights[1, 0], wires=0)\r\n      qml.RZ(weights[1, 1], wires=2)\r\n\r\n      qml.CNOT(wires=[0, 1])\r\n      qml.CNOT(wires=[1, 2])\r\n      return qml.expval(qml.PauliZ(0) @ qml.PauliZ(1)), qml.expval(qml.PauliY(2))\r\n  ```\r\n\r\n  We can use the `metric_tensor` function to generate a new function, that returns the metric tensor of this QNode:\r\n\r\n  ```pycon\r\n  >>> met_fn = qml.metric_tensor(circuit)\r\n  >>> weights = np.array([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]], requires_grad=True)\r\n  >>> met_fn(weights)\r\n  tensor([[0.25  , 0.    , 0.    , 0.    ],\r\n          [0.    , 0.25  , 0.    , 0.    ],\r\n          [0.    , 0.    , 0.0025, 0.0024],\r\n          [0.    , 0.    , 0.0024, 0.0123]], requires_grad=True)\r\n  ```\r\n\r\n  The returned metric tensor is also fully differentiable, in all interfaces. For example, differentiating the `(3, 2)` element:\r\n\r\n  ```pycon\r\n  >>> grad_fn = qml.grad(lambda x: met_fn(x)[3, 2])\r\n  >>> grad_fn(weights)\r\n  array([[ 0.04867729, -0.00049502,  0.        ],\r\n         [ 0.        ,  0.        ,  0.        ]])\r\n  ```\r\n\r\n  Differentiation is also supported using Torch, Jax, and TensorFlow.\r\n\r\n* Adds the new function `qml.math.cov_matrix()`. This function accepts a list of commuting observables, and the probability distribution in the shared observable eigenbasis after the application of an ansatz. It uses these to construct the covariance matrix in a *framework independent* manner, such that the output covariance matrix is autodifferentiable. [(#1012)](https://github.com/PennyLaneAI/pennylane/pull/1012)\r\n\r\n  For example, consider the following ansatz and observable list:\r\n\r\n  ```python3\r\n  obs_list = [qml.PauliX(0) @ qml.PauliZ(1), qml.PauliY(2)]\r\n  ansatz = qml.templates.StronglyEntanglingLayers\r\n  ```\r\n\r\n  We can construct a QNode to output the probability distribution in the shared eigenbasis of the observables:\r\n\r\n  ```python\r\n  dev = qml.device(\"default.qubit\", wires=3)\r\n\r\n  @qml.qnode(dev, interface=\"autograd\")\r\n  def circuit(weights):\r\n      ansatz(weights, wires=[0, 1, 2])\r\n      # rotate into the basis of the observables\r\n      for o in obs_list:\r\n          o.diagonalizing_gates()\r\n      return qml.probs(wires=[0, 1, 2])\r\n  ```\r\n\r\n  We can now compute the covariance matrix:\r\n\r\n  ```pycon\r\n  >>> weights = qml.init.strong_ent_layers_normal(n_layers=2, n_wires=3)\r\n  >>> cov = qml.math.cov_matrix(circuit(weights), obs_list)\r\n  >>> cov\r\n  array([[0.98707611, 0.03665537],\r\n         [0.03665537, 0.99998377]])\r\n  ```\r\n\r\n  Autodifferentiation is fully supported using all interfaces:\r\n\r\n  ```pycon\r\n  >>> cost_fn = lambda weights: qml.math.cov_matrix(circuit(weights), obs_list)[0, 1]\r\n  >>> qml.grad(cost_fn)(weights)[0]\r\n  array([[[ 4.94240914e-17, -2.33786398e-01, -1.54193959e-01],\r\n          [-3.05414996e-17,  8.40072236e-04,  5.57884080e-04],\r\n          [ 3.01859411e-17,  8.60411436e-03,  6.15745204e-04]],\r\n\r\n         [[ 6.80309533e-04, -1.23162742e-03,  1.08729813e-03],\r\n          [-1.53863193e-01, -1.38700657e-02, -1.36243323e-01],\r\n          [-1.54665054e-01, -1.89018172e-02, -1.56415558e-01]]])\r\n  ```\r\n\r\n* A new  `qml.draw` function is available, allowing QNodes to be easily drawn without execution by providing example input. [(#962)](https://github.com/PennyLaneAI/pennylane/pull/962)\r\n\r\n  ```python\r\n  @qml.qnode(dev)\r\n  def circuit(a, w):\r\n      qml.Hadamard(0)\r\n      qml.CRX(a, wires=[0, 1])\r\n      qml.Rot(*w, wires=[1])\r\n      qml.CRX(-a, wires=[0, 1])\r\n      return qml.expval(qml.PauliZ(0) @ qml.PauliZ(1))\r\n  ```\r\n\r\n  The QNode circuit structure may depend on the input arguments; this is taken into account by passing example QNode arguments to the `qml.draw()` drawing function:\r\n\r\n  ```pycon\r\n  >>> drawer = qml.draw(circuit)\r\n  >>> result = drawer(a=2.3, w=[1.2, 3.2, 0.7])\r\n  >>> print(result)\r\n  0: \u2500\u2500H\u2500\u2500\u256dC\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256dC\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256d\u2524 \u27e8Z \u2297 Z\u27e9\r\n  1: \u2500\u2500\u2500\u2500\u2500\u2570RX(2.3)\u2500\u2500Rot(1.2, 3.2, 0.7)\u2500\u2500\u2570RX(-2.3)\u2500\u2500\u2570\u2524 \u27e8Z \u2297 Z\u27e9\r\n  ```\r\n\r\n<h4>A faster, leaner, and more flexible core</h4>\r\n\r\n* The new core of PennyLane, rewritten from the ground up and developed over the last few release cycles, has achieved feature parity and has been made the new default in PennyLane v0.14. The old core has been marked as deprecated, and will be removed in an upcoming release. [(#1046)](https://github.com/PennyLaneAI/pennylane/pull/1046) [(#1040)](https://github.com/PennyLaneAI/pennylane/pull/1040) [(#1034)](https://github.com/PennyLaneAI/pennylane/pull/1034) [(#1035)](https://github.com/PennyLaneAI/pennylane/pull/1035) [(#1027)](https://github.com/PennyLaneAI/pennylane/pull/1027) [(#1026)](https://github.com/PennyLaneAI/pennylane/pull/1026) [(#1021)](https://github.com/PennyLaneAI/pennylane/pull/1021) [(#1054)](https://github.com/PennyLaneAI/pennylane/pull/1054) [(#1049)](https://github.com/PennyLaneAI/pennylane/pull/1049)\r\n\r\n  While high-level PennyLane code and tutorials remain unchanged, the new core provides several advantages and improvements:\r\n\r\n  - **Faster and more optimized**: The new core provides various performance optimizations, reducing pre- and post-processing overhead, and reduces the number of quantum evaluations in certain cases.\r\n\r\n  - **Support for in-QNode classical processing**: this allows for differentiable classical processing within the QNode.\r\n\r\n    ```python\r\n    dev = qml.device(\"default.qubit\", wires=1)\r\n\r\n    @qml.qnode(dev, interface=\"tf\")\r\n    def circuit(p):\r\n        qml.RX(tf.sin(p[0])**2 + p[1], wires=0)\r\n        return qml.expval(qml.PauliZ(0))\r\n    ```\r\n\r\n    The classical processing functions used within the QNode must match the QNode interface. Here, we use TensorFlow:\r\n\r\n    ```pycon\r\n    >>> params = tf.Variable([0.5, 0.1], dtype=tf.float64)\r\n    >>> with tf.GradientTape() as tape:\r\n    ...     res = circuit(params)\r\n    >>> grad = tape.gradient(res, params)\r\n    >>> print(res)\r\n    tf.Tensor(0.9460913127754935, shape=(), dtype=float64)\r\n    >>> print(grad)\r\n    tf.Tensor([-0.27255248 -0.32390003], shape=(2,), dtype=float64)\r\n    ```\r\n\r\n    As a result of this change, quantum decompositions that require classical processing are fully supported and end-to-end differentiable in tape mode.\r\n\r\n  - **No more Variable wrapping**: QNode arguments no longer become `Variable` objects within the QNode.\r\n\r\n    ```python\r\n    dev = qml.device(\"default.qubit\", wires=1)\r\n\r\n    @qml.qnode(dev)\r\n    def circuit(x):\r\n        print(\"Parameter value:\", x)\r\n        qml.RX(x, wires=0)\r\n        return qml.expval(qml.PauliZ(0))\r\n    ```\r\n\r\n    Internal QNode parameters can be easily inspected, printed, and manipulated:\r\n\r\n    ```pycon\r\n    >>> circuit(0.5)\r\n    Parameter value: 0.5\r\n    tensor(0.87758256, requires_grad=True)\r\n    ```\r\n\r\n  - **Less restrictive QNode signatures**: There is no longer any restriction on the QNode signature; the QNode can be defined and called following the same rules as standard Python functions.\r\n\r\n    For example, the following QNode uses positional, named, and variable keyword arguments:\r\n\r\n    ```python\r\n    x = torch.tensor(0.1, requires_grad=True)\r\n    y = torch.tensor([0.2, 0.3], requires_grad=True)\r\n    z = torch.tensor(0.4, requires_grad=True)\r\n\r\n    @qml.qnode(dev, interface=\"torch\")\r\n    def circuit(p1, p2=y, **kwargs):\r\n        qml.RX(p1, wires=0)\r\n        qml.RY(p2[0] * p2[1], wires=0)\r\n        qml.RX(kwargs[\"p3\"], wires=0)\r\n        return qml.var(qml.PauliZ(0))\r\n    ```\r\n\r\n    When we call the QNode, we may pass the arguments by name even if defined positionally; any argument not provided will use the default value.\r\n\r\n    ```pycon\r\n    >>> res = circuit(p1=x, p3=z)\r\n    >>> print(res)\r\n    tensor(0.2327, dtype=torch.float64, grad_fn=<SelectBackward>)\r\n    >>> res.backward()\r\n    >>> print(x.grad, y.grad, z.grad)\r\n    tensor(0.8396) tensor([0.0289, 0.0193]) tensor(0.8387)\r\n    ```\r\n\r\n    This extends to the `qnn` module, where `KerasLayer` and `TorchLayer` modules can be created from QNodes with unrestricted signatures.\r\n\r\n  - **Smarter measurements:** QNodes can now measure wires more than once, as long as all observables are commuting:\r\n\r\n    ```python\r\n    @qml.qnode(dev)\r\n    def circuit(x):\r\n        qml.RX(x, wires=0)\r\n        return [\r\n            qml.expval(qml.PauliZ(0)),\r\n            qml.expval(qml.PauliZ(0) @ qml.PauliZ(1))\r\n        ]\r\n    ```\r\n\r\n    Further, the `qml.ExpvalCost()` function allows for optimizing measurements to reduce the number of quantum evaluations required.\r\n\r\n  With the new PennyLane core, there are a few small breaking changes, detailed below in the 'Breaking Changes' section.\r\n\r\n<h3>Improvements</h3>\r\n\r\n* The built-in PennyLane optimizers allow more flexible cost functions. The cost function passed to most optimizers may accept any combination of trainable arguments, non-trainable arguments, and keyword arguments. [(#959)](https://github.com/PennyLaneAI/pennylane/pull/959) [(#1053)](https://github.com/PennyLaneAI/pennylane/pull/1053)\r\n\r\n  The full changes apply to:\r\n\r\n  * `AdagradOptimizer`\r\n  * `AdamOptimizer`\r\n  * `GradientDescentOptimizer`\r\n  * `MomentumOptimizer`\r\n  * `NesterovMomentumOptimizer`\r\n  * `RMSPropOptimizer`\r\n  * `RotosolveOptimizer`\r\n\r\n  The `requires_grad=False` property must mark any non-trainable constant argument. The `RotoselectOptimizer` allows passing only keyword arguments.\r\n\r\n  Example use:\r\n\r\n  ```python\r\n  def cost(x, y, data, scale=1.0):\r\n      return scale * (x[0]-data)**2 + scale * (y-data)**2\r\n\r\n  x = np.array([1.], requires_grad=True)\r\n  y = np.array([1.0])\r\n  data = np.array([2.], requires_grad=False)\r\n\r\n  opt = qml.GradientDescentOptimizer()\r\n\r\n  # the optimizer step and step_and_cost methods can\r\n  # now update multiple parameters at once\r\n  x_new, y_new, data = opt.step(cost, x, y, data, scale=0.5)\r\n  (x_new, y_new, data), value = opt.step_and_cost(cost, x, y, data, scale=0.5)\r\n\r\n  # list and tuple unpacking is also supported\r\n  params = (x, y, data)\r\n  params = opt.step(cost, *params)\r\n  ```\r\n\r\n* The circuit drawer has been updated to support the inclusion of unused or inactive wires, by passing the `show_all_wires` argument. [(#1033)](https://github.com/PennyLaneAI/pennylane/pull/1033)\r\n\r\n  ```python\r\n  dev = qml.device('default.qubit', wires=[-1, \"a\", \"q2\", 0])\r\n\r\n  @qml.qnode(dev)\r\n  def circuit():\r\n      qml.Hadamard(wires=-1)\r\n      qml.CNOT(wires=[-1, \"q2\"])\r\n      return qml.expval(qml.PauliX(wires=\"q2\"))\r\n  ```\r\n\r\n  ```pycon\r\n  >>> print(qml.draw(circuit, show_all_wires=True)())\r\n  >>>\r\n   -1: \u2500\u2500H\u2500\u2500\u256dC\u2500\u2500\u2524\r\n    a: \u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2524\r\n   q2: \u2500\u2500\u2500\u2500\u2500\u2570X\u2500\u2500\u2524 \u27e8X\u27e9\r\n    0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n  ```\r\n\r\n* The logic for choosing the 'best' differentiation method has been altered to improve performance. [(#1008)](https://github.com/PennyLaneAI/pennylane/pull/1008)\r\n\r\n  - If the device provides its own gradient, this is now the preferred differentiation method.\r\n\r\n  - If a device provides additional interface-specific versions that natively support classical backpropagation, this is now preferred over the parameter-shift rule.\r\n\r\n    Devices define additional interface-specific devices via their `capabilities()` dictionary. For example, `default.qubit` supports supplementary devices for TensorFlow, Autograd, and JAX:\r\n\r\n    ```python\r\n    {\r\n      \"passthru_devices\": {\r\n          \"tf\": \"default.qubit.tf\",\r\n          \"autograd\": \"default.qubit.autograd\",\r\n          \"jax\": \"default.qubit.jax\",\r\n      },\r\n    }\r\n    ```\r\n\r\n  As a result of this change, if the QNode `diff_method` is not explicitly provided, it is possible that the QNode will run on a *supplementary device* of the device that was specifically provided:\r\n\r\n  ```python\r\n  dev = qml.device(\"default.qubit\", wires=2)\r\n  qml.QNode(dev) # will default to backprop on default.qubit.autograd\r\n  qml.QNode(dev, interface=\"tf\") # will default to backprop on default.qubit.tf\r\n  qml.QNode(dev, interface=\"jax\") # will default to backprop on default.qubit.jax\r\n  ```\r\n\r\n* The `default.qubit` device has been updated so that internally it applies operations in a more functional style, i.e., by accepting an input state and returning an evolved state. [(#1025)](https://github.com/PennyLaneAI/pennylane/pull/1025)\r\n\r\n* A new test series, `pennylane/devices/tests/test_compare_default_qubit.py`, has been added, allowing to test if a chosen device gives the same result as `default.qubit`. [(#897)](https://github.com/PennyLaneAI/pennylane/pull/897)\r\n\r\n  Three tests are added:\r\n\r\n  - `test_hermitian_expectation`,\r\n  - `test_pauliz_expectation_analytic`, and\r\n  - `test_random_circuit`.\r\n\r\n* Adds the following agnostic tensor manipulation functions to the `qml.math` module: `abs`, `angle`, `arcsin`, `concatenate`, `dot`, `squeeze`, `sqrt`, `sum`, `take`, `where`. These functions are required to fully support end-to-end differentiable Mottonen and Amplitude embedding. [(#922)](https://github.com/PennyLaneAI/pennylane/pull/922) [(#1011)](https://github.com/PennyLaneAI/pennylane/pull/1011)\r\n\r\n* The `qml.math` module now supports JAX. [(#985)](https://github.com/XanaduAI/software-docs/pull/274)\r\n\r\n* Several improvements have been made to the `Wires` class to reduce overhead and simplify the logic of how wire labels are interpreted: [(#1019)](https://github.com/PennyLaneAI/pennylane/pull/1019) [(#1010)](https://github.com/PennyLaneAI/pennylane/pull/1010) [(#1005)](https://github.com/PennyLaneAI/pennylane/pull/1005) [(#983)](https://github.com/PennyLaneAI/pennylane/pull/983) [(#967)](https://github.com/PennyLaneAI/pennylane/pull/967)\r\n\r\n  - If the input `wires` to a wires class instantiation `Wires(wires)` can be iterated over, its elements are interpreted as wire labels. Otherwise, `wires` is interpreted as a single wire label. The only exception to this are strings, which are always interpreted as a single wire label, so users can address wires with labels such as `\"ancilla\"`.\r\n\r\n  - Any type can now be a wire label as long as it is hashable. The hash is used to establish the uniqueness of two labels.\r\n\r\n  - Indexing wires objects now returns a label, instead of a new `Wires` object. For example:\r\n\r\n    ```pycon\r\n    >>> w = Wires([0, 1, 2])\r\n    >>> w[1]\r\n    >>> 1\r\n    ```\r\n\r\n  - The check for uniqueness of wires moved from `Wires` instantiation to the `qml.wires._process` function in order to reduce overhead from repeated creation of `Wires` instances.\r\n\r\n  - Calls to the `Wires` class are substantially reduced, for example by avoiding to call Wires on Wires instances on `Operation` instantiation, and by using labels instead of `Wires` objects inside the default qubit device.\r\n\r\n* Adds the `PauliRot` generator to the `qml.operation` module. This generator is required to construct the metric tensor. [(#963)](https://github.com/PennyLaneAI/pennylane/pull/963)\r\n\r\n* The templates are modified to make use of the new `qml.math` module, for framework-agnostic tensor manipulation. This allows the template library to be differentiable in backpropagation mode (`diff_method=\"backprop\"`). [(#873)](https://github.com/PennyLaneAI/pennylane/pull/873)\r\n\r\n* The circuit drawer now allows for the wire order to be (optionally) modified: [(#992)](https://github.com/PennyLaneAI/pennylane/pull/992)\r\n\r\n  ```pycon\r\n  >>> dev = qml.device('default.qubit', wires=[\"a\", -1, \"q2\"])\r\n  >>> @qml.qnode(dev)\r\n  ... def circuit():\r\n  ...     qml.Hadamard(wires=-1)\r\n  ...     qml.CNOT(wires=[\"a\", \"q2\"])\r\n  ...     qml.RX(0.2, wires=\"a\")\r\n  ...     return qml.expval(qml.PauliX(wires=\"q2\"))\r\n  ```\r\n\r\n  Printing with default wire order of the device:\r\n\r\n  ```pycon\r\n  >>> print(circuit.draw())\r\n    a: \u2500\u2500\u2500\u2500\u2500\u256dC\u2500\u2500RX(0.2)\u2500\u2500\u2524\r\n   -1: \u2500\u2500H\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n   q2: \u2500\u2500\u2500\u2500\u2500\u2570X\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u27e8X\u27e9\r\n  ```\r\n\r\n  Changing the wire order:\r\n\r\n  ```pycon\r\n  >>> print(circuit.draw(wire_order=[\"q2\", \"a\", -1]))\r\n   q2: \u2500\u2500\u256dX\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u27e8X\u27e9\r\n    a: \u2500\u2500\u2570C\u2500\u2500RX(0.2)\u2500\u2500\u2524\r\n   -1: \u2500\u2500\u2500H\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n  ```\r\n\r\n<h3>Breaking changes</h3>\r\n\r\n* QNodes using the new PennyLane core will no longer accept ragged arrays as inputs.\r\n\r\n* When using the new PennyLane core and the Autograd interface, non-differentiable data passed as a QNode argument or a gate must have the `requires_grad` property set to `False`:\r\n\r\n  ```python\r\n  @qml.qnode(dev)\r\n  def circuit(weights, data):\r\n      basis_state = np.array([1, 0, 1, 1], requires_grad=False)\r\n      qml.BasisState(basis_state, wires=[0, 1, 2, 3])\r\n      qml.templates.AmplitudeEmbedding(data, wires=[0, 1, 2, 3])\r\n      qml.templates.BasicEntanglerLayers(weights, wires=[0, 1, 2, 3])\r\n      return qml.probs(wires=0)\r\n\r\n  data = np.array(data, requires_grad=False)\r\n  weights = np.array(weights, requires_grad=True)\r\n  circuit(weights, data)\r\n  ```\r\n\r\n<h3>Bug fixes</h3>\r\n\r\n* Fixes an issue where if the constituent observables of a tensor product do not exist in the queue, an error is raised. With this fix, they are first queued before annotation occurs. [(#1038)](https://github.com/PennyLaneAI/pennylane/pull/1038)\r\n\r\n* Fixes an issue with tape expansions where information about sampling (specifically the `is_sampled` tape attribute) was not preserved. [(#1027)](https://github.com/PennyLaneAI/pennylane/pull/1027)\r\n\r\n* Tape expansion was not properly taking into devices that supported inverse operations, causing inverse operations to be unnecessarily decomposed. The QNode tape expansion logic, as well as the `Operation.expand()` method, has been modified to fix this. [(#956)](https://github.com/PennyLaneAI/pennylane/pull/956)\r\n\r\n* Fixes an issue where the Autograd interface was not unwrapping non-differentiable PennyLane tensors, which can cause issues on some devices. [(#941)](https://github.com/PennyLaneAI/pennylane/pull/941)\r\n\r\n* `qml.vqe.Hamiltonian` prints any observable with any number of strings. [(#987)](https://github.com/PennyLaneAI/pennylane/pull/987)\r\n\r\n* Fixes a bug where parameter-shift differentiation would fail if the QNode contained a single probability output. [(#1007)](https://github.com/PennyLaneAI/pennylane/pull/1007)\r\n\r\n* Fixes an issue when using trainable parameters that are lists/arrays with `tape.vjp`. [(#1042)](https://github.com/PennyLaneAI/pennylane/pull/1042)\r\n\r\n* The `TensorN` observable is updated to support being copied without any parameters or wires passed. [(#1047)](https://github.com/PennyLaneAI/pennylane/pull/1047)\r\n\r\n* Fixed deprecation warning when importing `Sequence` from `collections` instead of `collections.abc` in `vqe/vqe.py`. [(#1051)](https://github.com/PennyLaneAI/pennylane/pull/1051)\r\n\r\n<h3>Contributors</h3>\r\n\r\nThis release contains contributions from (in alphabetical order):\r\n\r\nJuan Miguel Arrazola, Thomas Bromley, Olivia Di Matteo, Theodor Isacsson, Josh Izaac, Christina Lee, Alejandro Montanez, Steven Oud, Chase Roberts, Sankalp Sanand, Maria Schuld, Antal Sz\u00e1va, David Wierichs, Jiahao Yao.\r\n"}
{"url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/35621935", "assets_url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/35621935/assets", "upload_url": "https://uploads.github.com/repos/PennyLaneAI/pennylane/releases/35621935/assets{?name,label}", "html_url": "https://github.com/PennyLaneAI/pennylane/releases/tag/v0.13.0-post2", "id": 35621935, "author": {"login": "josh146", "id": 2959003, "node_id": "MDQ6VXNlcjI5NTkwMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/2959003?v=4", "gravatar_id": "", "url": "https://api.github.com/users/josh146", "html_url": "https://github.com/josh146", "followers_url": "https://api.github.com/users/josh146/followers", "following_url": "https://api.github.com/users/josh146/following{/other_user}", "gists_url": "https://api.github.com/users/josh146/gists{/gist_id}", "starred_url": "https://api.github.com/users/josh146/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/josh146/subscriptions", "organizations_url": "https://api.github.com/users/josh146/orgs", "repos_url": "https://api.github.com/users/josh146/repos", "events_url": "https://api.github.com/users/josh146/events{/privacy}", "received_events_url": "https://api.github.com/users/josh146/received_events", "type": "User", "site_admin": false}, "node_id": "MDc6UmVsZWFzZTM1NjIxOTM1", "tag_name": "v0.13.0-post2", "target_commitish": "v0.13.0-post2-release", "name": "Release 0.13.0-post2", "draft": false, "prerelease": false, "created_at": "2020-12-22T16:09:37Z", "published_at": "2020-12-22T16:10:22Z", "assets": [], "tarball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/tarball/v0.13.0-post2", "zipball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/zipball/v0.13.0-post2", "body": "A minor post-release to update the main page of the PennyLane documentation.\r\n"}
{"url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/35015784", "assets_url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/35015784/assets", "upload_url": "https://uploads.github.com/repos/PennyLaneAI/pennylane/releases/35015784/assets{?name,label}", "html_url": "https://github.com/PennyLaneAI/pennylane/releases/tag/v0.13.0-post1", "id": 35015784, "author": {"login": "josh146", "id": 2959003, "node_id": "MDQ6VXNlcjI5NTkwMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/2959003?v=4", "gravatar_id": "", "url": "https://api.github.com/users/josh146", "html_url": "https://github.com/josh146", "followers_url": "https://api.github.com/users/josh146/followers", "following_url": "https://api.github.com/users/josh146/following{/other_user}", "gists_url": "https://api.github.com/users/josh146/gists{/gist_id}", "starred_url": "https://api.github.com/users/josh146/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/josh146/subscriptions", "organizations_url": "https://api.github.com/users/josh146/orgs", "repos_url": "https://api.github.com/users/josh146/repos", "events_url": "https://api.github.com/users/josh146/events{/privacy}", "received_events_url": "https://api.github.com/users/josh146/received_events", "type": "User", "site_admin": false}, "node_id": "MDc6UmVsZWFzZTM1MDE1Nzg0", "tag_name": "v0.13.0-post1", "target_commitish": "master", "name": "Release 0.13.0-post1", "draft": false, "prerelease": false, "created_at": "2020-12-08T23:45:55Z", "published_at": "2020-12-08T23:55:57Z", "assets": [], "tarball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/tarball/v0.13.0-post1", "zipball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/zipball/v0.13.0-post1", "body": "A minor post-release to update the main page of the PennyLane documentation."}
{"url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/34513678", "assets_url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/34513678/assets", "upload_url": "https://uploads.github.com/repos/PennyLaneAI/pennylane/releases/34513678/assets{?name,label}", "html_url": "https://github.com/PennyLaneAI/pennylane/releases/tag/v0.13.0", "id": 34513678, "author": {"login": "josh146", "id": 2959003, "node_id": "MDQ6VXNlcjI5NTkwMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/2959003?v=4", "gravatar_id": "", "url": "https://api.github.com/users/josh146", "html_url": "https://github.com/josh146", "followers_url": "https://api.github.com/users/josh146/followers", "following_url": "https://api.github.com/users/josh146/following{/other_user}", "gists_url": "https://api.github.com/users/josh146/gists{/gist_id}", "starred_url": "https://api.github.com/users/josh146/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/josh146/subscriptions", "organizations_url": "https://api.github.com/users/josh146/orgs", "repos_url": "https://api.github.com/users/josh146/repos", "events_url": "https://api.github.com/users/josh146/events{/privacy}", "received_events_url": "https://api.github.com/users/josh146/received_events", "type": "User", "site_admin": false}, "node_id": "MDc6UmVsZWFzZTM0NTEzNjc4", "tag_name": "v0.13.0", "target_commitish": "master", "name": "Release 0.13.0", "draft": false, "prerelease": false, "created_at": "2020-11-27T18:11:25Z", "published_at": "2020-11-27T18:18:53Z", "assets": [], "tarball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/tarball/v0.13.0", "zipball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/zipball/v0.13.0", "body": "<h3>New features since last release</h3>\r\n\r\n<h4>Automatically optimize the number of measurements</h4>\r\n\r\n* QNodes in tape mode now support returning observables on the same wire whenever the observables are qubit-wise commuting Pauli words. Qubit-wise commuting observables can be evaluated with a *single* device run as they are diagonal in the same basis, via a shared set of single-qubit rotations. [(#882)](https://github.com/PennyLaneAI/pennylane/pull/882)\r\n\r\n  The following example shows a single QNode returning the expectation values of the qubit-wise commuting Pauli words `XX` and `XI`:\r\n\r\n  ```python\r\n  qml.enable_tape()\r\n\r\n  @qml.qnode(dev)\r\n  def f(x):\r\n      qml.Hadamard(wires=0)\r\n      qml.Hadamard(wires=1)\r\n      qml.CRot(0.1, 0.2, 0.3, wires=[1, 0])\r\n      qml.RZ(x, wires=1)\r\n      return qml.expval(qml.PauliX(0) @ qml.PauliX(1)), qml.expval(qml.PauliX(0))\r\n  ```\r\n\r\n  ```pycon\r\n  >>> f(0.4)\r\n  tensor([0.89431013, 0.9510565 ], requires_grad=True)\r\n  ```\r\n\r\n* The `ExpvalCost` class (previously `VQECost`) now provides observable optimization using the `optimize` argument, resulting in potentially fewer device executions. [(#902)](https://github.com/PennyLaneAI/pennylane/pull/902)\r\n\r\n  This is achieved by separating the observables composing the Hamiltonian into qubit-wise commuting groups and evaluating those groups on a single QNode using functionality from the `qml.grouping` module:\r\n\r\n  ```python\r\n  qml.enable_tape()\r\n  commuting_obs = [qml.PauliX(0), qml.PauliX(0) @ qml.PauliZ(1)]\r\n  H = qml.vqe.Hamiltonian([1, 1], commuting_obs)\r\n\r\n  dev = qml.device(\"default.qubit\", wires=2)\r\n  ansatz = qml.templates.StronglyEntanglingLayers\r\n\r\n  cost_opt = qml.ExpvalCost(ansatz, H, dev, optimize=True)\r\n  cost_no_opt = qml.ExpvalCost(ansatz, H, dev, optimize=False)\r\n\r\n  params = qml.init.strong_ent_layers_uniform(3, 2)\r\n  ```\r\n\r\n  Grouping these commuting observables leads to fewer device executions:\r\n\r\n  ```pycon\r\n  >>> cost_opt(params)\r\n  >>> ex_opt = dev.num_executions\r\n  >>> cost_no_opt(params)\r\n  >>> ex_no_opt = dev.num_executions - ex_opt\r\n  >>> print(\"Number of executions:\", ex_no_opt)\r\n  Number of executions: 2\r\n  >>> print(\"Number of executions (optimized):\", ex_opt)\r\n  Number of executions (optimized): 1\r\n  ```\r\n\r\n<h4>New quantum gradient features</h4>\r\n\r\n* Compute the analytic gradient of quantum circuits in parallel on supported devices. [(#840)](https://github.com/PennyLaneAI/pennylane/pull/840)\r\n\r\n  This release introduces support for batch execution of circuits, via a new device API method `Device.batch_execute()`. Devices that implement this new API support submitting a batch of circuits for *parallel* evaluation simultaneously, which can significantly reduce the computation time.\r\n\r\n  Furthermore, if using tape mode and a compatible device, gradient computations will automatically make use of the new batch API---providing a speedup during optimization.\r\n\r\n* Gradient recipes are now much more powerful, allowing for operations to define their gradient via an arbitrary linear combination of circuit evaluations. [(#909)](https://github.com/PennyLaneAI/pennylane/pull/909) [(#915)](https://github.com/PennyLaneAI/pennylane/pull/915)\r\n\r\n  With this change, gradient recipes can now be of the form `\\frac{\\partial}{\\partial\\phi_k}f(\\phi_k) = \\sum_{i} c_i f(a_i \\phi_k + s_i )`, and are no longer restricted to two-term shifts with identical (but opposite in sign) shift values.\r\n\r\n  As a result, PennyLane now supports native analytic quantum gradients for the controlled rotation operations `CRX`, `CRY`, `CRZ`, and `CRot`. This allows for parameter-shift analytic gradients on hardware, without decomposition.\r\n\r\n  Note that this is a breaking change for developers; please see the *Breaking Changes* section for more details.\r\n\r\n* The `qnn.KerasLayer` class now supports differentiating the QNode through classical backpropagation in tape mode. [(#869)](https://github.com/PennyLaneAI/pennylane/pull/869)\r\n\r\n  ```python\r\n  qml.enable_tape()\r\n\r\n  dev = qml.device(\"default.qubit.tf\", wires=2)\r\n\r\n  @qml.qnode(dev, interface=\"tf\", diff_method=\"backprop\")\r\n  def f(inputs, weights):\r\n      qml.templates.AngleEmbedding(inputs, wires=range(2))\r\n      qml.templates.StronglyEntanglingLayers(weights, wires=range(2))\r\n      return [qml.expval(qml.PauliZ(i)) for i in range(2)]\r\n\r\n  weight_shapes = {\"weights\": (3, 2, 3)}\r\n\r\n  qlayer = qml.qnn.KerasLayer(f, weight_shapes, output_dim=2)\r\n\r\n  inputs = tf.constant(np.random.random((4, 2)), dtype=tf.float32)\r\n\r\n  with tf.GradientTape() as tape:\r\n      out = qlayer(inputs)\r\n\r\n  tape.jacobian(out, qlayer.trainable_weights)\r\n  ```\r\n\r\n<h4>New operations, templates, and measurements</h4>\r\n\r\n* Adds the `qml.density_matrix` QNode return with partial trace capabilities. [(#878)](https://github.com/PennyLaneAI/pennylane/pull/878)\r\n\r\n  The density matrix over the provided wires is returned, with all other subsystems traced out. `qml.density_matrix` currently works for both the `default.qubit` and `default.mixed` devices.\r\n\r\n  ```python\r\n  qml.enable_tape()\r\n  dev = qml.device(\"default.qubit\", wires=2)\r\n\r\n  def circuit(x):\r\n      qml.PauliY(wires=0)\r\n      qml.Hadamard(wires=1)\r\n      return qml.density_matrix(wires=[1])  # wire 0 is traced out\r\n  ```\r\n\r\n* Adds the square-root X gate `SX`. [(#871)](https://github.com/PennyLaneAI/pennylane/pull/871)\r\n\r\n  ```python\r\n  dev = qml.device(\"default.qubit\", wires=1)\r\n\r\n  @qml.qnode(dev)\r\n  def circuit():\r\n      qml.SX(wires=[0])\r\n      return qml.expval(qml.PauliZ(wires=[0]))\r\n  ```\r\n\r\n* Two new hardware-efficient particle-conserving templates have been implemented to perform VQE-based quantum chemistry simulations. The new templates apply several layers of the particle-conserving entanglers proposed in Figs. 2a and 2b of Barkoutsos *et al*., [arXiv:1805.04340](https://arxiv.org/abs/1805.04340) [(#875)](https://github.com/PennyLaneAI/pennylane/pull/875) [(#876)](https://github.com/PennyLaneAI/pennylane/pull/876)\r\n\r\n<h4>Estimate and track resources</h4>\r\n\r\n* The `QuantumTape` class now contains basic resource estimation functionality. The method `tape.get_resources()` returns a dictionary with a list of the constituent operations and the number of times they appear in the circuit. Similarly, `tape.get_depth()` computes the circuit depth. [(#862)](https://github.com/PennyLaneAI/pennylane/pull/862)\r\n\r\n  ```pycon\r\n  >>> with qml.tape.QuantumTape() as tape:\r\n  ...    qml.Hadamard(wires=0)\r\n  ...    qml.RZ(0.26, wires=1)\r\n  ...    qml.CNOT(wires=[1, 0])\r\n  ...    qml.Rot(1.8, -2.7, 0.2, wires=0)\r\n  ...    qml.Hadamard(wires=1)\r\n  ...    qml.CNOT(wires=[0, 1])\r\n  ...    qml.expval(qml.PauliZ(0) @ qml.PauliZ(1))\r\n  >>> tape.get_resources()\r\n  {'Hadamard': 2, 'RZ': 1, 'CNOT': 2, 'Rot': 1}\r\n  >>> tape.get_depth()\r\n  4\r\n  ```\r\n\r\n* The number of device executions over a QNode's lifetime can now be returned using `num_executions`. [(#853)](https://github.com/PennyLaneAI/pennylane/pull/853)\r\n\r\n  ```pycon\r\n  >>> dev = qml.device(\"default.qubit\", wires=2)\r\n  >>> @qml.qnode(dev)\r\n  ... def circuit(x, y):\r\n  ...    qml.RX(x, wires=[0])\r\n  ...    qml.RY(y, wires=[1])\r\n  ...    qml.CNOT(wires=[0, 1])\r\n  ...    return qml.expval(qml.PauliZ(0) @ qml.PauliX(1))\r\n  >>> for _ in range(10):\r\n  ...    circuit(0.432, 0.12)\r\n  >>> print(dev.num_executions)\r\n  10\r\n  ```\r\n\r\n<h3>Improvements</h3>\r\n\r\n* Support for tape mode has improved across PennyLane. The following features now work in tape mode:\r\n\r\n  - QNode collections [(#863)](https://github.com/PennyLaneAI/pennylane/pull/863)\r\n\r\n  - `qnn.ExpvalCost` [(#863)](https://github.com/PennyLaneAI/pennylane/pull/863) [(#911)](https://github.com/PennyLaneAI/pennylane/pull/911)\r\n\r\n  - `qml.qnn.KerasLayer` [(#869)](https://github.com/PennyLaneAI/pennylane/pull/869)\r\n\r\n  - `qml.qnn.TorchLayer` [(#865)](https://github.com/PennyLaneAI/pennylane/pull/865)\r\n\r\n  - The `qml.qaoa` module [(#905)](https://github.com/PennyLaneAI/pennylane/pull/905)\r\n\r\n* A new function, `qml.refresh_devices()`, has been added, allowing PennyLane to rescan installed PennyLane plugins and refresh the device list. In addition, the `qml.device` loader will attempt to refresh devices if the required plugin device cannot be found. This will result in an improved experience if installing PennyLane and plugins within a running Python session (for example, on Google Colab), and avoid the need to restart the kernel/runtime. [(#907)](https://github.com/PennyLaneAI/pennylane/pull/907)\r\n\r\n* When using `grad_fn = qml.grad(cost)` to compute the gradient of a cost function with the Autograd interface, the value of the intermediate forward pass is now available via the `grad_fn.forward` property [(#914)](https://github.com/PennyLaneAI/pennylane/pull/914):\r\n\r\n  ```python\r\n  def cost_fn(x, y):\r\n      return 2 * np.sin(x[0]) * np.exp(-x[1]) + x[0] ** 3 + np.cos(y)\r\n\r\n  params = np.array([0.1, 0.5], requires_grad=True)\r\n  data = np.array(0.65, requires_grad=False)\r\n  grad_fn = qml.grad(cost_fn)\r\n\r\n  grad_fn(params, data)  # perform backprop and evaluate the gradient\r\n  grad_fn.forward  # the cost function value\r\n  ```\r\n\r\n* Gradient-based optimizers now have a `step_and_cost` method that returns both the next step as well as the objective (cost) function output. [(#916)](https://github.com/PennyLaneAI/pennylane/pull/916)\r\n\r\n  ```pycon\r\n  >>> opt = qml.GradientDescentOptimizer()\r\n  >>> params, cost = opt.step_and_cost(cost_fn, params)\r\n  ```\r\n\r\n* PennyLane provides a new experimental module `qml.proc` which provides framework-agnostic processing  functions for array and tensor manipulations. [(#886)](https://github.com/PennyLaneAI/pennylane/pull/886)\r\n\r\n  Given the input tensor-like object, the call is dispatched to the corresponding array manipulation framework, allowing for end-to-end differentiation to be preserved.\r\n\r\n  ```pycon\r\n  >>> x = torch.tensor([1., 2.])\r\n  >>> qml.proc.ones_like(x)\r\n  tensor([1, 1])\r\n  >>> y = tf.Variable([[0], [5]])\r\n  >>> qml.proc.ones_like(y, dtype=np.complex128)\r\n  <tf.Tensor: shape=(2, 1), dtype=complex128, numpy=\r\n  array([[1.+0.j],\r\n         [1.+0.j]])>\r\n  ```\r\n\r\n  Note that these functions are experimental, and only a subset of common functionality is supported. Furthermore, the names and behaviour of these functions may differ from similar functions in common frameworks; please refer to the function docstrings for more details.\r\n\r\n* The gradient methods in tape mode now fully separate the quantum and classical processing. Rather than returning the evaluated gradients directly, they now return a tuple containing the required quantum and classical processing steps. [(#840)](https://github.com/PennyLaneAI/pennylane/pull/840)\r\n\r\n  ```python\r\n  def gradient_method(idx, param, **options):\r\n      # generate the quantum tapes that must be computed\r\n      # to determine the quantum gradient\r\n      tapes = quantum_gradient_tapes(self)\r\n\r\n      def processing_fn(results):\r\n          # perform classical processing on the evaluated tapes\r\n          # returning the evaluated quantum gradient\r\n          return classical_processing(results)\r\n\r\n      return tapes, processing_fn\r\n  ```\r\n\r\n  The `JacobianTape.jacobian()` method has been similarly modified to accumulate all gradient quantum tapes and classical processing functions, evaluate all quantum tapes simultaneously, and then apply the post-processing functions to the evaluated tape results.\r\n\r\n* The MultiRZ gate now has a defined generator, allowing it to be used in quantum natural gradient optimization. [(#912)](https://github.com/PennyLaneAI/pennylane/pull/912)\r\n\r\n* The CRot gate now has a `decomposition` method, which breaks the gate down into rotations and CNOT gates. This allows `CRot` to be used on devices that do not natively support it. [(#908)](https://github.com/PennyLaneAI/pennylane/pull/908)\r\n\r\n* The classical processing in the `MottonenStatePreparation` template has been largely rewritten to use dense matrices and tensor manipulations wherever possible. This is in preparation to support differentiation through the template in the future. [(#864)](https://github.com/PennyLaneAI/pennylane/pull/864)\r\n\r\n* Device-based caching has replaced QNode caching. Caching is now accessed by passing a `cache` argument to the device. [(#851)](https://github.com/PennyLaneAI/pennylane/pull/851)\r\n\r\n  The `cache` argument should be an integer specifying the size of the cache. For example, a cache of size 10 is created using:\r\n\r\n  ```pycon\r\n  >>> dev = qml.device(\"default.qubit\", wires=2, cache=10)\r\n  ```\r\n\r\n* The `Operation`, `Tensor`, and `MeasurementProcess` classes now have the `__copy__` special method defined. [(#840)](https://github.com/PennyLaneAI/pennylane/pull/840)\r\n\r\n  This allows us to ensure that, when a shallow copy is performed of an operation, the mutable list storing the operation parameters is *also* shallow copied. Both the old operation and the copied operation will continue to share the same parameter data,\r\n\r\n  ```pycon\r\n  >>> import copy\r\n  >>> op = qml.RX(0.2, wires=0)\r\n  >>> op2 = copy.copy(op)\r\n  >>> op.data[0] is op2.data[0]\r\n  True\r\n  ```\r\n\r\n  however the *list container* is not a reference:\r\n\r\n  ```pycon\r\n  >>> op.data is op2.data\r\n  False\r\n  ```\r\n\r\n  This allows the parameters of the copied operation to be modified, without mutating the parameters of the original operation.\r\n\r\n* The `QuantumTape.copy` method has been tweaked so that [(#840)](https://github.com/PennyLaneAI/pennylane/pull/840):\r\n\r\n  - Optionally, the tape's operations are shallow copied in addition to the tape by passing the `copy_operations=True` boolean flag. This allows the copied tape's parameters to be mutated without affecting the original tape's parameters. (Note: the two tapes will share parameter data *until* one of the tapes has their parameter list modified.)\r\n\r\n  - Copied tapes can be cast to another `QuantumTape` subclass by passing the `tape_cls` keyword argument.\r\n\r\n<h3>Breaking changes</h3>\r\n\r\n* Updated how parameter-shift gradient recipes are defined for operations, allowing for gradient recipes that are specified as an arbitrary number of terms. [(#909)](https://github.com/PennyLaneAI/pennylane/pull/909)\r\n\r\n  Previously, `Operation.grad_recipe` was restricted to two-term parameter-shift formulas. With this change, the gradient recipe now contains elements of the form `[c_i, a_i, s_i]`, resulting in a gradient recipe of `\\frac{\\partial}{\\partial\\phi_k}f(\\phi_k) = \\sum_{i} c_i f(a_i \\phi_k + s_i )`.\r\n\r\n  As this is a breaking change, all custom operations with defined gradient recipes must be updated to continue working with PennyLane 0.13. Note though that if `grad_recipe = None`, the default gradient recipe remains unchanged, and corresponds to the two terms `[c_0, a_0, s_0]=[1/2, 1, \\pi/2]` and `[c_1, a_1, s_1]=[-1/2, 1, -\\pi/2]` for every parameter.\r\n\r\n- The `VQECost` class has been renamed to `ExpvalCost` to reflect its general applicability beyond VQE. Use of `VQECost` is still possible but will result in a deprecation warning. [(#913)](https://github.com/PennyLaneAI/pennylane/pull/913)\r\n\r\n<h3>Bug fixes</h3>\r\n\r\n* The `default.qubit.tf` device is updated to handle TensorFlow objects (e.g., `tf.Variable`) as gate parameters correctly when using the `MultiRZ` and `CRot` operations. [(#921)](https://github.com/PennyLaneAI/pennylane/pull/921)\r\n\r\n* PennyLane tensor objects are now unwrapped in BaseQNode when passed as a keyword argument to the quantum function. [(#903)](https://github.com/PennyLaneAI/pennylane/pull/903) [(#893)](https://github.com/PennyLaneAI/pennylane/pull/893)\r\n\r\n* The new tape mode now prevents multiple observables from being evaluated on the same wire if the observables are not qubit-wise commuting Pauli words. [(#882)](https://github.com/PennyLaneAI/pennylane/pull/882)\r\n\r\n* Fixes a bug in `default.qubit` whereby inverses of common gates were not being applied via efficient gate-specific methods, instead falling back to matrix-vector multiplication. The following gates were affected: `PauliX`, `PauliY`, `PauliZ`, `Hadamard`, `SWAP`, `S`, `T`, `CNOT`, `CZ`. [(#872)](https://github.com/PennyLaneAI/pennylane/pull/872)\r\n\r\n* The `PauliRot` operation now gracefully handles single-qubit Paulis, and all-identity Paulis [(#860)](https://github.com/PennyLaneAI/pennylane/pull/860).\r\n\r\n* Fixes a bug whereby binary Python operators were not properly propagating the `requires_grad` attribute to the output tensor. [(#889)](https://github.com/PennyLaneAI/pennylane/pull/889)\r\n\r\n* Fixes a bug which prevents `TorchLayer` from doing `backward` when CUDA is enabled. [(#899)](https://github.com/PennyLaneAI/pennylane/pull/899)\r\n\r\n* Fixes a bug where multi-threaded execution of `QNodeCollection` sometimes fails because of simultaneous queuing. This is fixed by adding thread locking during queuing. [(#910)](https://github.com/PennyLaneAI/pennylane/pull/918)\r\n\r\n* Fixes a bug in `QuantumTape.set_parameters()`. The previous implementation assumed that the `self.trainable_parms` set would always be iterated over in increasing integer order. However, this is not guaranteed behaviour, and can lead to the incorrect tape parameters being set if this is not the case. [(#923)](https://github.com/PennyLaneAI/pennylane/pull/923)\r\n\r\n* Fixes broken error message if a QNode is instantiated with an unknown exception. [(#930)](https://github.com/PennyLaneAI/pennylane/pull/930)\r\n\r\n<h3>Contributors</h3>\r\n\r\nThis release contains contributions from (in alphabetical order):\r\n\r\nJuan Miguel Arrazola, Thomas Bromley, Christina Lee, Alain Delgado Gran, Olivia Di Matteo, Anthony Hayes, Theodor Isacsson, Josh Izaac, Soran Jahangiri, Nathan Killoran, Shumpei Kobayashi, Romain Moyard, Zeyue Niu, Maria Schuld, Antal Sz\u00e1va.\r\n"}
{"url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/32794584", "assets_url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/32794584/assets", "upload_url": "https://uploads.github.com/repos/PennyLaneAI/pennylane/releases/32794584/assets{?name,label}", "html_url": "https://github.com/PennyLaneAI/pennylane/releases/tag/v0.12.0", "id": 32794584, "author": {"login": "josh146", "id": 2959003, "node_id": "MDQ6VXNlcjI5NTkwMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/2959003?v=4", "gravatar_id": "", "url": "https://api.github.com/users/josh146", "html_url": "https://github.com/josh146", "followers_url": "https://api.github.com/users/josh146/followers", "following_url": "https://api.github.com/users/josh146/following{/other_user}", "gists_url": "https://api.github.com/users/josh146/gists{/gist_id}", "starred_url": "https://api.github.com/users/josh146/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/josh146/subscriptions", "organizations_url": "https://api.github.com/users/josh146/orgs", "repos_url": "https://api.github.com/users/josh146/repos", "events_url": "https://api.github.com/users/josh146/events{/privacy}", "received_events_url": "https://api.github.com/users/josh146/received_events", "type": "User", "site_admin": false}, "node_id": "MDc6UmVsZWFzZTMyNzk0NTg0", "tag_name": "v0.12.0", "target_commitish": "master", "name": "Release 0.12.0", "draft": false, "prerelease": false, "created_at": "2020-10-20T07:34:46Z", "published_at": "2020-10-20T07:40:50Z", "assets": [], "tarball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/tarball/v0.12.0", "zipball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/zipball/v0.12.0", "body": "\r\n<h3>New features since last release</h3>\r\n\r\n<h4>New and improved simulators</h4>\r\n\r\n* PennyLane now supports a new device, `default.mixed`, designed for simulating mixed-state quantum computations. This enables native support for implementing noisy channels in a circuit, which generally map pure states to mixed states. [(#794)](https://github.com/PennyLaneAI/pennylane/pull/794) [(#807)](https://github.com/PennyLaneAI/pennylane/pull/807) [(#819)](https://github.com/PennyLaneAI/pennylane/pull/819)\r\n\r\n  The device can be initialized as\r\n  ```pycon\r\n  >>> dev = qml.device(\"default.mixed\", wires=1)\r\n  ```\r\n\r\n  This allows the construction of QNodes that include non-unitary operations, such as noisy channels:\r\n\r\n  ```pycon\r\n  >>> @qml.qnode(dev)\r\n  ... def circuit(params):\r\n  ...     qml.RX(params[0], wires=0)\r\n  ...     qml.RY(params[1], wires=0)\r\n  ...     qml.AmplitudeDamping(0.5, wires=0)\r\n  ...     return qml.expval(qml.PauliZ(0))\r\n  >>> print(circuit([0.54, 0.12]))\r\n  0.9257702929524184\r\n  >>> print(circuit([0, np.pi]))\r\n  0.0\r\n  ```\r\n\r\n<h4>New tools for optimizing measurements</h4>\r\n\r\n* The new `grouping` module provides functionality for grouping simultaneously measurable Pauli word observables. [(#761)](https://github.com/PennyLaneAI/pennylane/pull/761) [(#850)](https://github.com/PennyLaneAI/pennylane/pull/850) [(#852)](https://github.com/PennyLaneAI/pennylane/pull/852)\r\n\r\n  - The `optimize_measurements` function will take as input a list of Pauli word observables and their corresponding coefficients (if any), and will return the partitioned Pauli terms diagonalized in the measurement basis and the corresponding diagonalizing circuits.\r\n\r\n    ```python\r\n    from pennylane.grouping import optimize_measurements\r\n    h, nr_qubits = qml.qchem.molecular_hamiltonian(\"h2\", \"h2.xyz\")\r\n    rotations, grouped_ops, grouped_coeffs = optimize_measurements(h.ops, h.coeffs, grouping=\"qwc\")\r\n    ```\r\n\r\n    The diagonalizing circuits of `rotations` correspond to the diagonalized Pauli word groupings of `grouped_ops`.\r\n\r\n  - Pauli word partitioning utilities are performed by the `PauliGroupingStrategy` class. An input list of Pauli words can be partitioned into mutually commuting, qubit-wise-commuting, or anticommuting groupings.\r\n\r\n    For example, partitioning Pauli words into anticommutative groupings by the Recursive Largest First (RLF) graph colouring heuristic:\r\n\r\n    ```python\r\n    from pennylane import PauliX, PauliY, PauliZ, Identity\r\n    from pennylane.grouping import group_observables\r\n    pauli_words = [\r\n        Identity('a') @ Identity('b'),\r\n        Identity('a') @ PauliX('b'),\r\n        Identity('a') @ PauliY('b'),\r\n        PauliZ('a') @ PauliX('b'),\r\n        PauliZ('a') @ PauliY('b'),\r\n        PauliZ('a') @ PauliZ('b')\r\n    ]\r\n    groupings = group_observables(pauli_words, grouping_type='anticommuting', method='rlf')\r\n    ```\r\n\r\n  - Various utility functions are included for obtaining and manipulating Pauli words in the binary symplectic vector space representation.\r\n\r\n    For instance, two Pauli words may be converted to their binary vector representation:\r\n\r\n    ```pycon\r\n    >>> from pennylane.grouping import pauli_to_binary\r\n    >>> from pennylane.wires import Wires\r\n    >>> wire_map = {Wires('a'): 0, Wires('b'): 1}\r\n    >>> pauli_vec_1 = pauli_to_binary(qml.PauliX('a') @ qml.PauliY('b'))\r\n    >>> pauli_vec_2 = pauli_to_binary(qml.PauliZ('a') @ qml.PauliZ('b'))\r\n    >>> pauli_vec_1\r\n    [1. 1. 0. 1.]\r\n    >>> pauli_vec_2\r\n    [0. 0. 1. 1.]\r\n    ```\r\n\r\n    Their product up to a phase may be computed by taking the sum of their binary vector representations, and returned in the operator representation.\r\n\r\n    ```pycon\r\n    >>> from pennylane.grouping import binary_to_pauli\r\n    >>> binary_to_pauli((pauli_vec_1 + pauli_vec_2) % 2, wire_map)\r\n    Tensor product ['PauliY', 'PauliX']: 0 params, wires ['a', 'b']\r\n    ```\r\n\r\n    For more details on the grouping module, see the [grouping module documentation](https://pennylane.readthedocs.io/en/stable/code/qml_grouping.html)\r\n\r\n\r\n<h4>Returning the quantum state from simulators</h4>\r\n\r\n* The quantum state of a QNode can now be returned using the `qml.state()` return function. [(#818)](https://github.com/XanaduAI/pennylane/pull/818)\r\n\r\n  ```python\r\n  import pennylane as qml\r\n\r\n  dev = qml.device(\"default.qubit\", wires=3)\r\n  qml.enable_tape()\r\n\r\n  @qml.qnode(dev)\r\n  def qfunc(x, y):\r\n      qml.RZ(x, wires=0)\r\n      qml.CNOT(wires=[0, 1])\r\n      qml.RY(y, wires=1)\r\n      qml.CNOT(wires=[0, 2])\r\n      return qml.state()\r\n\r\n  >>> qfunc(0.56, 0.1)\r\n  array([0.95985437-0.27601028j, 0.        +0.j        ,\r\n         0.04803275-0.01381203j, 0.        +0.j        ,\r\n         0.        +0.j        , 0.        +0.j        ,\r\n         0.        +0.j        , 0.        +0.j        ])\r\n  ```\r\n\r\n  Differentiating the state is currently available when using the classical backpropagation differentiation method (`diff_method=\"backprop\"`) with a compatible device, and when using the new tape mode.\r\n\r\n<h4>New operations and channels</h4>\r\n\r\n* PennyLane now includes standard channels such as the Amplitude-damping, Phase-damping, and Depolarizing channels, as well as the ability to make custom qubit channels. [(#760)](https://github.com/PennyLaneAI/pennylane/pull/760) [(#766)](https://github.com/PennyLaneAI/pennylane/pull/766) [(#778)](https://github.com/PennyLaneAI/pennylane/pull/778)\r\n\r\n* The controlled-Y operation is now available via `qml.CY`. For devices that do not natively support the controlled-Y operation, it will be decomposed into `qml.RY`, `qml.CNOT`, and `qml.S` operations. [(#806)](https://github.com/PennyLaneAI/pennylane/pull/806)\r\n\r\n<h4>Preview the next-generation PennyLane QNode</h4>\r\n\r\n* The new PennyLane `tape` module provides a re-formulated QNode class, rewritten from the ground-up, that uses a new `QuantumTape` object to represent the QNode's quantum circuit. Tape mode provides several advantages over the standard PennyLane QNode. [(#785)](https://github.com/PennyLaneAI/pennylane/pull/785) [(#792)](https://github.com/PennyLaneAI/pennylane/pull/792) [(#796)](https://github.com/PennyLaneAI/pennylane/pull/796) [(#800)](https://github.com/PennyLaneAI/pennylane/pull/800) [(#803)](https://github.com/PennyLaneAI/pennylane/pull/803) [(#804)](https://github.com/PennyLaneAI/pennylane/pull/804) [(#805)](https://github.com/PennyLaneAI/pennylane/pull/805) [(#808)](https://github.com/PennyLaneAI/pennylane/pull/808) [(#810)](https://github.com/PennyLaneAI/pennylane/pull/810) [(#811)](https://github.com/PennyLaneAI/pennylane/pull/811) [(#815)](https://github.com/PennyLaneAI/pennylane/pull/815) [(#820)](https://github.com/PennyLaneAI/pennylane/pull/820) [(#823)](https://github.com/PennyLaneAI/pennylane/pull/823) [(#824)](https://github.com/PennyLaneAI/pennylane/pull/824) [(#829)](https://github.com/PennyLaneAI/pennylane/pull/829)\r\n\r\n  - Support for in-QNode classical processing: Tape mode allows for differentiable classical processing within the QNode.\r\n\r\n  - No more Variable wrapping: In tape mode, QNode arguments no longer become `Variable` objects within the QNode.\r\n\r\n  - Less restrictive QNode signatures: There is no longer any restriction on the QNode signature; the QNode can be defined and called following the same rules as standard Python functions.\r\n\r\n  - Unifying all QNodes: The tape-mode QNode merges all QNodes (including the `JacobianQNode` and the `PassthruQNode`) into a single unified QNode, with identical behaviour regardless of the differentiation type.\r\n\r\n  - Optimizations: Tape mode provides various performance optimizations, reducing pre- and post-processing overhead, and reduces the number of quantum evaluations in certain cases.\r\n\r\n  Note that tape mode is **experimental**, and does not currently have feature-parity with the existing QNode. [Feedback and bug reports](https://github.com/PennyLaneAI/pennylane/issues) are encouraged and will help improve the new tape mode.\r\n\r\n  Tape mode can be enabled globally via the `qml.enable_tape` function, without changing your PennyLane code:\r\n\r\n  ```python\r\n  qml.enable_tape()\r\n  dev = qml.device(\"default.qubit\", wires=1)\r\n\r\n  @qml.qnode(dev, interface=\"tf\")\r\n  def circuit(p):\r\n      print(\"Parameter value:\", p)\r\n      qml.RX(tf.sin(p[0])**2 + p[1], wires=0)\r\n      return qml.expval(qml.PauliZ(0))\r\n  ```\r\n\r\n  For more details, please see the [tape mode documentation](https://pennylane.readthedocs.io/en/stable/code/qml_tape.html).\r\n\r\n<h3>Improvements</h3>\r\n\r\n* QNode caching has been introduced, allowing the QNode to keep track of the results of previous device executions and reuse those results in subsequent calls. Note that QNode caching is only supported in the new and experimental tape-mode. [(#817)](https://github.com/PennyLaneAI/pennylane/pull/817)\r\n\r\n  Caching is available by passing a `caching` argument to the QNode:\r\n\r\n  ```python\r\n  dev = qml.device(\"default.qubit\", wires=2)\r\n  qml.enable_tape()\r\n\r\n  @qml.qnode(dev, caching=10)  # cache up to 10 evaluations\r\n  def qfunc(x):\r\n      qml.RX(x, wires=0)\r\n      qml.RX(0.3, wires=1)\r\n      qml.CNOT(wires=[0, 1])\r\n      return qml.expval(qml.PauliZ(1))\r\n\r\n  qfunc(0.1)  # first evaluation executes on the device\r\n  qfunc(0.1)  # second evaluation accesses the cached result\r\n  ```\r\n\r\n* Sped up the application of certain gates in `default.qubit` by using array/tensor manipulation tricks. The following gates are affected: `PauliX`, `PauliY`, `PauliZ`, `Hadamard`, `SWAP`, `S`, `T`, `CNOT`, `CZ`. [(#772)](https://github.com/PennyLaneAI/pennylane/pull/772)\r\n\r\n* The computation of marginal probabilities has been made more efficient for devices with a large number of wires, achieving in some cases a 5x speedup. [(#799)](https://github.com/PennyLaneAI/pennylane/pull/799)\r\n\r\n* Adds arithmetic operations (addition, tensor product, subtraction, and scalar multiplication) between `Hamiltonian`, `Tensor`, and `Observable` objects, and inline arithmetic operations between Hamiltonians and other observables. [(#765)](https://github.com/PennyLaneAI/pennylane/pull/765)\r\n\r\n  Hamiltonians can now easily be defined as sums of observables:\r\n\r\n  ```pycon3\r\n  >>> H = 3 * qml.PauliZ(0) - (qml.PauliX(0) @ qml.PauliX(1)) + qml.Hamiltonian([4], [qml.PauliZ(0)])\r\n  >>> print(H)\r\n  (7.0) [Z0] + (-1.0) [X0 X1]\r\n  ```\r\n\r\n* Adds `compare()` method to `Observable` and `Hamiltonian` classes, which allows for comparison between observable quantities. [(#765)](https://github.com/PennyLaneAI/pennylane/pull/765)\r\n\r\n  ```pycon3\r\n  >>> H = qml.Hamiltonian([1], [qml.PauliZ(0)])\r\n  >>> obs = qml.PauliZ(0) @ qml.Identity(1)\r\n  >>> print(H.compare(obs))\r\n  True\r\n  ```\r\n\r\n  ```pycon3\r\n  >>> H = qml.Hamiltonian([2], [qml.PauliZ(0)])\r\n  >>> obs = qml.PauliZ(1) @ qml.Identity(0)\r\n  >>> print(H.compare(obs))\r\n  False\r\n  ```\r\n\r\n* Adds `simplify()` method to the `Hamiltonian` class. [(#765)](https://github.com/PennyLaneAI/pennylane/pull/765)\r\n\r\n  ```pycon3\r\n  >>> H = qml.Hamiltonian([1, 2], [qml.PauliZ(0), qml.PauliZ(0) @ qml.Identity(1)])\r\n  >>> H.simplify()\r\n  >>> print(H)\r\n  (3.0) [Z0]\r\n  ```\r\n\r\n* Added a new bit-flip mixer to the `qml.qaoa` module. [(#774)](https://github.com/PennyLaneAI/pennylane/pull/774)\r\n\r\n* Summation of two `Wires` objects is now supported and will return a `Wires` object containing the set of all wires defined by the terms in the summation. [(#812)](https://github.com/PennyLaneAI/pennylane/pull/812)\r\n\r\n<h3>Breaking changes</h3>\r\n\r\n* The PennyLane NumPy module now returns scalar (zero-dimensional) arrays where Python scalars were previously returned. [(#820)](https://github.com/PennyLaneAI/pennylane/pull/820) [(#833)](https://github.com/PennyLaneAI/pennylane/pull/833)\r\n\r\n  For example, this affects array element indexing, and summation:\r\n\r\n  ```pycon\r\n  >>> x = np.array([1, 2, 3], requires_grad=False)\r\n  >>> x[0]\r\n  tensor(1, requires_grad=False)\r\n  >>> np.sum(x)\r\n  tensor(6, requires_grad=True)\r\n  ```\r\n\r\n  This may require small updates to user code. A convenience method, `np.tensor.unwrap()`, has been added to help ease the transition. This converts PennyLane NumPy tensors to standard NumPy arrays and Python scalars:\r\n\r\n  ```pycon\r\n  >>> x = np.array(1.543, requires_grad=False)\r\n  >>> x.unwrap()\r\n  1.543\r\n  ```\r\n\r\n  Note, however, that information regarding array differentiability will be lost.\r\n\r\n* The device capabilities dictionary has been redesigned, for clarity and robustness. In particular, the capabilities dictionary is now inherited from the parent class, various keys have more expressive names, and all keys are now defined in the base device class. For more details, please [refer to the developer documentation](https://pennylane.readthedocs.io/en/stable/development/plugins.html#device-capabilities). [(#781)](https://github.com/PennyLaneAI/pennylane/pull/781/files)\r\n\r\n<h3>PennyLane-QChem</h3>\r\n\r\n* The functions `one_particle` and `two_particle` have been implemented to extend PennyLane-QChem capabilities to construct observables of many-body quantum systems. These functions can be used in conjunction with the `observable` function to construct electronic structure hamiltonians involving one- and two-particle operators. [(#809)](https://github.com/PennyLaneAI/pennylane/pull/809)\r\n\r\n* The function `observable` in the `obs` module has been generalized to build many-body observables combining one- and two-particle operators (e.g., Hamiltonians) [(#791)](https://github.com/PennyLaneAI/pennylane/pull/791)\r\n\r\n* Fix calculation of the contribution of core orbitals to two-particle operators in the function two_particle. [(#825)](https://github.com/PennyLaneAI/pennylane/pull/825)\r\n\r\n<h3>Bug fixes</h3>\r\n\r\n* Changed to use lists for storing variable values inside `BaseQNode` allowing complex matrices to be passed to `QubitUnitary`. [(#773)](https://github.com/PennyLaneAI/pennylane/pull/773)\r\n\r\n* Fixed a bug within `default.qubit`, resulting in greater efficiency when applying a state vector to all wires on the device. [(#849)](https://github.com/PennyLaneAI/pennylane/pull/849)\r\n\r\n<h3>Documentation</h3>\r\n\r\n* Equations have been added to the `qml.sample` and `qml.probs` docstrings to clarify the mathematical foundation of the performed measurements. [(#843)](https://github.com/PennyLaneAI/pennylane/pull/843)\r\n\r\n<h3>Contributors</h3>\r\n\r\nThis release contains contributions from (in alphabetical order):\r\n\r\nAroosa Ijaz, Juan Miguel Arrazola, Thomas Bromley, Jack Ceroni, Alain Delgado Gran, Josh Izaac, Soran Jahangiri, Nathan Killoran, Robert Lang, Cedric Lin, Olivia Di Matteo, Nicol\u00e1s Quesada, Maria Schuld, Antal Sz\u00e1va."}
{"url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/29797935", "assets_url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/29797935/assets", "upload_url": "https://uploads.github.com/repos/PennyLaneAI/pennylane/releases/29797935/assets{?name,label}", "html_url": "https://github.com/PennyLaneAI/pennylane/releases/tag/v0.11.0", "id": 29797935, "author": {"login": "josh146", "id": 2959003, "node_id": "MDQ6VXNlcjI5NTkwMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/2959003?v=4", "gravatar_id": "", "url": "https://api.github.com/users/josh146", "html_url": "https://github.com/josh146", "followers_url": "https://api.github.com/users/josh146/followers", "following_url": "https://api.github.com/users/josh146/following{/other_user}", "gists_url": "https://api.github.com/users/josh146/gists{/gist_id}", "starred_url": "https://api.github.com/users/josh146/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/josh146/subscriptions", "organizations_url": "https://api.github.com/users/josh146/orgs", "repos_url": "https://api.github.com/users/josh146/repos", "events_url": "https://api.github.com/users/josh146/events{/privacy}", "received_events_url": "https://api.github.com/users/josh146/received_events", "type": "User", "site_admin": false}, "node_id": "MDc6UmVsZWFzZTI5Nzk3OTM1", "tag_name": "v0.11.0", "target_commitish": "master", "name": "Release 0.11.0", "draft": false, "prerelease": false, "created_at": "2020-08-18T04:38:32Z", "published_at": "2020-08-18T05:09:33Z", "assets": [], "tarball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/tarball/v0.11.0", "zipball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/zipball/v0.11.0", "body": "<h3>New features since last release</h3>\r\n\r\n<h4>New and improved simulators</h4>\r\n\r\n* Added a new device, `default.qubit.autograd`, a pure-state qubit simulator written using Autograd. This device supports classical backpropagation (`diff_method=\"backprop\"`); this can be faster than the parameter-shift rule for computing quantum gradients when the number of parameters to be optimized is large. [(#721)](https://github.com/XanaduAI/pennylane/pull/721)\r\n\r\n  ```pycon\r\n  >>> dev = qml.device(\"default.qubit.autograd\", wires=1)\r\n  >>> @qml.qnode(dev, diff_method=\"backprop\")\r\n  ... def circuit(x):\r\n  ...     qml.RX(x[1], wires=0)\r\n  ...     qml.Rot(x[0], x[1], x[2], wires=0)\r\n  ...     return qml.expval(qml.PauliZ(0))\r\n  >>> weights = np.array([0.2, 0.5, 0.1])\r\n  >>> grad_fn = qml.grad(circuit)\r\n  >>> print(grad_fn(weights))\r\n  array([-2.25267173e-01, -1.00864546e+00,  6.93889390e-18])\r\n  ```\r\n\r\n  See the [device documentation](https://pennylane.readthedocs.io/en/stable/code/api/pennylane.devices.default_qubit_autograd.DefaultQubitAutograd.html) for more details.\r\n\r\n* A new experimental C++ state-vector simulator device is now available, `lightning.qubit`. It uses the C++ Eigen library to perform fast linear algebra calculations for simulating quantum state-vector evolution.\r\n\r\n  `lightning.qubit` is currently in beta; it can be installed via `pip`:\r\n\r\n  ```console\r\n  $ pip install pennylane-lightning\r\n  ```\r\n\r\n  Once installed, it can be used as a PennyLane device:\r\n\r\n  ```pycon\r\n  >>> dev = qml.device(\"lightning.qubit\", wires=2)\r\n  ```\r\n\r\n  For more details, please see the [lightning qubit documentation](https://pennylane-lightning.readthedocs.io).\r\n\r\n<h4>New algorithms and templates</h4>\r\n\r\n* Added built-in QAOA functionality via the new `qml.qaoa` module. [(#712)](https://github.com/PennyLaneAI/pennylane/pull/712) [(#718)](https://github.com/PennyLaneAI/pennylane/pull/718) [(#741)](https://github.com/PennyLaneAI/pennylane/pull/741) [(#720)](https://github.com/PennyLaneAI/pennylane/pull/720)\r\n\r\n  This includes the following features:\r\n\r\n  * New `qml.qaoa.x_mixer` and `qml.qaoa.xy_mixer` functions for defining Pauli-X and XY mixer Hamiltonians.\r\n\r\n  * MaxCut: The `qml.qaoa.maxcut` function allows easy construction of the cost Hamiltonian and recommended mixer Hamiltonian for solving the MaxCut problem for a supplied graph.\r\n\r\n  * Layers: `qml.qaoa.cost_layer` and `qml.qaoa.mixer_layer` take cost and mixer Hamiltonians, respectively, and apply the corresponding QAOA cost and mixer layers to the quantum circuit\r\n\r\n  For example, using PennyLane to construct and solve a MaxCut problem with QAOA:\r\n\r\n  ```python\r\n  wires = range(3)\r\n  graph = Graph([(0, 1), (1, 2), (2, 0)])\r\n  cost_h, mixer_h = qaoa.maxcut(graph)\r\n\r\n  def qaoa_layer(gamma, alpha):\r\n      qaoa.cost_layer(gamma, cost_h)\r\n      qaoa.mixer_layer(alpha, mixer_h)\r\n\r\n  def antatz(params, **kwargs):\r\n\r\n      for w in wires:\r\n          qml.Hadamard(wires=w)\r\n\r\n      # repeat the QAOA layer two times\r\n      qml.layer(qaoa_layer, 2, params[0], params[1])\r\n\r\n  dev = qml.device('default.qubit', wires=len(wires))\r\n  cost_function = qml.VQECost(ansatz, cost_h, dev)\r\n  ```\r\n\r\n* Added an `ApproxTimeEvolution` template to the PennyLane templates module, which can be used to implement Trotterized time-evolution under a Hamiltonian. [(#710)](https://github.com/XanaduAI/pennylane/pull/710)\r\n\r\n  <img src=\"https://pennylane.readthedocs.io/en/latest/_static/templates/subroutines/approx_time_evolution.png\" width=50%/>\r\n\r\n* Added a `qml.layer` template-constructing function, which takes a unitary, and repeatedly applies it on a set of wires to a given depth. [(#723)](https://github.com/PennyLaneAI/pennylane/pull/723)\r\n\r\n  ```python\r\n  def subroutine():\r\n      qml.Hadamard(wires=[0])\r\n      qml.CNOT(wires=[0, 1])\r\n      qml.PauliX(wires=[1])\r\n\r\n  dev = qml.device('default.qubit', wires=3)\r\n\r\n  @qml.qnode(dev)\r\n  def circuit():\r\n      qml.layer(subroutine, 3)\r\n      return [qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))]\r\n  ```\r\n\r\n  This creates the following circuit:\r\n  ```pycon\r\n  >>> circuit()\r\n  >>> print(circuit.draw())\r\n  0: \u2500\u2500H\u2500\u2500\u256dC\u2500\u2500X\u2500\u2500H\u2500\u2500\u256dC\u2500\u2500X\u2500\u2500H\u2500\u2500\u256dC\u2500\u2500X\u2500\u2500\u2524 \u27e8Z\u27e9\r\n  1: \u2500\u2500\u2500\u2500\u2500\u2570X\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2570X\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2570X\u2500\u2500\u2500\u2500\u2500\u2524 \u27e8Z\u27e9\r\n  ```\r\n\r\n* Added the `qml.utils.decompose_hamiltonian` function. This function can be used to decompose a Hamiltonian into a linear combination of Pauli operators. [(#671)](https://github.com/XanaduAI/pennylane/pull/671)\r\n\r\n  ```pycon\r\n  >>> A = np.array(\r\n  ... [[-2, -2+1j, -2, -2],\r\n  ... [-2-1j,  0,  0, -1],\r\n  ... [-2,  0, -2, -1],\r\n  ... [-2, -1, -1,  0]])\r\n  >>> coeffs, obs_list = decompose_hamiltonian(A)\r\n  ```\r\n\r\n<h4>New device features</h4>\r\n\r\n* It is now possible to specify custom wire labels, such as `['anc1', 'anc2', 0, 1, 3]`, where the labels can be strings or numbers. [(#666)](https://github.com/XanaduAI/pennylane/pull/666)\r\n\r\n  Custom wire labels are defined by passing a list to the ``wires`` argument when creating the device:\r\n\r\n  ```pycon\r\n  >>> dev = qml.device(\"default.qubit\", wires=['anc1', 'anc2', 0, 1, 3])\r\n  ```\r\n\r\n  Quantum operations should then be invoked with these custom wire labels:\r\n\r\n  ``` pycon\r\n  >>> @qml.qnode(dev)\r\n  >>> def circuit():\r\n  ...    qml.Hadamard(wires='anc2')\r\n  ...    qml.CNOT(wires=['anc1', 3])\r\n  ...    ...\r\n  ```\r\n\r\n  The existing behaviour, in which the number of wires is specified on device initialization, continues to work as usual. This gives a default behaviour where wires are labelled by consecutive integers.\r\n\r\n  ```pycon\r\n  >>> dev = qml.device(\"default.qubit\", wires=5)\r\n  ```\r\n\r\n* An integrated device test suite has been added, which can be used to run basic integration tests on core or external devices. [(#695)](https://github.com/PennyLaneAI/pennylane/pull/695) [(#724)](https://github.com/PennyLaneAI/pennylane/pull/724) [(#733)](https://github.com/PennyLaneAI/pennylane/pull/733)\r\n\r\n  The test can be invoked against a particular device by calling the ``pl-device-test`` command line program:\r\n\r\n  ```console\r\n  $ pl-device-test --device=default.qubit --shots=1234 --analytic=False\r\n  ```\r\n\r\n  If the tests are run on external devices, the device and its dependencies must be installed locally. For more details, please see the [plugin test documentation](http://pennylane.readthedocs.io/en/latest/code/api/pennylane.devices.tests.html).\r\n\r\n<h3>Improvements</h3>\r\n\r\n* Added support for TensorFlow 2.3 and PyTorch 1.6. [(#725)](https://github.com/PennyLaneAI/pennylane/pull/725)\r\n\r\n* Returning probabilities is now supported from photonic QNodes. As with qubit QNodes, photonic QNodes returning probabilities are end-to-end differentiable. [(#699)](https://github.com/XanaduAI/pennylane/pull/699/)\r\n\r\n  ```pycon\r\n  >>> dev = qml.device(\"strawberryfields.fock\", wires=2, cutoff_dim=5)\r\n  >>> @qml.qnode(dev)\r\n  ... def circuit(a):\r\n  ...     qml.Displacement(a, 0, wires=0)\r\n  ...     return qml.probs(wires=0)\r\n  >>> print(circuit(0.5))\r\n  [7.78800783e-01 1.94700196e-01 2.43375245e-02 2.02812704e-03 1.26757940e-04]\r\n  ```\r\n\r\n<h3>Breaking changes</h3>\r\n\r\n* The `pennylane.plugins` and `pennylane.beta.plugins` folders have been renamed to `pennylane.devices` and `pennylane.beta.devices`, to reflect their content better. [(#726)](https://github.com/XanaduAI/pennylane/pull/726)\r\n\r\n<h3>Bug fixes</h3>\r\n\r\n* The PennyLane interface conversion functions can now convert QNodes with pre-existing interfaces. [(#707)](https://github.com/XanaduAI/pennylane/pull/707)\r\n\r\n<h3>Documentation</h3>\r\n\r\n* The interfaces section of the documentation has been renamed to 'Interfaces and training', and updated with the latest variable handling details. [(#753)](https://github.com/PennyLaneAI/pennylane/pull/753)\r\n\r\n<h3>Contributors</h3>\r\n\r\nThis release contains contributions from (in alphabetical order):\r\n\r\nJuan Miguel Arazzola, Thomas Bromley, Jack Ceroni, Alain Delgado Gran, Shadab Hussain, Theodor Isacsson, Josh Izaac, Nathan Killoran, Maria Schuld, Antal Sz\u00e1va, Nicola Vitucci."}
{"url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/27791844", "assets_url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/27791844/assets", "upload_url": "https://uploads.github.com/repos/PennyLaneAI/pennylane/releases/27791844/assets{?name,label}", "html_url": "https://github.com/PennyLaneAI/pennylane/releases/tag/v0.10.0", "id": 27791844, "author": {"login": "josh146", "id": 2959003, "node_id": "MDQ6VXNlcjI5NTkwMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/2959003?v=4", "gravatar_id": "", "url": "https://api.github.com/users/josh146", "html_url": "https://github.com/josh146", "followers_url": "https://api.github.com/users/josh146/followers", "following_url": "https://api.github.com/users/josh146/following{/other_user}", "gists_url": "https://api.github.com/users/josh146/gists{/gist_id}", "starred_url": "https://api.github.com/users/josh146/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/josh146/subscriptions", "organizations_url": "https://api.github.com/users/josh146/orgs", "repos_url": "https://api.github.com/users/josh146/repos", "events_url": "https://api.github.com/users/josh146/events{/privacy}", "received_events_url": "https://api.github.com/users/josh146/received_events", "type": "User", "site_admin": false}, "node_id": "MDc6UmVsZWFzZTI3NzkxODQ0", "tag_name": "v0.10.0", "target_commitish": "master", "name": "Release 0.10.0", "draft": false, "prerelease": false, "created_at": "2020-06-22T15:24:54Z", "published_at": "2020-06-22T15:26:38Z", "assets": [], "tarball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/tarball/v0.10.0", "zipball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/zipball/v0.10.0", "body": "<h3>New features since last release</h3>\r\n\r\n<h4>New and improved simulators</h4>\r\n\r\n* Added a new device, `default.qubit.tf`, a pure-state qubit simulator written using TensorFlow. As a result, it supports classical backpropagation as a means to compute the Jacobian. This can be faster than the parameter-shift rule for computing quantum gradients when the number of parameters to be optimized is large.\r\n\r\n  `default.qubit.tf` is designed to be used with end-to-end classical backpropagation (`diff_method=\"backprop\"`) with the TensorFlow interface. This is the default method of differentiation when creating a QNode with this device.\r\n\r\n  Using this method, the created QNode is a 'white-box' that is tightly integrated with your TensorFlow computation, including [AutoGraph](https://www.tensorflow.org/guide/function) support:\r\n\r\n  ```pycon\r\n  >>> dev = qml.device(\"default.qubit.tf\", wires=1)\r\n  >>> @tf.function\r\n  ... @qml.qnode(dev, interface=\"tf\", diff_method=\"backprop\")\r\n  ... def circuit(x):\r\n  ...     qml.RX(x[1], wires=0)\r\n  ...     qml.Rot(x[0], x[1], x[2], wires=0)\r\n  ...     return qml.expval(qml.PauliZ(0))\r\n  >>> weights = tf.Variable([0.2, 0.5, 0.1])\r\n  >>> with tf.GradientTape() as tape:\r\n  ...     res = circuit(weights)\r\n  >>> print(tape.gradient(res, weights))\r\n  tf.Tensor([-2.2526717e-01 -1.0086454e+00  1.3877788e-17], shape=(3,), dtype=float32)\r\n  ```\r\n\r\n  See the `default.qubit.tf` [documentation](https://pennylane.ai/en/stable/code/api/pennylane.beta.plugins.DefaultQubitTF.html) for more details.\r\n\r\n* The [default.tensor plugin](https://github.com/XanaduAI/pennylane/blob/master/pennylane/beta/plugins/default_tensor.py) has been significantly upgraded. It now allows two different tensor network representations to be used: `\"exact\"` and `\"mps\"`. The former uses a exact factorized representation of quantum states, while the latter uses a matrix product state representation. ([#572](https://github.com/XanaduAI/pennylane/pull/572)) ([#599](https://github.com/XanaduAI/pennylane/pull/599))\r\n\r\n<h4>New machine learning functionality and integrations</h4>\r\n\r\n* PennyLane QNodes can now be converted into Torch layers, allowing for creation of quantum and hybrid models using the `torch.nn` API. [(#588)](https://github.com/XanaduAI/pennylane/pull/588)\r\n\r\n  A PennyLane QNode can be converted into a `torch.nn` layer using the `qml.qnn.TorchLayer` class:\r\n\r\n  ```pycon\r\n  >>> @qml.qnode(dev)\r\n  ... def qnode(inputs, weights_0, weight_1):\r\n  ...    # define the circuit\r\n  ...    # ...\r\n\r\n  >>> weight_shapes = {\"weights_0\": 3, \"weight_1\": 1}\r\n  >>> qlayer = qml.qnn.TorchLayer(qnode, weight_shapes)\r\n  ```\r\n\r\n  A hybrid model can then be easily constructed:\r\n\r\n  ```pycon\r\n  >>> model = torch.nn.Sequential(qlayer, torch.nn.Linear(2, 2))\r\n  ```\r\n\r\n* Added a new \"reversible\" differentiation method which can be used in simulators, but not hardware.\r\n\r\n  The reversible approach is similar to backpropagation, but trades off extra computation for enhanced memory efficiency. Where backpropagation caches the state tensors at each step during a simulated evolution, the reversible method only caches the final pre-measurement state.\r\n\r\n  Compared to the parameter-shift method, the reversible method can be faster or slower, depending on the density and location of parametrized gates in a circuit (circuits with higher density of parametrized gates near the end of the circuit will see a benefit). [(#670)](https://github.com/XanaduAI/pennylane/pull/670)\r\n\r\n  ```pycon\r\n  >>> dev = qml.device(\"default.qubit\", wires=2)\r\n  ... @qml.qnode(dev, diff_method=\"reversible\")\r\n  ... def circuit(x):\r\n  ...     qml.RX(x, wires=0)\r\n  ...     qml.RX(x, wires=0)\r\n  ...     qml.CNOT(wires=[0,1])\r\n  ...     return qml.expval(qml.PauliZ(0))\r\n  >>> qml.grad(circuit)(0.5)\r\n  (array(-0.47942554),)\r\n  ```\r\n\r\n<h4>New templates and cost functions</h4>\r\n\r\n* Added the new templates `UCCSD`, `SingleExcitationUnitary`, and`DoubleExcitationUnitary`, which together implement the Unitary Coupled-Cluster Singles and Doubles (UCCSD) ansatz to perform VQE-based quantum chemistry simulations using PennyLane-QChem. [(#622)](https://github.com/XanaduAI/pennylane/pull/622) [(#638)](https://github.com/XanaduAI/pennylane/pull/638) [(#654)](https://github.com/XanaduAI/pennylane/pull/654) [(#659)](https://github.com/XanaduAI/pennylane/pull/659) [(#622)](https://github.com/XanaduAI/pennylane/pull/622)\r\n\r\n* Added module `pennylane.qnn.cost` with class `SquaredErrorLoss`. The module contains classes to calculate losses and cost functions on circuits with trainable parameters. [(#642)](https://github.com/XanaduAI/pennylane/pull/642)\r\n\r\n<h3>Improvements</h3>\r\n\r\n* A significant improvement with respect to how QNodes and interfaces mark quantum function arguments as differentiable when using Autograd, designed to improve performance and make QNodes more intuitive. [(#648)](https://github.com/XanaduAI/pennylane/pull/648) [(#650)](https://github.com/XanaduAI/pennylane/pull/650)\r\n\r\n  In particular, the following changes have been made:\r\n\r\n  - A new `ndarray` subclass `pennylane.numpy.tensor`, which extends NumPy arrays with the keyword argument and attribute `requires_grad`. Tensors which have `requires_grad=False` are treated as non-differentiable by the Autograd interface.\r\n\r\n  - A new subpackage `pennylane.numpy`, which wraps `autograd.numpy` such that NumPy functions accept the `requires_grad` keyword argument, and allows Autograd to differentiate `pennylane.numpy.tensor` objects.\r\n\r\n  - The `argnum` argument to `qml.grad` is now optional; if not provided, arguments explicitly marked as `requires_grad=False` are excluded for the list of differentiable arguments. The ability to pass `argnum` has been retained for backwards compatibility, and if present the old behaviour persists.\r\n\r\n* The QNode Torch interface now inspects QNode positional arguments. If any argument does not have the attribute `requires_grad=True`, it is automatically excluded from quantum gradient computations. [(#652)](https://github.com/XanaduAI/pennylane/pull/652) [(#660)](https://github.com/XanaduAI/pennylane/pull/660)\r\n\r\n* The QNode TF interface now inspects QNode positional arguments. If any argument is not being watched by a `tf.GradientTape()`, it is automatically excluded from quantum gradient computations. [(#655)](https://github.com/XanaduAI/pennylane/pull/655) [(#660)](https://github.com/XanaduAI/pennylane/pull/660)\r\n\r\n* QNodes have two new public methods: `QNode.set_trainable_args()` and `QNode.get_trainable_args()`. These are designed to be called by interfaces, to specify to the QNode which of its input arguments are differentiable. Arguments which are non-differentiable will not be converted to PennyLane Variable objects within the QNode. [(#660)](https://github.com/XanaduAI/pennylane/pull/660)\r\n\r\n* Added `decomposition` method to PauliX, PauliY, PauliZ, S, T, Hadamard, and PhaseShift gates, which decomposes each of these gates into rotation gates. [(#668)](https://github.com/XanaduAI/pennylane/pull/668)\r\n\r\n* The `CircuitGraph` class now supports serializing contained circuit operations and measurement basis rotations to an OpenQASM2.0 script via the new `CircuitGraph.to_openqasm()` method. [(#623)](https://github.com/XanaduAI/pennylane/pull/623)\r\n\r\n<h3>Breaking changes</h3>\r\n\r\n* Removes support for Python 3.5. [(#639)](https://github.com/XanaduAI/pennylane/pull/639)\r\n\r\n<h3>Documentation</h3>\r\n\r\n* Various small typos were fixed.\r\n\r\n<h3>Contributors</h3>\r\n\r\nThis release contains contributions from (in alphabetical order):\r\n\r\nThomas Bromley, Jack Ceroni, Alain Delgado Gran, Theodor Isacsson, Josh Izaac, Nathan Killoran, Maria Schuld, Antal Sz\u00e1va, Nicola Vitucci."}
{"url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/26540114", "assets_url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/26540114/assets", "upload_url": "https://uploads.github.com/repos/PennyLaneAI/pennylane/releases/26540114/assets{?name,label}", "html_url": "https://github.com/PennyLaneAI/pennylane/releases/tag/v0.9.0", "id": 26540114, "author": {"login": "josh146", "id": 2959003, "node_id": "MDQ6VXNlcjI5NTkwMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/2959003?v=4", "gravatar_id": "", "url": "https://api.github.com/users/josh146", "html_url": "https://github.com/josh146", "followers_url": "https://api.github.com/users/josh146/followers", "following_url": "https://api.github.com/users/josh146/following{/other_user}", "gists_url": "https://api.github.com/users/josh146/gists{/gist_id}", "starred_url": "https://api.github.com/users/josh146/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/josh146/subscriptions", "organizations_url": "https://api.github.com/users/josh146/orgs", "repos_url": "https://api.github.com/users/josh146/repos", "events_url": "https://api.github.com/users/josh146/events{/privacy}", "received_events_url": "https://api.github.com/users/josh146/received_events", "type": "User", "site_admin": false}, "node_id": "MDc6UmVsZWFzZTI2NTQwMTE0", "tag_name": "v0.9.0", "target_commitish": "master", "name": "Release 0.9.0", "draft": false, "prerelease": false, "created_at": "2020-05-15T01:33:42Z", "published_at": "2020-05-15T01:50:38Z", "assets": [], "tarball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/tarball/v0.9.0", "zipball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/zipball/v0.9.0", "body": "<h3>New features since last release</h3>\r\n\r\n<h4>New machine learning integrations</h4>\r\n\r\n* PennyLane QNodes can now be converted into Keras layers, allowing for creation of quantum and hybrid models using the Keras API. [(#529)](https://github.com/XanaduAI/pennylane/pull/529)\r\n\r\n  A PennyLane QNode can be converted into a Keras layer using the `KerasLayer` class:\r\n\r\n  ```python\r\n  from pennylane.qnn import KerasLayer\r\n\r\n  @qml.qnode(dev)\r\n  def circuit(inputs, weights_0, weight_1):\r\n     # define the circuit\r\n     # ...\r\n\r\n  weight_shapes = {\"weights_0\": 3, \"weight_1\": 1}\r\n  qlayer = qml.qnn.KerasLayer(circuit, weight_shapes, output_dim=2)\r\n  ```\r\n\r\n  A hybrid model can then be easily constructed:\r\n\r\n  ```python\r\n  model = tf.keras.models.Sequential([qlayer, tf.keras.layers.Dense(2)])\r\n  ```\r\n\r\n* Added a new type of QNode, `qml.qnodes.PassthruQNode`. For simulators which are coded in an external library which supports automatic differentiation, PennyLane will treat a PassthruQNode as a \"white box\", and rely on the external library to directly provide gradients via backpropagation. This can be more efficient than the using parameter-shift rule for a large number of parameters. [(#488)](https://github.com/XanaduAI/pennylane/pull/488)\r\n\r\n  Currently this behaviour is supported by PennyLane's `default.tensor.tf` device backend, compatible with the `'tf'` interface using TensorFlow 2:\r\n\r\n  ```python\r\n  dev = qml.device('default.tensor.tf', wires=2)\r\n\r\n  @qml.qnode(dev, diff_method=\"backprop\")\r\n  def circuit(params):\r\n      qml.RX(params[0], wires=0)\r\n      qml.RX(params[1], wires=1)\r\n      qml.CNOT(wires=[0, 1])\r\n      return qml.expval(qml.PauliZ(0))\r\n\r\n  qnode = PassthruQNode(circuit, dev)\r\n  params = tf.Variable([0.3, 0.1])\r\n\r\n  with tf.GradientTape() as tape:\r\n      tape.watch(params)\r\n      res = qnode(params)\r\n\r\n  grad = tape.gradient(res, params)\r\n  ```\r\n\r\n<h4>New optimizers</h4>\r\n\r\n* Added the `qml.RotosolveOptimizer`, a gradient-free optimizer that minimizes the quantum function by updating each parameter, one-by-one, via a closed-form expression while keeping other parameters fixed.\r\n  [(#636)](https://github.com/XanaduAI/pennylane/pull/636) [(#539)](https://github.com/XanaduAI/pennylane/pull/539)\r\n\r\n* Added the `qml.RotoselectOptimizer`, which uses Rotosolve to minimizes a quantum function with respect to both the\r\n  rotation operations applied and the rotation parameters. [(#636)](https://github.com/XanaduAI/pennylane/pull/636) [(#539)](https://github.com/XanaduAI/pennylane/pull/539)\r\n\r\n  For example, given a quantum function `f` that accepts parameters `x` and a list of corresponding rotation operations `generators`, the Rotoselect optimizer will, at each step, update both the parameter values and the list of rotation gates to minimize the loss:\r\n\r\n  ```pycon\r\n  >>> opt = qml.optimize.RotoselectOptimizer()\r\n  >>> x = [0.3, 0.7]\r\n  >>> generators = [qml.RX, qml.RY]\r\n  >>> for _ in range(100):\r\n  ...     x, generators = opt.step(f, x, generators)\r\n  ```\r\n\r\n\r\n<h4>New operations</h4>\r\n\r\n* Added the `PauliRot` gate, which performs an arbitrary Pauli rotation on multiple qubits, and the `MultiRZ` gate,\r\n  which performs a rotation generated by a tensor product of Pauli Z operators. [(#559)](https://github.com/XanaduAI/pennylane/pull/559)\r\n\r\n  ```python\r\n  dev = qml.device('default.qubit', wires=4)\r\n\r\n  @qml.qnode(dev)\r\n  def circuit(angle):\r\n      qml.PauliRot(angle, \"IXYZ\", wires=[0, 1, 2, 3])\r\n      return [qml.expval(qml.PauliZ(wire)) for wire in [0, 1, 2, 3]]\r\n  ```\r\n\r\n  ```pycon\r\n  >>> circuit(0.4)\r\n  [1.         0.92106099 0.92106099 1.        ]\r\n  >>> print(circuit.draw())\r\n   0: \u2500\u2500\u256dRI(0.4)\u2500\u2500\u2524 \u27e8Z\u27e9\r\n   1: \u2500\u2500\u251cRX(0.4)\u2500\u2500\u2524 \u27e8Z\u27e9\r\n   2: \u2500\u2500\u251cRY(0.4)\u2500\u2500\u2524 \u27e8Z\u27e9\r\n   3: \u2500\u2500\u2570RZ(0.4)\u2500\u2500\u2524 \u27e8Z\u27e9\r\n  ```\r\n\r\n  If the `PauliRot` gate is not supported on the target device, it will be decomposed into `Hadamard`, `RX` and `MultiRZ` gates. Note that identity gates in the Pauli word result in untouched wires:\r\n\r\n  ```pycon\r\n  >>> print(circuit.draw())\r\n   0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u27e8Z\u27e9\r\n   1: \u2500\u2500H\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256dRZ(0.4)\u2500\u2500H\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u27e8Z\u27e9\r\n   2: \u2500\u2500RX(1.571)\u2500\u2500\u251cRZ(0.4)\u2500\u2500RX(-1.571)\u2500\u2500\u2524 \u27e8Z\u27e9\r\n   3: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2570RZ(0.4)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u27e8Z\u27e9\r\n  ```\r\n\r\n  If the `MultiRZ` gate is not supported, it will be decomposed into\r\n  `CNOT` and `RZ` gates:\r\n\r\n  ```pycon\r\n  >>> print(circuit.draw())\r\n   0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u27e8Z\u27e9\r\n   1: \u2500\u2500H\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256dX\u2500\u2500RZ(0.4)\u2500\u2500\u256dX\u2500\u2500\u2500\u2500\u2500\u2500H\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u27e8Z\u27e9\r\n   2: \u2500\u2500RX(1.571)\u2500\u2500\u256dX\u2500\u2500\u2570C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2570C\u2500\u2500\u256dX\u2500\u2500RX(-1.571)\u2500\u2500\u2524 \u27e8Z\u27e9\r\n   3: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2570C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2570C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u27e8Z\u27e9\r\n  ```\r\n\r\n* PennyLane now provides `DiagonalQubitUnitary` for diagonal gates, that are e.g., encountered in IQP circuits. These kinds of gates can be evaluated much faster on a simulator device. [(#567)](https://github.com/XanaduAI/pennylane/pull/567)\r\n\r\n  The gate can be used, for example, to efficiently simulate oracles:\r\n\r\n  ```python\r\n  dev = qml.device('default.qubit', wires=3)\r\n\r\n  # Function as a bitstring\r\n  f = np.array([1, 0, 0, 1, 1, 0, 1, 0])\r\n\r\n  @qml.qnode(dev)\r\n  def circuit(weights1, weights2):\r\n      qml.templates.StronglyEntanglingLayers(weights1, wires=[0, 1, 2])\r\n\r\n      # Implements the function as a phase-kickback oracle\r\n      qml.DiagonalQubitUnitary((-1)**f, wires=[0, 1, 2])\r\n\r\n      qml.templates.StronglyEntanglingLayers(weights2, wires=[0, 1, 2])\r\n      return [qml.expval(qml.PauliZ(w)) for w in range(3)]\r\n  ```\r\n\r\n* Added the `TensorN` CVObservable that can represent the tensor product of the `NumberOperator` on photonic backends. [(#608)](https://github.com/XanaduAI/pennylane/pull/608)\r\n\r\n<h4>New templates</h4>\r\n\r\n* Added the `ArbitraryUnitary` and `ArbitraryStatePreparation` templates, which use `PauliRot` gates to perform an arbitrary unitary and prepare an arbitrary basis state with the minimal number of parameters. [(#590)](https://github.com/XanaduAI/pennylane/pull/590)\r\n\r\n  ```python\r\n  dev = qml.device('default.qubit', wires=3)\r\n\r\n  @qml.qnode(dev)\r\n  def circuit(weights1, weights2):\r\n        qml.templates.ArbitraryStatePreparation(weights1, wires=[0, 1, 2])\r\n        qml.templates.ArbitraryUnitary(weights2, wires=[0, 1, 2])\r\n        return qml.probs(wires=[0, 1, 2])\r\n  ```\r\n\r\n* Added the `IQPEmbedding` template, which encodes inputs into the diagonal gates of an IQP circuit. [(#605)](https://github.com/XanaduAI/pennylane/pull/605)\r\n\r\n  <img src=\"https://pennylane.readthedocs.io/en/latest/_images/iqp.png\"\r\n  width=50%></img>\r\n\r\n* Added the ``SimplifiedTwoDesign`` template, which implements the circuit design of [Cerezo et al. (2020)](<https://arxiv.org/abs/2001.00550>). [(#556)](https://github.com/XanaduAI/pennylane/pull/556)\r\n\r\n  <img src=\"https://pennylane.readthedocs.io/en/latest/_images/simplified_two_design.png\"\r\n  width=50%></img>\r\n\r\n* Added the ``BasicEntanglerLayers`` template, which is a simple layer architecture of rotations and CNOT nearest-neighbour entanglers. [(#555)](https://github.com/XanaduAI/pennylane/pull/555)\r\n\r\n  <img src=\"https://pennylane.readthedocs.io/en/latest/_images/basic_entangler.png\" width=50%></img>\r\n\r\n* PennyLane now offers a broadcasting function to easily construct templates: `qml.broadcast()` takes single quantum operations or other templates and applies them to wires in a specific pattern. [(#515)](https://github.com/XanaduAI/pennylane/pull/515) [(#522)](https://github.com/XanaduAI/pennylane/pull/522) [(#526)](https://github.com/XanaduAI/pennylane/pull/526) [(#603)](https://github.com/XanaduAI/pennylane/pull/603)\r\n\r\n  For example, we can use broadcast to repeat a custom template across multiple wires:\r\n\r\n  ```python\r\n  from pennylane.templates import template\r\n\r\n  @template\r\n  def mytemplate(pars, wires):\r\n      qml.Hadamard(wires=wires)\r\n      qml.RY(pars, wires=wires)\r\n\r\n  dev = qml.device('default.qubit', wires=3)\r\n\r\n  @qml.qnode(dev)\r\n  def circuit(pars):\r\n      qml.broadcast(mytemplate, pattern=\"single\", wires=[0,1,2], parameters=pars)\r\n      return qml.expval(qml.PauliZ(0))\r\n  ```\r\n\r\n  ```pycon\r\n  >>> circuit([1, 1, 0.1])\r\n  -0.841470984807896\r\n  >>> print(circuit.draw())\r\n   0: \u2500\u2500H\u2500\u2500RY(1.0)\u2500\u2500\u2524 \u27e8Z\u27e9\r\n   1: \u2500\u2500H\u2500\u2500RY(1.0)\u2500\u2500\u2524\r\n   2: \u2500\u2500H\u2500\u2500RY(0.1)\u2500\u2500\u2524\r\n  ```\r\n\r\n  For other available patterns, see the [broadcast function documentation](https://pennylane.readthedocs.io/en/latest/code/api/pennylane.broadcast.html).\r\n\r\n<h3>Breaking changes</h3>\r\n\r\n* The `QAOAEmbedding` now uses the new `MultiRZ` gate as a `ZZ` entangler, which changes the convention. While previously, the `ZZ` gate in the embedding was implemented as\r\n\r\n  ```python\r\n  CNOT(wires=[wires[0], wires[1]])\r\n  RZ(2 * parameter, wires=wires[0])\r\n  CNOT(wires=[wires[0], wires[1]])\r\n  ```\r\n\r\n  the `MultiRZ` corresponds to\r\n\r\n  ```python\r\n  CNOT(wires=[wires[1], wires[0]])\r\n  RZ(parameter, wires=wires[0])\r\n  CNOT(wires=[wires[1], wires[0]])\r\n  ```\r\n\r\n  which differs in the factor of `2`, and fixes a bug in the wires that the `CNOT` was applied to. [(#609)](https://github.com/XanaduAI/pennylane/pull/609)\r\n\r\n* Probability methods are handled by `QubitDevice` and device method requirements are modified to simplify plugin development. [(#573)](https://github.com/XanaduAI/pennylane/pull/573)\r\n\r\n* The internal variables `All` and `Any` to mark an `Operation` as acting on all or any wires have been renamed to `AllWires` and `AnyWires`. [(#614)](https://github.com/XanaduAI/pennylane/pull/614)\r\n\r\n<h3>Improvements</h3>\r\n\r\n* Improvements to the speed/performance of the `default.qubit` device. [(#567)](https://github.com/XanaduAI/pennylane/pull/567) [(#559)](https://github.com/XanaduAI/pennylane/pull/559)\r\n\r\n* Added the `\"backprop\"` and `\"device\"` differentiation methods to the `qnode` decorator. [(#552)](https://github.com/XanaduAI/pennylane/pull/552)\r\n\r\n  - `\"backprop\"`: Use classical backpropagation. Default on simulator devices that are classically end-to-end differentiable.\r\n    The returned QNode can only be used with the same machine learning framework (e.g., ``default.tensor.tf`` simulator with the ``tensorflow`` interface).\r\n\r\n  - `\"device\"`: Queries the device directly for the gradient.\r\n\r\n  Using the `\"backprop\"` differentiation method with the `default.tensor.tf` device, the created QNode is a 'white-box', and is tightly integrated with the overall TensorFlow computation:\r\n\r\n  ```python\r\n  >>> dev = qml.device(\"default.tensor.tf\", wires=1)\r\n  >>> @qml.qnode(dev, interface=\"tf\", diff_method=\"backprop\")\r\n  >>> def circuit(x):\r\n  ...     qml.RX(x[1], wires=0)\r\n  ...     qml.Rot(x[0], x[1], x[2], wires=0)\r\n  ...     return qml.expval(qml.PauliZ(0))\r\n  >>> vars = tf.Variable([0.2, 0.5, 0.1])\r\n  >>> with tf.GradientTape() as tape:\r\n  ...     res = circuit(vars)\r\n  >>> tape.gradient(res, vars)\r\n  <tf.Tensor: shape=(3,), dtype=float32, numpy=array([-2.2526717e-01, -1.0086454e+00,  1.3877788e-17], dtype=float32)>\r\n  ```\r\n\r\n* The circuit drawer now displays inverted operations, as well as wires where probabilities are returned from the device: [(#540)](https://github.com/XanaduAI/pennylane/pull/540)\r\n\r\n  ```python\r\n  >>> @qml.qnode(dev)\r\n  ... def circuit(theta):\r\n  ...     qml.RX(theta, wires=0)\r\n  ...     qml.CNOT(wires=[0, 1])\r\n  ...     qml.S(wires=1).inv()\r\n  ...     return qml.probs(wires=[0, 1])\r\n  >>> circuit(0.2)\r\n  array([0.99003329, 0.        , 0.        , 0.00996671])\r\n  >>> print(circuit.draw())\r\n  0: \u2500\u2500RX(0.2)\u2500\u2500\u256dC\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256d\u2524 Probs\r\n  1: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2570X\u2500\u2500S\u207b\u00b9\u2500\u2500\u2570\u2524 Probs\r\n  ```\r\n\r\n* You can now evaluate the metric tensor of a VQE Hamiltonian via the new `VQECost.metric_tensor` method. This allows `VQECost` objects to be directly optimized by the quantum natural gradient optimizer (`qml.QNGOptimizer`). [(#618)](https://github.com/XanaduAI/pennylane/pull/618)\r\n\r\n* The input check functions in `pennylane.templates.utils` are now public and visible in the API documentation. [(#566)](https://github.com/XanaduAI/pennylane/pull/566)\r\n\r\n* Added keyword arguments for step size and order to the `qnode` decorator, as well as the `QNode` and `JacobianQNode` classes. This enables the user to set the step size and order when using finite difference methods. These options are also exposed when creating QNode collections. [(#530)](https://github.com/XanaduAI/pennylane/pull/530) [(#585)](https://github.com/XanaduAI/pennylane/pull/585) [(#587)](https://github.com/XanaduAI/pennylane/pull/587)\r\n\r\n* The decomposition for the `CRY` gate now uses the simpler form `RY @ CNOT @ RY @ CNOT` [(#547)](https://github.com/XanaduAI/pennylane/pull/547)\r\n\r\n* The underlying queuing system was refactored, removing the `qml._current_context` property that held the currently active `QNode` or `OperationRecorder`. Now, all objects that expose a queue for operations inherit from `QueuingContext` and\r\n  register their queue globally. [(#548)](https://github.com/XanaduAI/pennylane/pull/548)\r\n\r\n* The PennyLane repository has a new benchmarking tool which supports the comparison of different git revisions. [(#568)](https://github.com/XanaduAI/pennylane/pull/568) [(#560)](https://github.com/XanaduAI/pennylane/pull/560) [(#516)](https://github.com/XanaduAI/pennylane/pull/516)\r\n\r\n<h3>Documentation</h3>\r\n\r\n* Updated the development section by creating a landing page with links to sub-pages containing specific guides. [(#596)](https://github.com/XanaduAI/pennylane/pull/596)\r\n\r\n* Extended the developer's guide by a section explaining how to add new templates. [(#564)](https://github.com/XanaduAI/pennylane/pull/564)\r\n\r\n<h3>Bug fixes</h3>\r\n\r\n* `tf.GradientTape().jacobian()` can now be evaluated on QNodes using the TensorFlow interface. [(#626)](https://github.com/XanaduAI/pennylane/pull/626)\r\n\r\n* `RandomLayers()` is now compatible with the qiskit devices. [(#597)](https://github.com/XanaduAI/pennylane/pull/597)\r\n\r\n* `DefaultQubit.probability()` now returns the correct probability when called with `device.analytic=False`. [(#563)](https://github.com/XanaduAI/pennylane/pull/563)\r\n\r\n* Fixed a bug in the `StronglyEntanglingLayers` template, allowing it to work correctly when applied to a single wire. [(544)](https://github.com/XanaduAI/pennylane/pull/544)\r\n\r\n* Fixed a bug when inverting operations with decompositions; operations marked as inverted are now correctly inverted when the fallback decomposition is called. [(#543)](https://github.com/XanaduAI/pennylane/pull/543)\r\n\r\n* The `QNode.print_applied()` method now correctly displays wires where `qml.prob()` is being returned. [#542](https://github.com/XanaduAI/pennylane/pull/542)\r\n\r\n<h3>Contributors</h3>\r\n\r\nThis release contains contributions from (in alphabetical order):\r\n\r\nVille Bergholm, Lana Bozanic, Thomas Bromley, Theodor Isacsson, Josh Izaac, Nathan Killoran, Maggie Li, Johannes Jakob Meyer, Maria Schuld, Sukin Sim, Antal Sz\u00e1va."}
{"url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/24072774", "assets_url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/24072774/assets", "upload_url": "https://uploads.github.com/repos/PennyLaneAI/pennylane/releases/24072774/assets{?name,label}", "html_url": "https://github.com/PennyLaneAI/pennylane/releases/tag/v0.8.1", "id": 24072774, "author": {"login": "josh146", "id": 2959003, "node_id": "MDQ6VXNlcjI5NTkwMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/2959003?v=4", "gravatar_id": "", "url": "https://api.github.com/users/josh146", "html_url": "https://github.com/josh146", "followers_url": "https://api.github.com/users/josh146/followers", "following_url": "https://api.github.com/users/josh146/following{/other_user}", "gists_url": "https://api.github.com/users/josh146/gists{/gist_id}", "starred_url": "https://api.github.com/users/josh146/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/josh146/subscriptions", "organizations_url": "https://api.github.com/users/josh146/orgs", "repos_url": "https://api.github.com/users/josh146/repos", "events_url": "https://api.github.com/users/josh146/events{/privacy}", "received_events_url": "https://api.github.com/users/josh146/received_events", "type": "User", "site_admin": false}, "node_id": "MDc6UmVsZWFzZTI0MDcyNzc0", "tag_name": "v0.8.1", "target_commitish": "master", "name": "Release 0.8.1", "draft": false, "prerelease": false, "created_at": "2020-02-28T12:21:40Z", "published_at": "2020-02-28T12:32:17Z", "assets": [], "tarball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/tarball/v0.8.1", "zipball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/zipball/v0.8.1", "body": "### Improvements\r\n\r\n* Beginning of support for Python 3.8, with the test suite now being run in a Python 3.8 environment. [(#501)](https://github.com/XanaduAI/pennylane/pull/501)\r\n\r\n### Documentation\r\n\r\n* Present templates as a gallery of thumbnails showing the basic circuit architecture. [(#499)](https://github.com/XanaduAI/pennylane/pull/499)\r\n\r\n### Bug fixes\r\n\r\n* Fixed a bug where multiplying a QNode parameter by 0 caused a divide by zero error when calculating the parameter shift formula. [(#512)](https://github.com/XanaduAI/pennylane/pull/512)\r\n\r\n* Fixed a bug where the shape of differentiable QNode arguments was being cached on the first construction, leading to indexing errors if the QNode was re-evaluated if the argument changed shape. [(#505)](https://github.com/XanaduAI/pennylane/pull/505)\r\n\r\n### Contributors\r\n\r\nThis release contains contributions from (in alphabetical order):\r\n\r\nVille Bergholm, Josh Izaac, Maria Schuld, Antal Sz\u00e1va."}
{"url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/23494966", "assets_url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/23494966/assets", "upload_url": "https://uploads.github.com/repos/PennyLaneAI/pennylane/releases/23494966/assets{?name,label}", "html_url": "https://github.com/PennyLaneAI/pennylane/releases/tag/v0.8.0", "id": 23494966, "author": {"login": "josh146", "id": 2959003, "node_id": "MDQ6VXNlcjI5NTkwMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/2959003?v=4", "gravatar_id": "", "url": "https://api.github.com/users/josh146", "html_url": "https://github.com/josh146", "followers_url": "https://api.github.com/users/josh146/followers", "following_url": "https://api.github.com/users/josh146/following{/other_user}", "gists_url": "https://api.github.com/users/josh146/gists{/gist_id}", "starred_url": "https://api.github.com/users/josh146/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/josh146/subscriptions", "organizations_url": "https://api.github.com/users/josh146/orgs", "repos_url": "https://api.github.com/users/josh146/repos", "events_url": "https://api.github.com/users/josh146/events{/privacy}", "received_events_url": "https://api.github.com/users/josh146/received_events", "type": "User", "site_admin": false}, "node_id": "MDc6UmVsZWFzZTIzNDk0OTY2", "tag_name": "v0.8.0", "target_commitish": "master", "name": "Release 0.8.0", "draft": false, "prerelease": false, "created_at": "2020-02-07T21:46:53Z", "published_at": "2020-02-07T21:54:13Z", "assets": [], "tarball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/tarball/v0.8.0", "zipball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/zipball/v0.8.0", "body": "_See the [release notes](https://pennylane.readthedocs.io/en/stable/development/release_notes.html) on the PennyLane website for code examples and more details._\r\n\r\n### New features since last release\r\n\r\n* Added a quantum chemistry package, `pennylane.qchem`, which supports integration with OpenFermion, Psi4, PySCF, and OpenBabel. Functions and classes for creating and solving VQE\r\n  problems have also been addded. [(#453)](https://github.com/XanaduAI/pennylane/pull/453) [(#467)](https://github.com/XanaduAI/pennylane/pull/467)\r\n\r\n  Features include:\r\n\r\n  - Generate the qubit Hamiltonians directly starting with the atomic structure of the molecule.\r\n  - Calculate the mean-field (Hartree-Fock) electronic structure of molecules.\r\n  - Allow to define an active space based on the number of active electrons and active orbitals.\r\n  - Perform the fermionic-to-qubit transformation of the electronic Hamiltonian by\r\n    using different functions implemented in OpenFermion.\r\n  - Convert OpenFermion's QubitOperator to a Pennylane `Hamiltonian` class.\r\n  - Perform a Variational Quantum Eigensolver (VQE) computation with this Hamiltonian in PennyLane.\r\n  - `qml.Hamiltonian`: a lightweight class for representing qubit Hamiltonians\r\n  - `qml.VQECost`: a class for quickly constructing a differentiable cost function\r\n    given a circuit ansatz, Hamiltonian, and one or more devices\r\n\r\n  Check out the [quantum chemistry quickstart](https://pennylane.readthedocs.io/en/stable/introduction/chemistry.html), as well the quantum chemistry and VQE tutorials.\r\n\r\n* Added a circuit drawing feature that provides a text-based representation of a QNode instance. It can be invoked via `qnode.draw()`. The user can specify to display variable names instead of variable values and choose either an ASCII or Unicode charset. [(#446)](https://github.com/XanaduAI/pennylane/pull/446)\r\n\r\n* Added `QAOAEmbedding` and its parameter initialization as a new trainable template.\r\n  [(#442)](https://github.com/XanaduAI/pennylane/pull/442)\r\n\r\n* Added the `qml.probs()` measurement function, allowing QNodes to differentiate variational circuit probabilities on simulators and hardware. QNodes that return probabilities fully support autodifferentiation. [(#432)](https://github.com/XanaduAI/pennylane/pull/432)\r\n\r\n* Added the convenience load functions `qml.from_pyquil`, `qml.from_quil` and `qml.from_quil_file` that convert pyQuil objects and Quil code to PennyLane templates. This feature requires version 0.8 or above of the PennyLane-Forest plugin. [(#459)](https://github.com/XanaduAI/pennylane/pull/459)\r\n\r\n* Added a `qml.inv` method that inverts templates and sequences of Operations. Added a `@qml.template` decorator that makes templates return the queued Operations. [(#462)](https://github.com/XanaduAI/pennylane/pull/462)\r\n\r\n* Added the `QNodeCollection` container class, that allows independent QNodes to be stored and evaluated simultaneously. Experimental support for asynchronous evaluation of contained QNodes is provided with the `parallel=True` keyword argument. [(#466)](https://github.com/XanaduAI/pennylane/pull/466)\r\n\r\n* Added a high level `qml.map` function, that maps a quantum circuit template over a list of observables or devices, returning a `QNodeCollection`. [(#466)](https://github.com/XanaduAI/pennylane/pull/466)\r\n\r\n* Added high level `qml.sum`, `qml.dot`, `qml.apply` functions that act on QNode collections. `qml.sum` and `qml.dot` take the sum of a QNode collection, and a dot product of tensors/arrays/QNode collections, respectively.[(#466)](https://github.com/XanaduAI/pennylane/pull/466)\r\n\r\n### Breaking changes\r\n\r\n* Deprecated the old-style `QNode` such that only the new-style `QNode` and its syntax can be used, moved all related files from the `pennylane/beta` folder to `pennylane`. [(#440)](https://github.com/XanaduAI/pennylane/pull/440)\r\n\r\n### Improvements\r\n\r\n* Added the `Tensor.prune()` method and the `Tensor.non_identity_obs` property for extracting non-identity instances from the observables making up a `Tensor` instance. [(#498)](https://github.com/XanaduAI/pennylane/pull/498)\r\n\r\n* Renamed the `expt.tensornet` and `expt.tensornet.tf` devices to `default.tensor` and `default.tensor.tf`. [(#495)](https://github.com/XanaduAI/pennylane/pull/495)\r\n\r\n* Added a serialization method to the `CircuitGraph` class that is used to create a unique hash for each quantum circuit graph. [(#470)](https://github.com/XanaduAI/pennylane/pull/470)\r\n\r\n* Added the ``Observable.eigvals`` method to return the eigenvalues of observables. [(#449)](https://github.com/XanaduAI/pennylane/pull/449)\r\n\r\n* Added the `Observable.diagonalizing_gates` method to return the gates that diagonalize an observable in the computational basis. [(#454)](https://github.com/XanaduAI/pennylane/pull/454)\r\n\r\n* Added the `Operator.matrix` method to return the matrix representation of an operator in the computational basis. [(#454)](https://github.com/XanaduAI/pennylane/pull/454)\r\n\r\n* Added a `QubitDevice` class which implements common functionalities of plugin devices such that plugin devices can rely on these implementations. The new `QubitDevice` includes a new `execute` method, which allows for more convenient plugin design. As a result, the way samples are generated on qubit based devices has been unified. [(#461)](https://github.com/XanaduAI/pennylane/pull/461) [(#452)](https://github.com/XanaduAI/pennylane/pull/452) [(#473)](https://github.com/XanaduAI/pennylane/pull/473)\r\n\r\n* Improved documentation of `AmplitudeEmbedding` and `BasisEmbedding` templates. [(#441)](https://github.com/XanaduAI/pennylane/pull/441) [(#439)](https://github.com/XanaduAI/pennylane/pull/439)\r\n\r\n* Codeblocks in the documentation now have a 'copy' button for easily copying examples. [(#437)](https://github.com/XanaduAI/pennylane/pull/437)\r\n\r\n### Documentation\r\n\r\n* Update the developers plugin guide to use QubitDevice. [(#483)](https://github.com/XanaduAI/pennylane/pull/483)\r\n\r\n### Bug fixes\r\n\r\n* Fixed a bug in `CVQNode._pd_analytic`, where non-descendant observables were not Heisenberg-transformed before evaluating the partial derivatives when using the order-2 parameter-shift method, resulting in an erroneous Jacobian for some circuits. [(#433)](https://github.com/XanaduAI/pennylane/pull/433)\r\n\r\n### Contributors\r\n\r\nThis release contains contributions from (in alphabetical order):\r\n\r\nJuan Miguel Arrazola, Ville Bergholm, Alain Delgado Gran, Olivia Di Matteo, Theodor Isacsson, Josh Izaac, Soran Jahangiri, Nathan Killoran, Johannes Jakob Meyer, Zeyue Niu, Maria Schuld, Antal Sz\u00e1va."}
{"url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/21574389", "assets_url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/21574389/assets", "upload_url": "https://uploads.github.com/repos/PennyLaneAI/pennylane/releases/21574389/assets{?name,label}", "html_url": "https://github.com/PennyLaneAI/pennylane/releases/tag/v0.7.0", "id": 21574389, "author": {"login": "josh146", "id": 2959003, "node_id": "MDQ6VXNlcjI5NTkwMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/2959003?v=4", "gravatar_id": "", "url": "https://api.github.com/users/josh146", "html_url": "https://github.com/josh146", "followers_url": "https://api.github.com/users/josh146/followers", "following_url": "https://api.github.com/users/josh146/following{/other_user}", "gists_url": "https://api.github.com/users/josh146/gists{/gist_id}", "starred_url": "https://api.github.com/users/josh146/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/josh146/subscriptions", "organizations_url": "https://api.github.com/users/josh146/orgs", "repos_url": "https://api.github.com/users/josh146/repos", "events_url": "https://api.github.com/users/josh146/events{/privacy}", "received_events_url": "https://api.github.com/users/josh146/received_events", "type": "User", "site_admin": false}, "node_id": "MDc6UmVsZWFzZTIxNTc0Mzg5", "tag_name": "v0.7.0", "target_commitish": "master", "name": "Release 0.7.0", "draft": false, "prerelease": false, "created_at": "2019-11-19T05:31:06Z", "published_at": "2019-11-19T05:50:57Z", "assets": [], "tarball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/tarball/v0.7.0", "zipball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/zipball/v0.7.0", "body": "### New features since last release\r\n\r\n* Custom padding constant in `AmplitudeEmbedding` is supported (see 'Breaking changes'.) [#419](https://github.com/XanaduAI/pennylane/pull/419)\r\n\r\n* `StronglyEntanglingLayer` and `RandomLayer` now work with a single wire.  [#409](https://github.com/XanaduAI/pennylane/pull/409)  [#413](https://github.com/XanaduAI/pennylane/pull/413)\r\n\r\n* Added support for applying the inverse of an `Operation` within a circuit. [#377](https://github.com/XanaduAI/pennylane/pull/377)\r\n\r\n* Added an `OperationRecorder()` context manager, that allows templates  and quantum functions to be executed while recording events. The recorder can be used with and without QNodes as a debugging utility. [#388](https://github.com/XanaduAI/pennylane/pull/388)\r\n\r\n* Operations can now specify a decomposition that is used when the desired operation is not supported on the target device. [#396](https://github.com/XanaduAI/pennylane/pull/396)\r\n\r\n* The ability to load circuits from external frameworks as templates has been added via the new `qml.load()` function. This feature requires plugin support --- this initial release provides support for Qiskit circuits and QASM files when `pennylane-qiskit` is installed, via the functions `qml.from_qiskit` and `qml.from_qasm`. [#418](https://github.com/XanaduAI/pennylane/pull/418)\r\n\r\n* An experimental tensor network device has been added [#416](https://github.com/XanaduAI/pennylane/pull/416) [#395](https://github.com/XanaduAI/pennylane/pull/395) [#394](https://github.com/XanaduAI/pennylane/pull/394) [#380](https://github.com/XanaduAI/pennylane/pull/380)\r\n\r\n* An experimental tensor network device which uses TensorFlow for backpropagation has been added [#427](https://github.com/XanaduAI/pennylane/pull/427)\r\n\r\n* Custom padding constant in `AmplitudeEmbedding` is supported (see 'Breaking changes'.) [#419](https://github.com/XanaduAI/pennylane/pull/419)\r\n\r\n### Breaking changes\r\n\r\n* The ``pad`` parameter in `AmplitudeEmbedding()`` is now either ``None`` (no automatic padding), or a number that is used as the padding constant. [#419](https://github.com/XanaduAI/pennylane/pull/419)\r\n\r\n* Initialization functions now return a single array of weights per function. Utilities for multi-weight templates `Interferometer()` and `CVNeuralNetLayers()` are provided. [#412](https://github.com/XanaduAI/pennylane/pull/412)\r\n\r\n* The single layer templates `RandomLayer()`, `CVNeuralNetLayer()` and `StronglyEntanglingLayer()` have been turned into private functions `_random_layer()`, `_cv_neural_net_layer()` and `_strongly_entangling_layer()`. Recommended use is now via the corresponding `Layers()` templates. [#413](https://github.com/XanaduAI/pennylane/pull/413)\r\n\r\n### Improvements\r\n\r\n* Added extensive input checks in templates. [#419](https://github.com/XanaduAI/pennylane/pull/419)\r\n\r\n* Templates integration tests are rewritten - now cover keyword/positional argument passing, interfaces and combinations of templates. [#409](https://github.com/XanaduAI/pennylane/pull/409) [#419](https://github.com/XanaduAI/pennylane/pull/419)\r\n\r\n* State vector preparation operations in the `default.qubit` plugin can now be applied to subsets of wires, and are restricted to being the first operation in a circuit. [#346](https://github.com/XanaduAI/pennylane/pull/346)\r\n\r\n* The `QNode` class is split into a hierarchy of simpler classes. [#354](https://github.com/XanaduAI/pennylane/pull/354) [#398](https://github.com/XanaduAI/pennylane/pull/398) [#415](https://github.com/XanaduAI/pennylane/pull/415) [#417](https://github.com/XanaduAI/pennylane/pull/417) [#425](https://github.com/XanaduAI/pennylane/pull/425)\r\n\r\n* Added the gates U1, U2 and U3 parametrizing arbitrary unitaries on 1, 2 and 3 qubits and the Toffoli gate to the set of qubit operations. [#396](https://github.com/XanaduAI/pennylane/pull/396)\r\n\r\n* Changes have been made to accomodate the movement of the main function in `pytest._internal` to `pytest._internal.main` in pip 19.3. [#404](https://github.com/XanaduAI/pennylane/pull/404)\r\n\r\n* Added the templates `BasisStatePreparation` and `MottonenStatePreparation` that use gates to prepare a basis state and an arbitrary state respectively. [#336](https://github.com/XanaduAI/pennylane/pull/336)\r\n\r\n* Added decompositions for `BasisState` and `QubitStateVector` based on state preparation templates.\r\n  [#414](https://github.com/XanaduAI/pennylane/pull/414)\r\n\r\n* Replaces the pseudo-inverse in the quantum natural gradient optimizer (which can be numerically unstable) with `np.linalg.solve`. [#428](https://github.com/XanaduAI/pennylane/pull/428)\r\n\r\n### Contributors\r\n\r\nThis release contains contributions from (in alphabetical order):\r\n\r\nVille Bergholm, Josh Izaac, Nathan Killoran, Angus Lowe, Johannes Jakob Meyer, Oluwatobi Ogunbayo, Maria Schuld, Antal Sz\u00e1va."}
{"url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/21097711", "assets_url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/21097711/assets", "upload_url": "https://uploads.github.com/repos/PennyLaneAI/pennylane/releases/21097711/assets{?name,label}", "html_url": "https://github.com/PennyLaneAI/pennylane/releases/tag/v0.6.1", "id": 21097711, "author": {"login": "josh146", "id": 2959003, "node_id": "MDQ6VXNlcjI5NTkwMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/2959003?v=4", "gravatar_id": "", "url": "https://api.github.com/users/josh146", "html_url": "https://github.com/josh146", "followers_url": "https://api.github.com/users/josh146/followers", "following_url": "https://api.github.com/users/josh146/following{/other_user}", "gists_url": "https://api.github.com/users/josh146/gists{/gist_id}", "starred_url": "https://api.github.com/users/josh146/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/josh146/subscriptions", "organizations_url": "https://api.github.com/users/josh146/orgs", "repos_url": "https://api.github.com/users/josh146/repos", "events_url": "https://api.github.com/users/josh146/events{/privacy}", "received_events_url": "https://api.github.com/users/josh146/received_events", "type": "User", "site_admin": false}, "node_id": "MDc6UmVsZWFzZTIxMDk3NzEx", "tag_name": "v0.6.1", "target_commitish": "master", "name": "Release 0.6.1", "draft": false, "prerelease": false, "created_at": "2019-10-30T18:32:50Z", "published_at": "2019-10-30T18:38:39Z", "assets": [], "tarball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/tarball/v0.6.1", "zipball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/zipball/v0.6.1", "body": "### New features since last release\r\n\r\n* Added a `print_applied` method to QNodes, allowing the operation and observable queue to be printed as last constructed. [#378](https://github.com/XanaduAI/pennylane/pull/378)\r\n\r\n### Improvements\r\n\r\n* A new `Operator` base class is introduced, which is inherited by both the `Observable` class and the `Operation` class. [#355](https://github.com/XanaduAI/pennylane/pull/355)\r\n\r\n* Removed deprecated `@abstractproperty` decorators in `_device.py`. [#374](https://github.com/XanaduAI/pennylane/pull/374)\r\n\r\n* Comprehensive gradient tests have been added for the interfaces. [#381](https://github.com/XanaduAI/pennylane/pull/381)\r\n\r\n### Documentation\r\n\r\n* The new restructured documentation has been polished and updated. [#387](https://github.com/XanaduAI/pennylane/pull/387) [#375](https://github.com/XanaduAI/pennylane/pull/375) [#372](https://github.com/XanaduAI/pennylane/pull/372) [#370](https://github.com/XanaduAI/pennylane/pull/370) [#369](https://github.com/XanaduAI/pennylane/pull/369) [#367](https://github.com/XanaduAI/pennylane/pull/367) [#364](https://github.com/XanaduAI/pennylane/pull/364)\r\n\r\n* Updated the development guides. [#382](https://github.com/XanaduAI/pennylane/pull/382) [#379](https://github.com/XanaduAI/pennylane/pull/379)\r\n\r\n* Added all modules, classes, and functions to the API section in the documentation. [#373](https://github.com/XanaduAI/pennylane/pull/373)\r\n\r\n### Bug fixes\r\n\r\n* Replaces the existing `np.linalg.norm` normalization with hand-coded normalization, allowing AmplitudeEmbedding` to be used with differentiable parameters. AmplitudeEmbedding tests have been added and improved. [#376](https://github.com/XanaduAI/pennylane/pull/376)\r\n\r\n### Contributors\r\n\r\nThis release contains contributions from (in alphabetical order):\r\n\r\nJosh Izaac, Nathan Killoran, Maria Schuld, Antal Sz\u00e1va"}
{"url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/20816225", "assets_url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/20816225/assets", "upload_url": "https://uploads.github.com/repos/PennyLaneAI/pennylane/releases/20816225/assets{?name,label}", "html_url": "https://github.com/PennyLaneAI/pennylane/releases/tag/v0.6.0", "id": 20816225, "author": {"login": "josh146", "id": 2959003, "node_id": "MDQ6VXNlcjI5NTkwMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/2959003?v=4", "gravatar_id": "", "url": "https://api.github.com/users/josh146", "html_url": "https://github.com/josh146", "followers_url": "https://api.github.com/users/josh146/followers", "following_url": "https://api.github.com/users/josh146/following{/other_user}", "gists_url": "https://api.github.com/users/josh146/gists{/gist_id}", "starred_url": "https://api.github.com/users/josh146/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/josh146/subscriptions", "organizations_url": "https://api.github.com/users/josh146/orgs", "repos_url": "https://api.github.com/users/josh146/repos", "events_url": "https://api.github.com/users/josh146/events{/privacy}", "received_events_url": "https://api.github.com/users/josh146/received_events", "type": "User", "site_admin": false}, "node_id": "MDc6UmVsZWFzZTIwODE2MjI1", "tag_name": "v0.6.0", "target_commitish": "master", "name": "Release 0.6", "draft": false, "prerelease": false, "created_at": "2019-10-18T19:56:55Z", "published_at": "2019-10-18T20:00:20Z", "assets": [], "tarball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/tarball/v0.6.0", "zipball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/zipball/v0.6.0", "body": "### New features since last release\r\n\r\n* The devices `default.qubit` and `default.gaussian` have a new initialization parameter `analytic` that indicates if expectation values and variances should be calculated analytically and not be estimated from data. [#317](https://github.com/XanaduAI/pennylane/pull/317)\r\n\r\n* Added C-SWAP gate to the set of qubit operations [#330](https://github.com/XanaduAI/pennylane/pull/330)\r\n\r\n* The TensorFlow interface has been renamed from `\"tfe\"` to `\"tf\"`, and now supports TensorFlow 2.0. [#337](https://github.com/XanaduAI/pennylane/pull/337)\r\n\r\n* Added the S and T gates to the set of qubit operations. [#343](https://github.com/XanaduAI/pennylane/pull/343)\r\n\r\n* Tensor observables are now supported within the `expval`, `var`, and `sample` functions, by using the `@` operator. [#267](https://github.com/XanaduAI/pennylane/pull/267)\r\n\r\n### Breaking changes\r\n\r\n* The argument `n` specifying the number of samples in the method `Device.sample` was removed. Instead, the method will always return `Device.shots` many samples. [#317](https://github.com/XanaduAI/pennylane/pull/317)\r\n\r\n### Improvements\r\n\r\n* The number of shots / random samples used to estimate expectation values and variances, `Device.shots`, can now be changed after device creation. [#317](https://github.com/XanaduAI/pennylane/pull/317)\r\n\r\n* Unified import shortcuts to be under qml in qnode.py and test_operation.py [#329](https://github.com/XanaduAI/pennylane/pull/329)\r\n\r\n* The quantum natural gradient now uses `scipy.linalg.pinvh` which is more efficient for symmetric matrices than the previously used `scipy.linalg.pinv`. [#331](https://github.com/XanaduAI/pennylane/pull/331)\r\n\r\n* The deprecated `qml.expval.Observable` syntax has been removed. [#267](https://github.com/XanaduAI/pennylane/pull/267)\r\n\r\n* Remainder of the unittest-style tests were ported to pytest. [#310](https://github.com/XanaduAI/pennylane/pull/310)\r\n\r\n* The `do_queue` argument for operations now only takes effect within QNodes. Outside of QNodes, operations can now be instantiated without needing to specify `do_queue`. [#359](https://github.com/XanaduAI/pennylane/pull/359)\r\n\r\n### Documentation\r\n\r\n* The docs are rewritten and restructured to contain a code introduction section as well as an API section. [#314](https://github.com/XanaduAI/pennylane/pull/275)\r\n\r\n* Added Ising model example to the tutorials [#319] (https://github.com/XanaduAI/pennylane/pull/319)\r\n\r\n* Added tutorial for QAOA on MaxCut problem [#328](https://github.com/XanaduAI/pennylane/pull/328)\r\n\r\n* Added QGAN flow chart figure to its tutorial [#333](https://github.com/XanaduAI/pennylane/pull/333)\r\n\r\n* Added missing figures for gallery thumbnails of state-preparation and QGAN tutorials [#326](https://github.com/XanaduAI/pennylane/pull/326)\r\n\r\n* Fixed typos in the state preparation tutorial [#321](https://github.com/XanaduAI/pennylane/pull/321)\r\n\r\n* Fixed bug in VQE tutorial 3D plots [#327](https://github.com/XanaduAI/pennylane/pull/327)\r\n\r\n### Bug fixes\r\n\r\n* Fixed typo in measurement type error message in qnode.py [#341](https://github.com/XanaduAI/pennylane/pull/341)\r\n\r\n### Contributors\r\n\r\nThis release contains contributions from (in alphabetical order):\r\n\r\nShahnawaz Ahmed, Ville Bergholm, Aroosa Ijaz, Josh Izaac, Nathan Killoran, Angus Lowe, Johannes Jakob Meyer, Maria Schuld, Antal Sz\u00e1va, Roeland Wiersema.\r\n"}
{"url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/19865695", "assets_url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/19865695/assets", "upload_url": "https://uploads.github.com/repos/PennyLaneAI/pennylane/releases/19865695/assets{?name,label}", "html_url": "https://github.com/PennyLaneAI/pennylane/releases/tag/v0.5.0", "id": 19865695, "author": {"login": "josh146", "id": 2959003, "node_id": "MDQ6VXNlcjI5NTkwMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/2959003?v=4", "gravatar_id": "", "url": "https://api.github.com/users/josh146", "html_url": "https://github.com/josh146", "followers_url": "https://api.github.com/users/josh146/followers", "following_url": "https://api.github.com/users/josh146/following{/other_user}", "gists_url": "https://api.github.com/users/josh146/gists{/gist_id}", "starred_url": "https://api.github.com/users/josh146/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/josh146/subscriptions", "organizations_url": "https://api.github.com/users/josh146/orgs", "repos_url": "https://api.github.com/users/josh146/repos", "events_url": "https://api.github.com/users/josh146/events{/privacy}", "received_events_url": "https://api.github.com/users/josh146/received_events", "type": "User", "site_admin": false}, "node_id": "MDc6UmVsZWFzZTE5ODY1Njk1", "tag_name": "v0.5.0", "target_commitish": "master", "name": "Release 0.5", "draft": false, "prerelease": false, "created_at": "2019-09-09T22:23:29Z", "published_at": "2019-09-09T22:33:16Z", "assets": [], "tarball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/tarball/v0.5.0", "zipball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/zipball/v0.5.0", "body": "### New features since last release\r\n\r\n* Adds a new optimizer, `qml.QNGOptimizer`, which optimizes QNodes using quantum natural gradient descent. See https://arxiv.org/abs/1909.02108 for more details. [#295](https://github.com/XanaduAI/pennylane/pull/295) [#311](https://github.com/XanaduAI/pennylane/pull/311)\r\n\r\n* Adds a new QNode method, `QNode.metric_tensor()`, which returns the block-diagonal approximation to the Fubini-Study metric tensor evaluated on the attached device. [#295](https://github.com/XanaduAI/pennylane/pull/295)\r\n\r\n* Sampling support: QNodes can now return a specified number of samples from a given observable via the top-level `pennylane.sample()` function. To support this on plugin devices, there is a new `Device.sample` method.\r\n\r\n  Calculating gradients of QNodes that involve sampling is not possible. [#256](https://github.com/XanaduAI/pennylane/pull/256)\r\n\r\n* `default.qubit` has been updated to provide support for sampling. [#256](https://github.com/XanaduAI/pennylane/pull/256)\r\n\r\n* Added controlled rotation gates to PennyLane operations and `default.qubit` plugin. [#251](https://github.com/XanaduAI/pennylane/pull/251)\r\n\r\n### Breaking changes\r\n\r\n* The method `Device.supported` was removed, and replaced with the methods `Device.supports_observable` and `Device.supports_operation`. Both methods can be called with string arguments (`dev.supports_observable('PauliX')`) and class arguments (`dev.supports_observable(qml.PauliX)`). [#276](https://github.com/XanaduAI/pennylane/pull/276)\r\n\r\n* The following CV observables were renamed to comply with the new Operation/Observable scheme: `MeanPhoton` to `NumberOperator`, `Homodyne` to `QuadOperator` and `NumberState` to `FockStateProjector`. [#243](https://github.com/XanaduAI/pennylane/pull/254)\r\n\r\n### Improvements\r\n\r\n* The `AmplitudeEmbedding` function now provides options to normalize and pad features to ensure a valid state vector is prepared. [#275](https://github.com/XanaduAI/pennylane/pull/275)\r\n\r\n* Operations can now optionally specify generators, either as existing PennyLane operations, or by providing a NumPy array. [#295](https://github.com/XanaduAI/pennylane/pull/295) [#313](https://github.com/XanaduAI/pennylane/pull/313)\r\n\r\n* Adds a `Device.parameters` property, so that devices can view a dictionary mapping free parameters to operation parameters. This will allow plugin devices to take advantage of parametric compilation. [#283](https://github.com/XanaduAI/pennylane/pull/283)\r\n\r\n* Introduces two enumerations: `Any` and `All`, representing any number of wires and all wires in the system respectively. They can be imported from `pennylane.operation`, and can be used when defining the `Operation.num_wires` class attribute of operations. [#277](https://github.com/XanaduAI/pennylane/pull/277)\r\n\r\n  As part of this change:\r\n\r\n  - `All` is equivalent to the integer 0, for backwards compatibility with the existing test suite\r\n\r\n  - `Any` is equivalent to the integer -1 to allow numeric comparison operators to continue working\r\n\r\n  - An additional validation is now added to the `Operation` class, which will alert the user that an operation with `num_wires = All` is being incorrectly.\r\n\r\n* The one-qubit rotations in `pennylane.plugins.default_qubit` no longer depend on Scipy's `expm`. Instead they are calculated with Euler's formula. [#292](https://github.com/XanaduAI/pennylane/pull/292)\r\n\r\n* Creates an `ObservableReturnTypes` enumeration class containing `Sample`, `Variance` and `Expectation`. These new values can be assigned to the `return_type` attribute of an `Observable`. [#290](https://github.com/XanaduAI/pennylane/pull/290)\r\n\r\n* Changed the signature of the `RandomLayer` and `RandomLayers` templates to have a fixed seed by default. [#258](https://github.com/XanaduAI/pennylane/pull/258)\r\n\r\n* `setup.py` has been cleaned up, removing the non-working shebang, and removing unused imports. [#262](https://github.com/XanaduAI/pennylane/pull/262)\r\n\r\n### Documentation\r\n\r\n* A documentation refactor to simplify the tutorials and include Sphinx-Gallery. [#291](https://github.com/XanaduAI/pennylane/pull/291)\r\n\r\n  - Examples and tutorials previously split across the `examples/` and `doc/tutorials/` directories, in a mixture of ReST and Jupyter notebooks, have been rewritten as Python scripts with ReST comments in a single location, the `examples/` folder.\r\n\r\n  - Sphinx-Gallery is used to automatically build and run the tutorials. Rendered output is displayed in the Sphinx documentation.\r\n\r\n  - Links are provided at the top of every tutorial page for downloading the tutorial as an executable python script, downloading the tutorial as a Jupyter notebook, or viewing the notebook on GitHub.\r\n\r\n  - The tutorials table of contents have been moved to a single quick start page.\r\n\r\n* Fixed a typo in `QubitStateVector`. [#295](https://github.com/XanaduAI/pennylane/pull/296)\r\n\r\n* Fixed a typo in the `default_gaussian.gaussian_state` function. [#293](https://github.com/XanaduAI/pennylane/pull/293)\r\n\r\n* Fixed a typo in the gradient recipe within the `RX`, `RY`, `RZ` operation docstrings. [#248](https://github.com/XanaduAI/pennylane/pull/248)\r\n\r\n* Fixed a broken link in the tutorial documentation, as a result of the `qml.expval.Observable` deprecation. [#246](https://github.com/XanaduAI/pennylane/pull/246)\r\n\r\n### Bug fixes\r\n\r\n* Fixed a bug where a `PolyXP` observable would fail if applied to subsets of wires on `default.gaussian`. [#277](https://github.com/XanaduAI/pennylane/pull/277)\r\n\r\n### Contributors\r\n\r\nThis release contains contributions from (in alphabetical order):\r\n\r\nSimon Cross, Aroosa Ijaz, Josh Izaac, Nathan Killoran, Johannes Jakob Meyer, Rohit Midha, Nicol\u00e1s Quesada, Maria Schuld, Antal Sz\u00e1va, Roeland Wiersema."}
{"url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/18161321", "assets_url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/18161321/assets", "upload_url": "https://uploads.github.com/repos/PennyLaneAI/pennylane/releases/18161321/assets{?name,label}", "html_url": "https://github.com/PennyLaneAI/pennylane/releases/tag/v0.4.0", "id": 18161321, "author": {"login": "co9olguy", "id": 7213358, "node_id": "MDQ6VXNlcjcyMTMzNTg=", "avatar_url": "https://avatars.githubusercontent.com/u/7213358?v=4", "gravatar_id": "", "url": "https://api.github.com/users/co9olguy", "html_url": "https://github.com/co9olguy", "followers_url": "https://api.github.com/users/co9olguy/followers", "following_url": "https://api.github.com/users/co9olguy/following{/other_user}", "gists_url": "https://api.github.com/users/co9olguy/gists{/gist_id}", "starred_url": "https://api.github.com/users/co9olguy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/co9olguy/subscriptions", "organizations_url": "https://api.github.com/users/co9olguy/orgs", "repos_url": "https://api.github.com/users/co9olguy/repos", "events_url": "https://api.github.com/users/co9olguy/events{/privacy}", "received_events_url": "https://api.github.com/users/co9olguy/received_events", "type": "User", "site_admin": false}, "node_id": "MDc6UmVsZWFzZTE4MTYxMzIx", "tag_name": "v0.4.0", "target_commitish": "master", "name": "Release 0.4", "draft": false, "prerelease": false, "created_at": "2019-06-22T18:34:33Z", "published_at": "2019-06-22T18:37:23Z", "assets": [], "tarball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/tarball/v0.4.0", "zipball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/zipball/v0.4.0", "body": "### New features since last release\r\n\r\n* `pennylane.expval()` is now a top-level *function*, and is no longer a package of classes. For now, the existing `pennylane.expval.Observable` interface continues to work, but will raise a deprecation warning.  [#232](https://github.com/XanaduAI/pennylane/pull/232)\r\n\r\n* Variance support: QNodes can now return the variance of observables, via the top-level `pennylane.var()` function. To support this on plugin devices, there is a new `Device.var` method.\r\n\r\n  The following observables support analytic gradients of variances:\r\n\r\n  - All qubit observables (requiring 3 circuit evaluations for involutory observables such as `Identity`, `X`, `Y`, `Z`; and 5 circuit evals for non-involutary observables, currently only `qml.Hermitian`)\r\n\r\n  - First-order CV observables (requiring 5 circuit evaluations)\r\n\r\n  Second-order CV observables support numerical variance gradients.\r\n\r\n* `pennylane.about()` function added, providing details on current PennyLane version, installed plugins, Python,\r\n  platform, and NumPy versions [#186](https://github.com/XanaduAI/pennylane/pull/186)\r\n\r\n* Removed the logic that allowed `wires` to be passed as a positional argument in quantum operations. This allows us to raise more useful error messages for the user if incorrect syntax is used. [#188](https://github.com/XanaduAI/pennylane/pull/188)\r\n\r\n* Adds support for multi-qubit expectation values of the `pennylane.Hermitian()` observable [#192](https://github.com/XanaduAI/pennylane/pull/192)\r\n\r\n* Adds support for multi-qubit expectation values in `default.qubit`. [#202](https://github.com/XanaduAI/pennylane/pull/202)\r\n\r\n* Organize templates into submodules [#195](https://github.com/XanaduAI/pennylane/pull/195). This included the following improvements:\r\n\r\n  - Distinguish embedding templates, layer templates, and parameter templates.\r\n\r\n  - New random initialization functions supporting the templates available in the new submodule `pennylane.init`.\r\n\r\n  - Added a random circuit template (`RandomLayers()`), in which rotations and 2-qubit gates are randomly distributed over the wires\r\n\r\n  - Add various embedding strategies\r\n\r\n### Breaking changes\r\n\r\n* The `Device` methods `expectations`, `pre_expval`, and `post_expval` have been renamed to `observables`, `pre_measure`, and `post_measure` respectively. [#232](https://github.com/XanaduAI/pennylane/pull/232)\r\n\r\n### Improvements\r\n\r\n* `default.qubit` plugin now uses `np.tensordot` when applying quantum operations and evaluating expectations, resulting in significant speedup [#239](https://github.com/XanaduAI/pennylane/pull/239), [#241](https://github.com/XanaduAI/pennylane/pull/241)\r\n\r\n* Allows division of quantum operation parameters by a constant [#179](https://github.com/XanaduAI/pennylane/pull/179)\r\n\r\n* Portions of the test suite are in the process of being ported to pytest. Note: this is still a work in progress.\r\n\r\n  Ported tests include:\r\n\r\n  - `test_ops.py`\r\n  - `test_about.py`\r\n  - `test_classical_gradients.py`\r\n  - `test_observables.py`\r\n  - `test_measure.py`\r\n  - `test_init.py`\r\n  - `test_templates*.py`\r\n  - `test_ops.py`\r\n  - `test_variable.py`\r\n  - `test_qnode.py` (partial)\r\n\r\n### Bug fixes\r\n\r\n* Fixes a bug in `Device.supported`, which would incorrectly mark an operation as supported if it shared a name with an observable [#203](https://github.com/XanaduAI/pennylane/pull/203)\r\n\r\n* Fixes a bug in `Operation.wires`, by explicitly casting the type of each wire to an integer [#206](https://github.com/XanaduAI/pennylane/pull/206)\r\n\r\n* Removes code in PennyLane which configured the logger, as this would clash with users' configurations [#208](https://github.com/XanaduAI/pennylane/pull/208)\r\n\r\n* Fixes a bug in `default.qubit`, in which `QubitStateVector` operations were accidentally being cast to `np.float` instead of `np.complex`. [#211](https://github.com/XanaduAI/pennylane/pull/211)\r\n\r\n\r\n### Contributors\r\n\r\nThis release contains contributions from:\r\n\r\nShahnawaz Ahmed, riveSunder, Aroosa Ijaz, Josh Izaac, Nathan Killoran, Maria Schuld."}
{"url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/16009401", "assets_url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/16009401/assets", "upload_url": "https://uploads.github.com/repos/PennyLaneAI/pennylane/releases/16009401/assets{?name,label}", "html_url": "https://github.com/PennyLaneAI/pennylane/releases/tag/v0.3.1", "id": 16009401, "author": {"login": "josh146", "id": 2959003, "node_id": "MDQ6VXNlcjI5NTkwMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/2959003?v=4", "gravatar_id": "", "url": "https://api.github.com/users/josh146", "html_url": "https://github.com/josh146", "followers_url": "https://api.github.com/users/josh146/followers", "following_url": "https://api.github.com/users/josh146/following{/other_user}", "gists_url": "https://api.github.com/users/josh146/gists{/gist_id}", "starred_url": "https://api.github.com/users/josh146/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/josh146/subscriptions", "organizations_url": "https://api.github.com/users/josh146/orgs", "repos_url": "https://api.github.com/users/josh146/repos", "events_url": "https://api.github.com/users/josh146/events{/privacy}", "received_events_url": "https://api.github.com/users/josh146/received_events", "type": "User", "site_admin": false}, "node_id": "MDc6UmVsZWFzZTE2MDA5NDAx", "tag_name": "v0.3.1", "target_commitish": "master", "name": "Release 0.3.1", "draft": false, "prerelease": false, "created_at": "2019-03-09T05:22:38Z", "published_at": "2019-03-09T05:27:26Z", "assets": [{"url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/assets/11441596", "id": 11441596, "node_id": "MDEyOlJlbGVhc2VBc3NldDExNDQxNTk2", "name": "PennyLane-0.3.1-py3-none-any.whl", "label": null, "uploader": {"login": "josh146", "id": 2959003, "node_id": "MDQ6VXNlcjI5NTkwMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/2959003?v=4", "gravatar_id": "", "url": "https://api.github.com/users/josh146", "html_url": "https://github.com/josh146", "followers_url": "https://api.github.com/users/josh146/followers", "following_url": "https://api.github.com/users/josh146/following{/other_user}", "gists_url": "https://api.github.com/users/josh146/gists{/gist_id}", "starred_url": "https://api.github.com/users/josh146/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/josh146/subscriptions", "organizations_url": "https://api.github.com/users/josh146/orgs", "repos_url": "https://api.github.com/users/josh146/repos", "events_url": "https://api.github.com/users/josh146/events{/privacy}", "received_events_url": "https://api.github.com/users/josh146/received_events", "type": "User", "site_admin": false}, "content_type": "application/octet-stream", "state": "uploaded", "size": 91730, "download_count": 21, "created_at": "2019-03-09T05:27:13Z", "updated_at": "2019-03-09T05:27:16Z", "browser_download_url": "https://github.com/PennyLaneAI/pennylane/releases/download/v0.3.1/PennyLane-0.3.1-py3-none-any.whl"}], "tarball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/tarball/v0.3.1", "zipball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/zipball/v0.3.1", "body": "### Bug fixes\r\n\r\n* Fixed a bug where the interfaces submodule was not correctly being packaged via setup.py."}
{"url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/15547696", "assets_url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/15547696/assets", "upload_url": "https://uploads.github.com/repos/PennyLaneAI/pennylane/releases/15547696/assets{?name,label}", "html_url": "https://github.com/PennyLaneAI/pennylane/releases/tag/v0.3.0", "id": 15547696, "author": {"login": "josh146", "id": 2959003, "node_id": "MDQ6VXNlcjI5NTkwMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/2959003?v=4", "gravatar_id": "", "url": "https://api.github.com/users/josh146", "html_url": "https://github.com/josh146", "followers_url": "https://api.github.com/users/josh146/followers", "following_url": "https://api.github.com/users/josh146/following{/other_user}", "gists_url": "https://api.github.com/users/josh146/gists{/gist_id}", "starred_url": "https://api.github.com/users/josh146/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/josh146/subscriptions", "organizations_url": "https://api.github.com/users/josh146/orgs", "repos_url": "https://api.github.com/users/josh146/repos", "events_url": "https://api.github.com/users/josh146/events{/privacy}", "received_events_url": "https://api.github.com/users/josh146/received_events", "type": "User", "site_admin": false}, "node_id": "MDc6UmVsZWFzZTE1NTQ3Njk2", "tag_name": "v0.3.0", "target_commitish": "master", "name": "Release 0.3", "draft": false, "prerelease": false, "created_at": "2019-02-13T23:41:19Z", "published_at": "2019-02-13T23:55:27Z", "assets": [{"url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/assets/11071013", "id": 11071013, "node_id": "MDEyOlJlbGVhc2VBc3NldDExMDcxMDEz", "name": "PennyLane-0.3.0-py3-none-any.whl", "label": null, "uploader": {"login": "josh146", "id": 2959003, "node_id": "MDQ6VXNlcjI5NTkwMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/2959003?v=4", "gravatar_id": "", "url": "https://api.github.com/users/josh146", "html_url": "https://github.com/josh146", "followers_url": "https://api.github.com/users/josh146/followers", "following_url": "https://api.github.com/users/josh146/following{/other_user}", "gists_url": "https://api.github.com/users/josh146/gists{/gist_id}", "starred_url": "https://api.github.com/users/josh146/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/josh146/subscriptions", "organizations_url": "https://api.github.com/users/josh146/orgs", "repos_url": "https://api.github.com/users/josh146/repos", "events_url": "https://api.github.com/users/josh146/events{/privacy}", "received_events_url": "https://api.github.com/users/josh146/received_events", "type": "User", "site_admin": false}, "content_type": "application/octet-stream", "state": "uploaded", "size": 82711, "download_count": 12, "created_at": "2019-02-13T23:50:07Z", "updated_at": "2019-02-13T23:50:07Z", "browser_download_url": "https://github.com/PennyLaneAI/pennylane/releases/download/v0.3.0/PennyLane-0.3.0-py3-none-any.whl"}], "tarball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/tarball/v0.3.0", "zipball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/zipball/v0.3.0", "body": "### New features since last release\r\n\r\n* PennyLane now includes a new `interfaces` submodule, which enables QNode integration with additional machine learning libraries (#165).\r\n* Adds support for an experimental PyTorch interface for QNodes\r\n* Adds support for an experimental TensorFlow eager execution interface for QNodes\r\n* Adds a PyTorch+GPU+QPU tutorial to the documentation\r\n* Documentation now includes links and tutorials including the new [PennyLane-Forest](https://github.com/rigetti/pennylane-forest) plugin.\r\n\r\n### Improvements\r\n\r\n* Printing a QNode object, via `print(qnode)` or in an interactive terminal, now displays more useful information regarding the QNode, including the device it runs on, the number of wires, it's interface, and the quantum function it uses:\r\n  ```python\r\n  >>> print(qnode)\r\n  <QNode: device='default.qubit', func=circuit, wires=2, interface=PyTorch>\r\n  ```\r\n\r\n### Contributors\r\n\r\nThis release contains contributions from:\r\n\r\nJosh Izaac and Nathan Killoran."}
{"url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/14287158", "assets_url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/14287158/assets", "upload_url": "https://uploads.github.com/repos/PennyLaneAI/pennylane/releases/14287158/assets{?name,label}", "html_url": "https://github.com/PennyLaneAI/pennylane/releases/tag/v0.2.0", "id": 14287158, "author": {"login": "josh146", "id": 2959003, "node_id": "MDQ6VXNlcjI5NTkwMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/2959003?v=4", "gravatar_id": "", "url": "https://api.github.com/users/josh146", "html_url": "https://github.com/josh146", "followers_url": "https://api.github.com/users/josh146/followers", "following_url": "https://api.github.com/users/josh146/following{/other_user}", "gists_url": "https://api.github.com/users/josh146/gists{/gist_id}", "starred_url": "https://api.github.com/users/josh146/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/josh146/subscriptions", "organizations_url": "https://api.github.com/users/josh146/orgs", "repos_url": "https://api.github.com/users/josh146/repos", "events_url": "https://api.github.com/users/josh146/events{/privacy}", "received_events_url": "https://api.github.com/users/josh146/received_events", "type": "User", "site_admin": false}, "node_id": "MDc6UmVsZWFzZTE0Mjg3MTU4", "tag_name": "v0.2.0", "target_commitish": "master", "name": "Release 0.2", "draft": false, "prerelease": false, "created_at": "2019-01-29T18:53:58Z", "published_at": "2019-01-30T21:52:34Z", "assets": [{"url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/assets/10839998", "id": 10839998, "node_id": "MDEyOlJlbGVhc2VBc3NldDEwODM5OTk4", "name": "PennyLane-0.2.0-py3-none-any.whl", "label": null, "uploader": {"login": "josh146", "id": 2959003, "node_id": "MDQ6VXNlcjI5NTkwMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/2959003?v=4", "gravatar_id": "", "url": "https://api.github.com/users/josh146", "html_url": "https://github.com/josh146", "followers_url": "https://api.github.com/users/josh146/followers", "following_url": "https://api.github.com/users/josh146/following{/other_user}", "gists_url": "https://api.github.com/users/josh146/gists{/gist_id}", "starred_url": "https://api.github.com/users/josh146/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/josh146/subscriptions", "organizations_url": "https://api.github.com/users/josh146/orgs", "repos_url": "https://api.github.com/users/josh146/repos", "events_url": "https://api.github.com/users/josh146/events{/privacy}", "received_events_url": "https://api.github.com/users/josh146/received_events", "type": "User", "site_admin": false}, "content_type": "application/octet-stream", "state": "uploaded", "size": 81006, "download_count": 11, "created_at": "2019-01-29T22:29:41Z", "updated_at": "2019-01-29T22:29:41Z", "browser_download_url": "https://github.com/PennyLaneAI/pennylane/releases/download/v0.2.0/PennyLane-0.2.0-py3-none-any.whl"}], "tarball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/tarball/v0.2.0", "zipball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/zipball/v0.2.0", "body": "### New features since last release\r\n\r\n* Added the `Identity` expectation value for both CV and qubit models (#135)\r\n* Added the `templates.py` submodule, containing some commonly used QML models to be used as ansatz in QNodes (#133)\r\n* Added the `qml.Interferometer` CV operation (#152)\r\n* Wires are now supported as free QNode parameters (#151)\r\n* Added ability to update stepsizes of the optimizers (#159)\r\n\r\n### Improvements\r\n\r\n* Removed use of hardcoded values in the optimizers, made them parameters (see #131 and #132)\r\n* Created the new `PlaceholderExpectation`, to be used when both CV and qubit expval modules contain expectations with the same name \r\n* Provide the plugins a way to view the operation queue _before_ applying operations. This allows for on-the-fly modifications of the queue, allowing hardware-based plugins to support the full range of qubit expectation values. (#143)\r\n* QNode return values now support _any_ form of sequence, such as lists, sets, etc. (#144)\r\n* CV analytic gradient calculation is now more robust, allowing for operations which may not themselves be differentiated, but have a well defined `_heisenberg_rep` method, and so may succeed operations that are analytically differentiable (#152)\r\n\r\n### Bug fixes\r\n\r\n* Fixed a bug where the variational classifier example was not batching when learning parity (see #128 and #129)\r\n* Fixed an inconsistency where some initial state operations were documented as accepting complex parameters - all operations now accept real values (#146)\r\n\r\n### Contributors\r\n\r\nThis release contains contributions from:\r\n\r\nChristian Gogolin, Josh Izaac, Nathan Killoran, and Maria Schuld."}
{"url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/13965318", "assets_url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/13965318/assets", "upload_url": "https://uploads.github.com/repos/PennyLaneAI/pennylane/releases/13965318/assets{?name,label}", "html_url": "https://github.com/PennyLaneAI/pennylane/releases/tag/v0.1.0", "id": 13965318, "author": {"login": "josh146", "id": 2959003, "node_id": "MDQ6VXNlcjI5NTkwMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/2959003?v=4", "gravatar_id": "", "url": "https://api.github.com/users/josh146", "html_url": "https://github.com/josh146", "followers_url": "https://api.github.com/users/josh146/followers", "following_url": "https://api.github.com/users/josh146/following{/other_user}", "gists_url": "https://api.github.com/users/josh146/gists{/gist_id}", "starred_url": "https://api.github.com/users/josh146/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/josh146/subscriptions", "organizations_url": "https://api.github.com/users/josh146/orgs", "repos_url": "https://api.github.com/users/josh146/repos", "events_url": "https://api.github.com/users/josh146/events{/privacy}", "received_events_url": "https://api.github.com/users/josh146/received_events", "type": "User", "site_admin": false}, "node_id": "MDc6UmVsZWFzZTEzOTY1MzE4", "tag_name": "v0.1.0", "target_commitish": "master", "name": "Release 0.1", "draft": false, "prerelease": false, "created_at": "2018-11-13T01:21:07Z", "published_at": "2018-11-13T01:41:25Z", "assets": [{"url": "https://api.github.com/repos/PennyLaneAI/pennylane/releases/assets/9665160", "id": 9665160, "node_id": "MDEyOlJlbGVhc2VBc3NldDk2NjUxNjA=", "name": "PennyLane-0.1.0-py3-none-any.whl", "label": null, "uploader": {"login": "josh146", "id": 2959003, "node_id": "MDQ6VXNlcjI5NTkwMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/2959003?v=4", "gravatar_id": "", "url": "https://api.github.com/users/josh146", "html_url": "https://github.com/josh146", "followers_url": "https://api.github.com/users/josh146/followers", "following_url": "https://api.github.com/users/josh146/following{/other_user}", "gists_url": "https://api.github.com/users/josh146/gists{/gist_id}", "starred_url": "https://api.github.com/users/josh146/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/josh146/subscriptions", "organizations_url": "https://api.github.com/users/josh146/orgs", "repos_url": "https://api.github.com/users/josh146/repos", "events_url": "https://api.github.com/users/josh146/events{/privacy}", "received_events_url": "https://api.github.com/users/josh146/received_events", "type": "User", "site_admin": false}, "content_type": "application/octet-stream", "state": "uploaded", "size": 72306, "download_count": 18, "created_at": "2018-11-13T01:41:19Z", "updated_at": "2018-11-13T01:41:22Z", "browser_download_url": "https://github.com/PennyLaneAI/pennylane/releases/download/v0.1.0/PennyLane-0.1.0-py3-none-any.whl"}], "tarball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/tarball/v0.1.0", "zipball_url": "https://api.github.com/repos/PennyLaneAI/pennylane/zipball/v0.1.0", "body": "First public release of PennyLane.\r\n\r\n### Contributors\r\n\r\nThis release contains contributions from:\r\n\r\nVille Bergholm, Josh Izaac, Maria Schuld, Christian Gogolin, and Nathan Killoran.\r\n"}
